<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Realtime Graph — ASR → LLM → TTS</title>
    <style>
        :root {
            --bg: #0b0f14;
            --panel: rgba(255, 255, 255, .07);
            --panel2: rgba(255, 255, 255, .05);
            --accent: #66e0ff;
            --accent2: #a8ff60;
            --text: #e8f1f8;
            --muted: #a9b6c3;
            --ok: #7dffb0;
            --warn: #f9c846;
            --err: #ff6b6b;
            --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            --r: 16px;
            --shadow: 0 10px 30px rgba(0, 0, 0, .35), inset 0 0 1px rgba(255, 255, 255, .12)
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            color: var(--text);
            font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial
        }

        body::after {
            content: '';
            position: fixed;
            inset: 0;
            z-index: -1;
            background:
                radial-gradient(1200px 800px at 10% -10%, #163147, transparent 60%),
                radial-gradient(900px 600px at 100% 0%, #1b2d18, transparent 55%),
                var(--bg)
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 18px
        }

        .brand {
            display: flex;
            gap: 12px;
            align-items: center
        }

        .logo {
            width: 36px;
            height: 36px;
            border-radius: 12px;
            background: conic-gradient(from 220deg, var(--accent), #9f78ff, var(--accent2));
            box-shadow: var(--shadow)
        }

        h1 {
            margin: 0;
            font-size: 18px
        }

        .hint {
            color: var(--muted);
            font-size: 12px
        }

        .badge {
            display: inline-flex;
            gap: 8px;
            align-items: center;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .15);
            background: rgba(255, 255, 255, .06)
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%
        }

        .dot.ok {
            background: var(--ok);
            box-shadow: 0 0 10px var(--ok)
        }

        .dot.warn {
            background: var(--warn);
            box-shadow: 0 0 10px var(--warn)
        }

        .dot.err {
            background: var(--err);
            box-shadow: 0 0 10px var(--err)
        }

        main {
            display: grid;
            gap: 14px;
            padding: 0 18px 24px;
            grid-template-columns: repeat(12, 1fr)
        }

        .card {
            grid-column: span 12;
            background: var(--panel);
            border: 1px solid rgba(255, 255, 255, .08);
            border-radius: var(--r);
            backdrop-filter: blur(8px);
            padding: 14px
        }

        @media(min-width:980px) {
            .span-4 {
                grid-column: span 4
            }

            .span-8 {
                grid-column: span 8
            }
        }

        h2 {
            margin: 0 0 8px;
            font-size: 15px
        }

        .row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center
        }

        label {
            font-size: 12px;
            color: var(--muted);
            margin-right: 6px
        }

        input,
        select,
        textarea {
            width: 100%;
            background: var(--panel2);
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, .15);
            border-radius: 12px;
            padding: 9px 11px;
            outline: none
        }

        textarea {
            min-height: 84px;
            resize: vertical
        }

        button {
            background: linear-gradient(180deg, rgba(102, 224, 255, .9), rgba(102, 224, 255, .6));
            color: #001018;
            border: 0;
            border-radius: 12px;
            padding: 9px 12px;
            font-weight: 700;
            cursor: pointer
        }

        button.secondary {
            background: linear-gradient(180deg, rgba(168, 255, 96, .9), rgba(168, 255, 96, .6));
            color: #021204
        }

        button.ghost {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, .2);
            color: var(--text)
        }

        button.danger {
            background: linear-gradient(180deg, rgba(255, 107, 107, .95), rgba(255, 107, 107, .7));
            color: #280a0a
        }

        .code {
            font-family: var(--mono);
            font-size: 12px;
            background: #04070b;
            border: 1px solid rgba(255, 255, 255, .12);
            border-radius: 12px;
            padding: 10px;
            white-space: pre-wrap;
            max-height: 260px;
            overflow: auto
        }

        .bubble {
            background: rgba(255, 255, 255, .06);
            border: 1px solid rgba(255, 255, 255, .12);
            padding: 10px;
            border-radius: 12px
        }

        .muted {
            color: var(--muted);
            font-size: 12px
        }

        .vu {
            height: 8px;
            border-radius: 999px;
            background: rgba(255, 255, 255, .08);
            border: 1px solid rgba(255, 255, 255, .15);
            overflow: hidden
        }

        .vu>b {
            display: block;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #22c55e, #eab308, #ef4444)
        }

        .port {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 3px 8px;
            border: 1px dashed rgba(255, 255, 255, .25);
            border-radius: 999px;
            font-family: var(--mono);
            font-size: 12px;
            cursor: pointer
        }

        .port.sel {
            background: rgba(255, 255, 255, .1)
        }

        audio {
            width: 100%;
            height: 36px
        }

        .kv {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 8px
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border: 1px solid rgba(255, 255, 255, .18);
            border-radius: 999px;
            background: rgba(255, 255, 255, .06);
            font-family: var(--mono);
            font-size: 12px
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/nkn-sdk@1.3.6/dist/nkn.min.js"></script>
</head>

<body>
    <header>
        <div class="brand">
            <div class="logo"></div>
            <div>
                <h1>Realtime Graph</h1>
                <div class="hint">ASR → LLM → TTS · HTTP or NKN · streaming phrases + smoothed VAD</div>
            </div>
        </div>
        <div id="status" class="badge"><span class="dot warn"></span><span>Booting…</span></div>
    </header>

    <main>
        <!-- GLOBAL -->
        <section class="card span-12">
            <h2>Global</h2>
            <div class="row">
                <label>Transport</label>
                <select id="transport">
                    <option value="http">HTTP(S)</option>
                    <option value="nkn">NKN Relay</option>
                </select>
                <button id="nknConnect">Connect NKN</button>
                <button class="ghost" id="nknDisconnect">Disconnect</button>
                <button class="secondary" id="saveAll">Save</button>
                <span class="muted">NKN: <b id="nknInfo">disconnected</b></span>
            </div>
        </section>

        <!-- ASR -->
        <section class="card span-4" id="asrCard">
            <h2>ASR</h2>
            <div class="kv">
                <label>Base URL</label><input id="asrBase" placeholder="http://localhost:8126" />
                <label>NKN Relay</label><input id="asrRelay" placeholder="(full NKN address)" />
                <label>API Key</label><input id="asrApi" placeholder="(optional)" />
                <label>Model</label>
                <input id="asrModel" list="asrModelList" placeholder="base · small · medium · large-v3" />
                <datalist id="asrModelList"></datalist>
                <label>Rate</label><input id="asrRate" type="number" value="16000" />
                <label>Chunk (ms)</label><input id="asrChunk" type="number" value="120" />
                <label>Live</label><select id="asrLive">
                    <option value="true" selected>true</option>
                    <option value="false">false</option>
                </select>

                <!-- VAD -->
                <label>VAD Thresh</label><input id="asrRms" type="number" step="0.001" value="0.3" />
                <label>VAD Hangover (ms)</label><input id="asrHold" type="number" value="300" />
                <label>EMA Window (ms)</label><input id="asrEmaMs" type="number" value="100" />

                <!-- phrase streaming -->
                <label>Phrase Stream</label><select id="asrPhraseOn">
                    <option value="true" selected>on</option>
                    <option value="false">off</option>
                </select>
                <label>Min Words</label><input id="asrPhraseMin" type="number" value="3" />
                <label>Stable (ms)</label><input id="asrPhraseStable" type="number" value="350" />

                <!-- batch-only silence -->
                <label>Silence End (ms)</label><input id="asrSilence" type="number" value="1100" />

                <!-- prompt -->
                <label>Prompt</label>
                <textarea id="asrPrompt" placeholder="Bias decoding: keywords, names, spellings…"></textarea>
            </div>
            <div class="row" style="margin-top:8px;">
                <button id="asrStart">Start</button>
                <button class="danger" id="asrStop">Stop</button>
                <button id="asrRefresh">Refresh Models</button>

                <span class="pill"><span class="dot ok" id="asrDot"></span><b id="asrState">idle</b></span>
                <span class="pill">buf:<b id="asrBuf">0</b></span>
                <span class="pill">out:<b id="asrOut">0</b></span>
                <span class="pill">events:<b id="asrEvt">—</b></span>
            </div>
            <div class="row" style="margin-top:6px;">
                <div class="vu" style="flex:1"><b id="asrVu"></b></div>
                <span class="muted">VAD: <span id="asrVad">idle</span></span>
                <span class="muted">RMS: <span id="asrRmsVal">0</span></span>
            </div>
            <div class="row" style="margin-top:8px;">
                <span class="port" data-port="asr:partial">out · partial</span>
                <span class="port" data-port="asr:phrase">out · phrase</span>
                <span class="port" data-port="asr:final">out · final</span>
            </div>
            <div class="muted" style="margin-top:8px;">Partial</div>
            <div id="asrPartial" class="bubble" style="min-height:38px"></div>
            <div class="muted" style="margin-top:8px;">Phrases (streamed)</div>
            <div id="asrPhrases" class="bubble" style="min-height:38px;max-height:96px;overflow:auto"></div>
            <div class="muted" style="margin-top:8px;">Finals</div>
            <div id="asrFinals" class="code" style="min-height:70px"></div>
            <div class="muted" id="asrMeta" style="margin-top:6px;">—</div>
        </section>

        <!-- LLM -->
        <section class="card span-4" id="llmCard">
            <h2>LLM (Ollama)</h2>

            <div class="kv">
                <label>Base URL</label><input id="llmBase" placeholder="http://127.0.0.1:11434" />
                <label>NKN Relay</label><input id="llmRelay" placeholder="(full NKN address)" />
                <label>API Key</label><input id="llmApi" placeholder="(optional)" />
                <label>Model</label><select id="llmModel"></select>
                <label>Stream</label>
                <select id="llmStream">
                    <option value="true" selected>true</option>
                    <option value="false">false</option>
                </select>
            </div>

            <!-- System & Memory controls -->
            <div class="kv" style="margin-top:8px;">
                <label>Use System Message</label>
                <select id="llmUseSystem">
                    <option value="false" selected>false</option>
                    <option value="true">true</option>
                </select>

                <label>Use Chat Memory</label>
                <select id="llmMemory">
                    <option value="false" selected>false</option>
                    <option value="true">true</option>
                </select>

                <label>Persist Memory</label>
                <select id="llmPersistMemory">
                    <option value="false" selected>false</option>
                    <option value="true">true</option>
                </select>

                <label>Max Turns</label>
                <input id="llmMaxTurns" type="number" min="1" step="1" placeholder="16" />
            </div>

            <div class="row" style="margin-top:8px;">
                <label style="width:100%; display:block; margin-bottom:4px;">System Prompt</label>
                <textarea id="llmSystem" rows="3" placeholder="(optional system message)"
                    style="width:100%;"></textarea>
            </div>

            <div class="row" style="margin-top:8px;">
                <button id="llmRefresh">Refresh Models</button>
                <button id="llmClearMemory" class="secondary">Clear Memory</button>
                <span class="pill"><span class="dot warn" id="llmDot"></span><b id="llmState">idle</b></span>
                <span class="pill">tokens:<b id="llmTok">0</b></span>
                <span class="pill">bytes:<b id="llmBytes">0</b></span>
                <span class="pill">elapsed:<b id="llmMs">0ms</b></span>
                <span class="pill">memory:<b id="llmMemSize">0</b></span>
            </div>

            <div class="row" style="margin-top:6px;">
                <span class="port" data-port="llm:prompt">in · prompt</span>
                <span class="port" data-port="llm:delta">out · delta</span>
                <span class="port" data-port="llm:final">out · final</span>
                <!-- optional, if you want to listen for memory updates you already emit -->
                <span class="port" data-port="llm:memory">out · memory</span>
            </div>

            <div class="muted" style="margin-top:8px;">Streaming tokens</div>
            <div id="llmTokens" class="code" style="min-height:80px"></div>
        </section>


        <!-- TTS -->
        <section class="card span-4" id="ttsCard">
            <h2>TTS</h2>
            <div class="kv">
                <label>Base URL</label><input id="ttsBase" placeholder="http://localhost:8123" />
                <label>NKN Relay</label><input id="ttsRelay" placeholder="(full NKN address)" />
                <label>API Key</label><input id="ttsApi" placeholder="(optional)" />
                <label>Voice</label><input id="ttsModel" list="ttsModelList"
                    placeholder="glados_piper_medium or voices/*.onnx" />
                <datalist id="ttsModelList"></datalist>
                <label>Mode</label><select id="ttsMode">
                    <option value="stream" selected>stream (raw)</option>
                    <option value="file">file (ogg)</option>
                </select>
            </div>
            <div class="row" style="margin-top:8px;">
                <button id="ttsRefresh">Refresh Voices</button>
                <span class="pill"><span class="dot warn" id="ttsDot"></span><b id="ttsState">idle</b></span>
                <span class="pill">chunks:<b id="ttsChunks">0</b></span>
                <span class="pill">bytes:<b id="ttsBytes">0</b></span>
                <span class="pill">buf samp:<b id="ttsBuf">0</b></span>
                <span class="pill">buf ms:<b id="ttsBufMs">0</b></span>
                <span class="pill">underruns:<b id="ttsUrun">0</b></span>
                <span class="pill">AC:<b id="ttsAC">—</b></span>
            </div>
            <div class="row" style="margin-top:6px;">
                <span class="port" data-port="tts:text">in · text</span>
            </div>
            <audio id="ttsAudio" controls style="margin-top:8px"></audio>
            <div class="muted" id="ttsMeta" style="margin-top:6px;">—</div>
        </section>

        <!-- WIRES -->
        <section class="card span-12">
            <h2>Wires</h2>
            <div class="row">
                <button class="secondary" id="wireToggle">Wire Mode: <b id="wireState">ON</b></button>
                <button class="ghost" id="clearWires">Clear</button>
                <span class="muted">Click source then destination to connect.</span>
            </div>
            <div id="wiresBox" class="code" style="margin-top:8px;min-height:54px"></div>
        </section>

        <!-- LOGS -->
        <section class="card span-12">
            <h2>Status / Logs</h2>
            <div id="logBox" class="code" style="min-height:120px">(logs)</div>
        </section>
    </main>

    <script>
        // --- Anti-signoff defaults ---
        const ASR_DEFAULT_PROMPT =
            "Context: live interactive conversation, not a video or broadcast. " +
            "Transcribe exactly what is spoken. Do not add generic media sign-offs. " +
            "Avoid phrases such as: \"thanks for watching\", \"like and subscribe\", " +
            "\"don't forget to subscribe\", \"link in the description\".";

        const SIGNOFF_RE = /\b(thanks(?:,)?\s+for\s+(?:watching|listening)|(?:don['’]t\s+forget\s+to\s+)?(?:like|subscribe)|like\s+and\s+subscribe|link\s+in\s+(?:the\s+)?description)\b/i;

        /* ======== tiny helpers ======== */
        const LS = { get(k, d) { try { const v = localStorage.getItem(k); return v ? JSON.parse(v) : d } catch { return d } }, set(k, v) { localStorage.setItem(k, JSON.stringify(v)) } };
        const qs = s => document.querySelector(s); const qsa = s => Array.from(document.querySelectorAll(s));
        const j = x => { try { return JSON.stringify(x, null, 2) } catch { return String(x) } };
        function log(s) { const b = qs('#logBox'); if (!b) return; b.textContent = (b.textContent + '\n' + s).trim().slice(-9000); b.scrollTop = b.scrollHeight }
        function setBadge(msg, ok = true) { const el = qs('#status'); if (!el) return; el.innerHTML = `<span class="dot ${ok ? 'ok' : 'err'}"></span><span>${msg}</span>`; }
        const td = new TextDecoder(); function b64ToBytes(b64) { const bin = atob(b64); const u8 = new Uint8Array(bin.length); for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i); return u8 }

        /* ======== persisted config ======== */
        const CFG = LS.get('graph.cfg', {
            transport: 'http',
            asr: {
                base: 'http://localhost:8126', relay: '', api: '',
                rate: 16000, chunk: 120, live: true,
                rms: 0.015, hold: 250, emaMs: 120,
                phraseOn: true, phraseMin: 3, phraseStable: 350,
                silence: 900,
                prompt: '',
                model: ''
            },
            llm: { base: 'http://127.0.0.1:11434', relay: '', api: '', model: '', stream: true },
            tts: { base: 'http://localhost:8123', relay: '', api: '', model: '', mode: 'stream' },
            wireMode: true,
            wires: [{ from: 'asr:phrase', to: 'llm:prompt' }, { from: 'llm:final', to: 'tts:text' }]
        });

        function saveCFG() { LS.set('graph.cfg', CFG) }

        /* ======== network (http+nkn) ======== */
        const Net = {
            nkn: { client: null, ready: false, addr: '', pend: new Map(), streams: new Map() },
            auth(h = {}, api) {
                const out = Object.assign({}, h);
                if (!out['Content-Type']) out['Content-Type'] = 'application/json';
                if (api) {
                    if (/^Bearer\s+/i.test(api)) out['Authorization'] = api;
                    else out['X-API-Key'] = api;
                }
                return out;
            },
            async getJSON(base, path, api, useNkn, relay) {
                if (!useNkn) {
                    const headers = this.auth({}, api);
                    delete headers['Content-Type'];          // ← remove for GET
                    headers['Accept'] = 'application/json';
                    const r = await fetch(base.replace(/\/+$/, '') + path, { headers });
                    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
                    return r.json();
                }
                return this.nknFetch(base, path, 'GET', null, api, relay);
            },
            async postJSON(base, path, body, api, useNkn, relay, timeout = 45000) {
                if (!useNkn) {
                    const r = await fetch(base.replace(/\/+$/, '') + path, { method: 'POST', headers: this.auth({}, api), body: JSON.stringify(body || {}) });
                    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`); return r.json();
                }
                return this.nknFetch(base, path, 'POST', body, api, relay, timeout)
            },
            async fetchBlob(fullUrl, useNkn, relay, api) {
                if (!useNkn) { const r = await fetch(fullUrl, { headers: this.auth({}, api) }); if (!r.ok) throw new Error(`${r.status} ${r.statusText}`); return r.blob() }
                return this.nknFetchBlob(fullUrl, relay, api)
            },
            ensureNkn() {
                if (CFG.transport !== 'nkn') return;
                if (this.nkn.client) return;
                if (!window.nkn || !window.nkn.MultiClient) { setBadge('nkn-sdk missing', false); return }
                const c = new window.nkn.MultiClient({ identifier: 'graph', numSubClients: 4, wsConnHeartbeatTimeout: 60000 }); this.nkn.client = c;
                c.on('connect', () => { this.nkn.ready = true; this.nkn.addr = c.addr || ''; const i = qs('#nknInfo'); if (i) i.textContent = `connected • ${this.nkn.addr.slice(0, 10)}…`; setBadge('NKN ready') });
                c.on('close', () => { this.nkn.ready = false; const i = qs('#nknInfo'); if (i) i.textContent = 'connecting…' });

                c.on('message', (a, b) => {
                    let p = (a && typeof a === 'object' && a.payload !== undefined) ? a.payload : b;
                    try {
                        const msg = JSON.parse((p && p.toString) ? p.toString() : String(p));
                        const ev = msg.event || ''; const id = msg.id;

                        if (ev === 'relay.response' && id) {
                            const pr = this.nkn.pend.get(id);
                            if (pr) { clearTimeout(pr.t); this.nkn.pend.delete(id); pr.res(msg) }
                            return;
                        }

                        if (/^relay\.response\.(begin|chunk|end|lines)$/.test(ev) && id) {
                            const st = this.nkn.streams.get(id); if (!st) return;
                            if (ev === 'relay.response.begin') { st.onBegin && st.onBegin(msg); return }
                            if (ev === 'relay.response.chunk') { const u8 = b64ToBytes(msg.b64 || ''); st.onChunk && st.onChunk(u8, msg.seq | 0); return }
                            if (ev === 'relay.response.lines') {
                                const arr = Array.isArray(msg.lines) ? msg.lines : [];
                                for (const it of arr) { try { st.onLine && st.onLine(it.line, it.seq | 0, it.ts) } catch { } }
                                return;
                            }
                            if (ev === 'relay.response.end') { try { st.onEnd && st.onEnd(msg) } finally { this.nkn.streams.delete(id) } return }
                        }
                    } catch { }
                });
            },
            async nknSend(req, relay, timeout = 45000) {
                if (!relay) throw new Error('No relay'); if (!this.nkn.client) this.ensureNkn();
                const id = 'g-' + Date.now() + '-' + Math.random().toString(36).slice(2);
                return new Promise((res, rej) => {
                    const t = setTimeout(() => { this.nkn.pend.delete(id); rej(new Error('NKN relay timeout')) }, timeout);
                    this.nkn.pend.set(id, { res, rej, t });
                    this.nkn.client.send(relay, JSON.stringify({ event: 'http.request', id, req }), { noReply: true, maxHoldingSeconds: 120 })
                        .catch(e => { clearTimeout(t); this.nkn.pend.delete(id); rej(e) });
                });
            },
            async nknStream(req, relay, handlers = {}, timeout = 300000) {
                if (!relay) throw new Error('No relay');
                if (!this.nkn.client) this.ensureNkn();
                const id = 'g-' + Date.now() + '-' + Math.random().toString(36).slice(2);

                return new Promise(async (resolve, reject) => {
                    let to = null;
                    const wrapped = {
                        onBegin: (...args) => { try { handlers.onBegin && handlers.onBegin(...args) } catch { } },
                        onLine: (...args) => { try { handlers.onLine && handlers.onLine(...args) } catch { } },
                        onChunk: (...args) => { try { handlers.onChunk && handlers.onChunk(...args) } catch { } },
                        onEnd: (...args) => { try { handlers.onEnd && handlers.onEnd(...args) } catch { } finally { clearTimeout(to); this.nkn.streams.delete(id); resolve(); } },
                        onError: (err) => { clearTimeout(to); this.nkn.streams.delete(id); reject(err instanceof Error ? err : new Error(String(err || 'nkn stream error'))) }
                    };
                    this.nkn.streams.set(id, wrapped);

                    try {
                        await this.nkn.client.send(
                            relay,
                            JSON.stringify({ event: 'http.request', id, req: Object.assign({ stream: 'chunks' }, req) }),
                            { noReply: true, maxHoldingSeconds: 120 }
                        );
                    } catch (e) { this.nkn.streams.delete(id); return reject(e); }

                    to = setTimeout(() => {
                        const st = this.nkn.streams.get(id);
                        if (st) { this.nkn.streams.delete(id); reject(new Error('NKN stream timeout')); }
                    }, timeout);
                });
            },
            async nknFetch(base, path, method, json, api, relay, timeout = 45000) {
                const headers = this.auth({}, api);
                if (method === 'GET') {
                    delete headers['Content-Type'];          // ← avoid preflight in relay
                    headers['Accept'] = 'application/json';
                }
                const req = { url: base.replace(/\/+$/, '') + path, method, headers, timeout_ms: timeout };
                if (json !== null) req.json = json;
                const r = await this.nknSend(req, relay, timeout); if (!r || r.ok === false) throw new Error((r && r.error) || ('HTTP ' + (r && r.status)));
                if (r.json !== undefined && r.json !== null) return r.json;
                if (r.body_b64) { const u8 = b64ToBytes(r.body_b64); return JSON.parse(td.decode(u8)) }
                return null;
            },
            async nknFetchBlob(fullUrl, relay, api) {
                const parts = []; let ctype = 'application/octet-stream';
                await this.nknStream({ url: fullUrl, method: 'GET', headers: this.auth({ 'X-Relay-Stream': 'chunks' }, api), timeout_ms: 10 * 60 * 1000 }, relay, {
                    onBegin: (m) => { const h = m.headers || {}; ctype = h['content-type'] || h['Content-Type'] || ctype },
                    onChunk: (u8) => parts.push(u8),
                    onEnd: () => { }
                });
                return new Blob(parts, { type: ctype })
            }
        };

        /* ======== wiring ======== */
        const Router = {
            ports: new Map(), wires: CFG.wires.slice(), sel: null,
            register(key, el, onrecv) { if (!el) return; this.ports.set(key, { el, onrecv }); el.addEventListener('click', () => { if (!CFG.wireMode) return; if (!this.sel) { this.sel = key; el.classList.add('sel'); return } const from = this.sel; this.clearSel(); if (from === key) return; if (!this.wires.find(w => w.from === from && w.to === key)) { this.wires.push({ from, to: key }); CFG.wires = this.wires.slice(); saveCFG(); this.render(); log(`wired ${from} → ${key}`) } }) },
            clearSel() { qsa('.port.sel').forEach(e => e.classList.remove('sel')); this.sel = null },
            send(from, payload) { for (const w of this.wires) { if (w.from === from) { const p = this.ports.get(w.to); try { p && p.onrecv && p.onrecv(payload, from, w.to) } catch (e) { log(`wire error ${w.from}→${w.to}: ${e.message}`) } } } },
            render() { const box = qs('#wiresBox'); if (!box) return; box.textContent = this.wires.length ? this.wires.map((w, i) => `${i + 1}. ${w.from} → ${w.to}`).join('\n') : '(no wires)' },
            clear() { this.wires.length = 0; CFG.wires = []; saveCFG(); this.render() }
        };

        /* ======== ASR ======== */
        const ASR = {
            running: false, ac: null, node: null, media: null, source: null,
            bufF32: new Float32Array(0), out: 0, sid: null,

            _sawSpeech: false,
            finalizing: false,
            _vadWatch: null,

            // de-dupe window for identical final text (ms)
            _DEDUP_MS: 1500,
            _lastFinal: { text: '', at: 0 },

            // VAD state
            vad: { ema: 0, state: 'silence', lastVoice: 0, lastSilence: 0 },

            // phrase stream aggregator
            aggr: { prev: '', pend: '', pendStart: 0, lastChange: 0, lastEmit: 0 },

            // model refresh cadence
            models: [],
            _timer: null,
            _slow: 180000,
            _fast: 30000,

            // ─────────────────────────────────────────────────────────────
            // VAD-gated uplink & pre-roll ring buffer + linger
            // ─────────────────────────────────────────────────────────────
            _uplinkOn: false,
            _tailDeadline: 0,
            _preMs: 450,
            _preMaxSamples: 0,
            _preSamples: 0,
            _preChunks: [],
            _sawPartialForUplink: false,
            _lastPartialAt: 0,
            _lastPostAt: 0,

            // timing knobs
            _lingerMs: 700,         // wait this long after last POST/partial before /end
            _minTailMs: 350,        // minimum post-silence tail
            _forceQuietMaxMs: 2800, // hard cap: force finalize if quiet this long

            // AFTER-FINAL cleanup (only for the session that produced the final)
            _afterFinalCleanupForSid(expectedSid) {
                // clear partial & phrases only for the session that just finalized
                const p = qs('#asrPartial'); if (p) p.textContent = '';
                const ph = qs('#asrPhrases'); if (ph) ph.textContent = '';
                this.resetAggr();
                this._sawPartialForUplink = false;
                // do NOT clear finals here
            },

            _preInit(rate) {
                this._preMaxSamples = Math.max(1, Math.round(rate * (this._preMs / 1000)));
                this._preSamples = 0;
                this._preChunks = [];
            },
            _prePush(f32) {
                // keep ring at target rate regardless of uplink state
                this._preChunks.push(f32);
                this._preSamples += f32.length;
                while (this._preSamples > this._preMaxSamples && this._preChunks.length) {
                    const drop = this._preChunks.shift();
                    this._preSamples -= drop.length;
                }
            },
            _preFlushToSend() {
                for (const ch of this._preChunks) this.pushF32(ch);
                this._preChunks = [];
                this._preSamples = 0;
            },

            _openUplink(now, tailMs, currentBlockF32) {
                if (this._uplinkOn) return;
                this._uplinkOn = true;
                this._sawPartialForUplink = false;
                this._lastPartialAt = 0;
                this._tailDeadline = now + tailMs;
                // send pre-roll, then this voice block
                this._preFlushToSend();
                if (currentBlockF32) this.pushF32(currentBlockF32);
            },
            _extendTail(now, tailMs) { this._tailDeadline = now + tailMs; },

            _closeUplinkAndMaybeFinalize() {
                if (!this._uplinkOn) return;
                this._uplinkOn = false;
                // Drain any queued audio (already buffered) and then /end
                this._drainAndEnd().catch(e => log('[asr] finalize(gate) ' + (e?.message || e)));
            },

            // ===== model discovery =====
            async _probeModels() {
                const viaNkn = CFG.transport === 'nkn';
                const base = CFG.asr.base, relay = CFG.asr.relay, api = CFG.asr.api;

                const normalize = (data) => {
                    const pick = (arr) => arr.map(m =>
                        typeof m === 'string' ? m : (m && (m.name || m.model || m.id || m.tag)) || ''
                    ).filter(Boolean);
                    if (!data || typeof data !== 'object') return Array.isArray(data) ? pick(data) : [];
                    if (Array.isArray(data)) return pick(data);
                    if (Array.isArray(data.models)) return pick(data.models);
                    if (Array.isArray(data.items)) return pick(data.items);
                    if (Array.isArray(data.data)) return pick(data.data);
                    return [];
                };

                try {
                    const data = await Net.getJSON(base, '/models', api, viaNkn, relay);
                    const arr = normalize(data);
                    return { arr, current: data?.current || {} };
                } catch { }

                for (const p of ['/api/models', '/whisper/models', '/recognize/models']) {
                    try {
                        const resp = await Net.getJSON(base, p, api, viaNkn, relay);
                        const arr = normalize(resp);
                        if (arr.length) return { arr, current: {} };
                    } catch { }
                }
                return { arr: [], current: {} };
            },

            async refreshModels() {
                try {
                    const { arr, current } = await this._probeModels();
                    this.models = arr;

                    const dl = qs('#asrModelList'); if (dl) {
                        dl.innerHTML = '';
                        arr.forEach(n => { const o = document.createElement('option'); o.value = n; dl.appendChild(o); });
                    }

                    const prefer = current.full || current.preview || '';
                    const want = (prefer && arr.includes(prefer)) ? prefer
                        : (CFG.asr.model && arr.includes(CFG.asr.model)) ? CFG.asr.model
                            : (arr[0] || '');

                    CFG.asr.model = want;
                    const inp = qs('#asrModel'); if (inp) inp.value = want;
                    const meta = qs('#asrMeta'); if (meta) meta.textContent = arr.length ? `ASR models: ${arr.join(', ')}` : '—';
                    saveCFG();
                } catch (e) {
                    log('[asr] models ' + (e?.message || e));
                } finally {
                    clearTimeout(this._timer);
                    const healthy = this.models.length > 0;
                    this._timer = setTimeout(() => this.refreshModels(), healthy ? this._slow : this._fast);
                }
            },

            // ===== tiny utils =====
            pushF32(f32) { const a = this.bufF32, b = f32; const out = new Float32Array(a.length + b.length); out.set(a, 0); out.set(b, a.length); this.bufF32 = out; const el = qs('#asrBuf'); if (el) el.textContent = String(out.length) },
            drainF32(n) { const a = this.bufF32; const take = Math.min(a.length, n); const head = a.subarray(0, take); this.bufF32 = a.subarray(take).slice(0); const el = qs('#asrBuf'); if (el) el.textContent = String(this.bufF32.length); return head },
            vu(p) { const el = qs('#asrVu'); if (el) el.style.width = Math.max(0, Math.min(100, Math.round(p * 150))) + '%' },
            resample(f, fr, tr) { if (fr === tr) return f.slice(0); const r = tr / fr, L = Math.round(f.length * r), o = new Float32Array(L); for (let i = 0; i < L; i++) { const pos = i / r, i0 = Math.floor(pos), i1 = Math.min(i0 + 1, f.length - 1), t = pos - i0; o[i] = f[i0] * (1 - t) + f[i1] * t } return o },
            i16(f32) { const o = new Int16Array(f32.length); for (let i = 0; i < f32.length; i++) { const v = Math.max(-1, Math.min(1, f32[i])); o[i] = v < 0 ? v * 0x8000 : v * 0x7FFF } return new Uint8Array(o.buffer) },
            setState(txt, cls = 'ok') { const s = qs('#asrState'); const d = qs('#asrDot'); if (s) s.textContent = txt; if (d) d.className = 'dot ' + (cls === 'ok' ? 'ok' : cls === 'err' ? 'err' : 'warn') },
            printPartial(t) { const el = qs('#asrPartial'); if (el) el.textContent = t || ''; Router.send('asr:partial', { type: 'text', text: t || '' }) },

            addPhrase(t) {
                if (!t) return;
                const box = qs('#asrPhrases');
                if (box) { box.textContent = (box.textContent ? box.textContent + '\n' : '') + t; box.scrollTop = box.scrollHeight; }
                Router.send('asr:phrase', { type: 'text', text: t });
            },

            appendFinal(t) {
                const s = (t || '').trim().replace(/\s+/g, ' ');
                if (!s) return;
                const now = performance.now();
                if (s === this._lastFinal.text && (now - this._lastFinal.at) <= this._DEDUP_MS) { log('[asr] final deduped: "' + s + '"'); return; }
                this._lastFinal.text = s; this._lastFinal.at = now;
                const box = qs('#asrFinals');
                if (box) { box.textContent = (box.textContent ? box.textContent + '\n' : '') + s; box.scrollTop = box.scrollHeight; }
                Router.send('asr:final', { type: 'text', text: s, eos: true }); // eos=true for downstream flush
            },

            ssePump(onEvent) {
                let buf = '';
                return (u8) => {
                    buf += td.decode(u8, { stream: true });
                    let i;
                    while ((i = buf.indexOf('\n\n')) >= 0) {
                        const chunk = buf.slice(0, i);
                        buf = buf.slice(i + 2);
                        let ev = null, data = '';
                        for (const line of chunk.split(/\r?\n/)) {
                            if (!line) continue;
                            if (line.startsWith(':')) continue;
                            if (line.startsWith('event:')) ev = line.slice(6).trim();
                            else if (line.startsWith('data:')) data += (data ? '\n' : '') + line.slice(5).trim();
                        }
                        if (data) onEvent(ev || 'message', data);
                    }
                };
            },

            resetAggr() { this.aggr.prev = ''; this.aggr.pend = ''; this.aggr.pendStart = 0; this.aggr.lastChange = 0; },

            handlePartialForPhrases(text) {
                if ((qs('#asrPhraseOn')?.value) !== 'true') return;
                const minW = parseInt(qs('#asrPhraseMin')?.value || '3', 10) || 3;
                const stableMs = parseInt(qs('#asrPhraseStable')?.value || '350', 10) || 350;

                const prev = this.aggr.prev || '';
                if (!text.startsWith(prev)) {
                    this.aggr.prev = text;
                    this.aggr.pend = '';
                    this.aggr.pendStart = performance.now();
                    this.aggr.lastChange = this.aggr.pendStart;
                    return;
                }

                const added = text.slice(prev.length);
                const now = performance.now();
                if (added.length > 0) {
                    if (!this.aggr.pend) this.aggr.pendStart = now;
                    this.aggr.pend += added;
                    this.aggr.prev = text;
                    this.aggr.lastChange = now;
                } else {
                    const words = (this.aggr.pend.trim().match(/\S+/g) || []).length;
                    const punct = /[.!?;:,]$/.test(this.aggr.pend.trim());
                    if (this.aggr.pend && words >= minW && (punct || (now - this.aggr.lastChange) >= stableMs)) {
                        const phrase = this.aggr.pend.trim();
                        this.addPhrase(phrase);
                        this.aggr.pend = ''; this.aggr.pendStart = 0; this.aggr.lastChange = now;
                    }
                }
            },

            handleFinalFlush(text) {
                if (this.aggr.pend) { this.addPhrase(this.aggr.pend.trim()); this.aggr.pend = ''; }
                else if (text.startsWith(this.aggr.prev || '')) {
                    const extra = text.slice((this.aggr.prev || '').length).trim();
                    if (extra) this.addPhrase(extra);
                }
                this.aggr.prev = text;
            },

            // === drain pending audio and respect linger before /end ===
            async _drainAndEnd() {
                if (this.finalizing || !this.sid) return;
                this.finalizing = true;

                const viaNkn = CFG.transport === 'nkn';
                const base = CFG.asr.base;
                const relay = CFG.asr.relay;
                const api = CFG.asr.api;

                const oldSid = this.sid;
                this._autoEndSid = oldSid;
                this.setState('finalizing…', 'warn');

                const softDeadline = performance.now() + Math.max(900, this._lingerMs + 600);
                while (performance.now() < softDeadline) {
                    const now = performance.now();
                    const postQuiet = (now - this._lastPostAt) >= this._lingerMs;
                    const partialQuiet = (!this._sawPartialForUplink) || (now - this._lastPartialAt) >= this._lingerMs;
                    const hardQuiet = (now - Math.max(this._lastPostAt, this._lastPartialAt || 0)) >= this._forceQuietMaxMs;
                    if ((postQuiet && partialQuiet && this.out === 0 && this.bufF32.length === 0) || hardQuiet) break;
                    await new Promise(r => setTimeout(r, 12));
                }

                // stop mic now (prevents more partials arriving after we /end)
                try { this.node && this.node.disconnect(); } catch { }
                try { this.source && this.source.disconnect(); } catch { }
                try { this.media && this.media.getTracks().forEach(t => t.stop()); } catch { }
                try { this.ac && this.ac.close(); } catch { }
                this.node = this.source = this.media = this.ac = null;
                this.running = false;

                try {
                    await Net.postJSON(base, `/recognize/stream/${encodeURIComponent(oldSid)}/end`, {}, api, viaNkn, relay, 20000);
                } catch (e) {
                    log('[asr] finalize-live ' + (e?.message || e));
                } finally {
                    this.finalizing = false;
                }
            },

            async _finalizeLiveAndRestart() {
                if (this.finalizing) return;
                const oldSid = this.sid;
                if (!oldSid) return;
                this.finalizing = true;

                const viaNkn = CFG.transport === 'nkn';
                const base = CFG.asr.base;
                const relay = CFG.asr.relay;
                const api = CFG.asr.api;

                this._autoEndSid = oldSid;
                this.sid = null;
                clearInterval(this._vadWatch); this._vadWatch = null;

                try { this.node && this.node.disconnect(); } catch { }
                try { this.source && this.source.disconnect(); } catch { }
                try { this.media && this.media.getTracks().forEach(t => t.stop()); } catch { }
                try { this.ac && this.ac.close(); } catch { }
                this.node = this.source = this.media = this.ac = null;
                this.running = false;
                this.setState('finalizing…', 'warn');

                try { await Net.postJSON(base, `/recognize/stream/${encodeURIComponent(oldSid)}/end`, {}, api, viaNkn, relay, 20000); }
                catch (e) { log('[asr] finalize-live ' + (e?.message || e)); }
                finally { this.finalizing = false; }
            },

            async _rollSessionOnSilence() { /* optional legacy path unchanged */ },

            async start() {
                if (this.running) return;

                this._lastFinal = { text: '', at: 0 };

                const rate = parseInt(qs('#asrRate')?.value || '16000', 10) || 16000;
                const chunk = parseInt(qs('#asrChunk')?.value || '120', 10) || 120;
                const live = (qs('#asrLive')?.value) === 'true';
                const rmsTh = parseFloat(qs('#asrRms')?.value || '0.015') || 0.015;
                const holdMs = parseInt(qs('#asrHold')?.value || '250', 10) || 250;
                const emaMs = parseInt(qs('#asrEmaMs')?.value || '120', 10) || 120;
                const silence = parseInt(qs('#asrSilence')?.value || '900', 10) || 900;
                const tailBaseMs = Math.max(this._minTailMs, silence);

                this._preMs = parseInt(qs('#asrPreMs')?.value || `${this._preMs}`, 10) || this._preMs;

                const viaNkn = CFG.transport === 'nkn';
                const base = CFG.asr.base;
                const relay = CFG.asr.relay;
                const api = CFG.asr.api;

                this._autoEndSid = null;
                const suppressReset = !!this._restartFlag;
                this._restartFlag = false;

                this._sawSpeech = false;
                this._lastSpeechAt = 0;
                this.finalizing = false;

                this._uplinkOn = false;
                this._tailDeadline = 0;
                this._sawPartialForUplink = false;
                this._lastPartialAt = 0;
                this._lastPostAt = 0;
                this._preInit(rate);

                try {
                    this.ac = new (window.AudioContext || window.webkitAudioContext)();
                    this.media = await navigator.mediaDevices.getUserMedia({
                        audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false },
                        video: false
                    });
                    this.source = this.ac.createMediaStreamSource(this.media);
                    this.node = (this.ac.createScriptProcessor
                        ? this.ac.createScriptProcessor(2048, 1, 1)
                        : new ScriptProcessorNode(this.ac, { bufferSize: 2048, numberOfInputs: 1, numberOfOutputs: 1 }));

                    const from = this.ac.sampleRate | 0 || rate;
                    const bufDurMs = (this.node.bufferSize / from) * 1000;
                    const alpha = 1 - Math.exp(-bufDurMs / Math.max(emaMs, 1));

                    this.vad.ema = 0;
                    this.vad.state = 'silence';
                    this.vad.lastVoice = 0;
                    this.vad.lastSilence = performance.now();

                    let batchQuietSince = null;

                    this.node.onaudioprocess = (e) => {
                        const ch = e.inputBuffer.getChannelData(0);
                        let sum = 0; for (let i = 0; i < ch.length; i++) sum += ch[i] * ch[i];
                        const rmsCur = Math.sqrt(sum / ch.length);

                        this.vad.ema = (1 - alpha) * this.vad.ema + alpha * rmsCur;
                        const ema = this.vad.ema;
                        const onTh = rmsTh;
                        const offTh = rmsTh * 0.7;
                        const now = performance.now();
                        const tailMs = tailBaseMs;

                        const f32 = (from === rate) ? ch.slice(0) : this.resample(ch, from, rate);
                        this._prePush(f32); // pre-roll always updated

                        if (this.vad.state === 'silence') {
                            if (ema >= onTh) {
                                // ENTER VOICE
                                this.vad.state = 'voice';
                                this.vad.lastVoice = now;
                                this._sawSpeech = true;
                                this._lastSpeechAt = now;
                                // open uplink: send pre-roll + this block
                                this._openUplink(now, tailMs, f32);
                            } else if (this._uplinkOn) {
                                // We're silent while uplink is open (tail waiting).
                                // DO NOT push any audio during silence (cut to silence).
                                if (now > this._tailDeadline) {
                                    const postQuiet = (now - this._lastPostAt) >= this._lingerMs;
                                    const partialQuiet = (!this._sawPartialForUplink) || ((now - this._lastPartialAt) >= this._lingerMs);
                                    const hardQuiet = (now - Math.max(this._lastPostAt, this._lastPartialAt || 0)) >= this._forceQuietMaxMs;
                                    if ((postQuiet && partialQuiet) || hardQuiet) this._closeUplinkAndMaybeFinalize();
                                }
                            }
                        } else {
                            // state === 'voice'
                            if (ema >= offTh) {
                                // still voice
                                this.vad.lastVoice = now;
                                this._lastSpeechAt = now;
                                if (this._uplinkOn) { this._extendTail(now, tailMs); this.pushF32(f32); }
                            } else {
                                // below off threshold → hangover
                                const sinceVoice = now - (this.vad.lastVoice || now);
                                if (sinceVoice >= holdMs) {
                                    // EXIT VOICE → SILENCE
                                    this.vad.state = 'silence';
                                    this.vad.lastSilence = now;
                                    if (this.aggr.pend) { this.addPhrase(this.aggr.pend.trim()); this.aggr.pend = ''; }
                                    // IMPORTANT: do NOT push audio here; silence begins now
                                } else {
                                    // brief dip; still voice, but don't refresh lastVoice
                                    if (this._uplinkOn) this.pushF32(f32);
                                }
                            }
                        }

                        // UI meters
                        this.vu(ema);
                        const v = qs('#asrVad'); if (v) v.textContent = this.vad.state;
                        const rv = qs('#asrRmsVal'); if (rv) rv.textContent = ema.toFixed(3);

                        // BATCH: auto finalize on long silence
                        if (!live) {
                            if (ema < offTh) {
                                batchQuietSince = batchQuietSince ?? now;
                                if (now - batchQuietSince >= silence) { batchQuietSince = null; this.finalizeOnce(rate).catch(() => { }); }
                            } else { batchQuietSince = null; }
                        }
                    };

                    this.source.connect(this.node);
                    this.node.connect(this.ac.destination);

                    clearInterval(this._vadWatch);
                    if (live) {
                        // watchdog: if silent tail has elapsed & no uploads/partials recently → finalize
                        this._vadWatch = setInterval(() => {
                            if (!this.sid || this.finalizing || !this._uplinkOn) return;
                            const now = performance.now();
                            if (this.vad.state !== 'silence') return;
                            if (now <= this._tailDeadline) return;
                            const postQuiet = (now - this._lastPostAt) >= this._lingerMs;
                            const partialQuiet = (!this._sawPartialForUplink) || ((now - this._lastPartialAt) >= this._lingerMs);
                            const hardQuiet = (now - Math.max(this._lastPostAt, this._lastPartialAt || 0)) >= this._forceQuietMaxMs;
                            if ((postQuiet && partialQuiet) || hardQuiet) this._closeUplinkAndMaybeFinalize();
                        }, Math.max(50, Math.min(200, chunk)));
                    }
                } catch (e) {
                    this.setState('mic error', 'err');
                    log('[asr] ' + e.message);
                    return;
                }

                // UI reset (keep Finals on auto-restarts)
                if (!suppressReset) {
                    const p = qs('#asrPartial'); if (p) p.textContent = '';
                    const ph = qs('#asrPhrases'); if (ph) ph.textContent = '';
                    const f = qs('#asrFinals'); if (f) f.textContent = '';
                }
                this.resetAggr();

                this.running = true;
                this.out = 0; const ao = qs('#asrOut'); if (ao) ao.textContent = '0';
                this.setState(live ? 'streaming' : 'batch', 'warn');

                if (live) {
                    try {
                        const prompt = (qs('#asrPrompt')?.value || CFG.asr.prompt || '').trim();
                        const model = (qs('#asrModel')?.value || CFG.asr.model || '').trim();
                        const body = Object.assign({}, prompt ? { prompt } : {}, model ? { model } : {}, {
                            temperature: 0.0, condition_on_previous_text: false, no_speech_threshold: 0.6, logprob_threshold: -1.0
                        });
                        const data = await Net.postJSON(base, '/recognize/stream/start', body, api, viaNkn, relay, 45000);
                        this.sid = (data && (data.sid || data.id || data.session)) || null;
                        if (!this.sid) throw new Error('no sid');
                    } catch (e) {
                        this.setState('start fail', 'err');
                        log('[asr] start ' + e.message);
                        return;
                    }

                    const thisSid = this.sid;

                    this.openEvents(thisSid, viaNkn, base, relay, api)
                        .then(() => {
                            if (this._autoEndSid === thisSid) {
                                this._restartFlag = true;
                                this._autoEndSid = null;
                                setTimeout(() => {
                                    if ((qs('#asrLive')?.value) === 'true') this.start();
                                }, 120);
                            }
                        })
                        .catch(() => { });

                    this.flushLoop(rate, chunk, viaNkn, base, relay, api).catch(() => { });
                } else {
                    this.setState('ready (batch)', 'ok');
                }
            },

            async stop() {
                if (!this.running) return; this.setState('stopping', 'warn');
                this.running = false;
                this._autoEndSid = null;
                try { this.node && this.node.disconnect() } catch { }
                try { this.source && this.source.disconnect() } catch { }
                try { this.media && this.media.getTracks().forEach(t => t.stop()) } catch { }
                try { this.ac && this.ac.close() } catch { }
                this.node = this.source = this.media = this.ac = null;
                clearInterval(this._vadWatch); this._vadWatch = null;
                this.bufF32 = new Float32Array(0);
                this._uplinkOn = false;
                this._preInit(parseInt(qs('#asrRate')?.value || '16000', 10) || 16000);

                const ab = qs('#asrBuf'); if (ab) ab.textContent = '0';
                const av = qs('#asrVad'); if (av) av.textContent = 'idle';
                if (this.sid) { try { await Net.postJSON(CFG.asr.base, `/recognize/stream/${encodeURIComponent(this.sid)}/end`, {}, CFG.asr.api, CFG.transport === 'nkn', CFG.asr.relay, 20000) } catch { } }
                this.sid = null; this.setState('idle', 'ok');
            },

            async finalizeOnce(rate) {
                if (!this.bufF32.length) return;
                const pcm = this.bufF32; const b = new ArrayBuffer(44 + pcm.length * 2); const v = new DataView(b); let o = 0;
                const W4 = s => { for (let i = 0; i < 4; i++) v.setUint8(o++, s.charCodeAt(i)) }; const U32 = n => { v.setUint32(o, n, true); o += 4 }; const U16 = n => { v.setUint16(o, n, true); o += 2 };
                const sr = rate, bps = 16, ch = 1, ba = ch * bps / 8, br = sr * ba;
                W4('RIFF'); U32(36 + pcm.length * 2); W4('WAVE'); W4('fmt '); U32(16); U16(1); U16(1); U32(sr); U32(br); U16(ba); U16(bps); W4('data'); U32(pcm.length * 2);
                for (let i = 0; i < pcm.length; i++) v.setInt16(44 + i * 2, Math.max(-1, Math.min(1, pcm[i])) < 0 ? pcm[i] * 0x8000 : pcm[i] * 0x7FFF, true);
                const b64 = btoa(String.fromCharCode(...new Uint8Array(b))); this.bufF32 = new Float32Array(0);
                try {
                    const prompt = (qs('#asrPrompt')?.value || CFG.asr.prompt || '').trim();
                    const body = Object.assign({ body_b64: b64, format: 'wav', sample_rate: rate }, prompt ? { prompt } : {});
                    const data = await Net.postJSON(CFG.asr.base, '/recognize', body, CFG.asr.api, CFG.transport === 'nkn', CFG.asr.relay, 120000);
                    const txt = (data && (data.text || data.transcript)) || '';
                    if (txt) this.appendFinal(txt);
                } catch (e) { log('[asr] finalize ' + e.message) }
            },

            async openEvents(sid, viaNkn, base, relay, api) {
                const pump = this.ssePump((ev, data) => {
                    try {
                        const obj = JSON.parse(data);
                        const t = (obj.type || obj.event || '').toLowerCase();

                        if (t === 'asr.partial' || t === 'partial') {
                            const text = obj.text || (obj.result && obj.result.text) || '';
                            this.printPartial(text);
                            this.handlePartialForPhrases(text);
                            if (text) {
                                this._sawSpeech = true;
                                this._lastSpeechAt = performance.now();
                                this._sawPartialForUplink = true;
                                this._lastPartialAt = performance.now();
                            }
                        } else if (t === 'asr.detected' || t === 'detected') {
                            const s = obj.text || (obj.result && obj.result.text) || '';
                            if (s) {
                                const meta = (obj.result && obj.result) || obj;
                                if (!ASR.shouldDropAsHallucination(s, meta)) this.addPhrase(s);
                                else log('[asr] suppressed hallucinated sign-off (detected): "' + s + '"');
                            }
                        } else if (t === 'asr.final' || t === 'final') {
                            const s = (obj.result && obj.result.text) || obj.text || '';
                            if (s) {
                                const meta = (obj.result && obj.result) || obj;
                                if (ASR.shouldDropAsHallucination(s, meta)) {
                                    log('[asr] dropped probable hallucinated sign-off: "' + s + '"');
                                } else {
                                    // ORDER: emit final → flush phrases → clear UI (deferred)
                                    this.appendFinal(s);              // Router 'asr:final' (eos:true)
                                    this.handleFinalFlush(s);         // push any leftover phrase deltas
                                    setTimeout(() => this._afterFinalCleanupForSid(sid), 0); // clear partials & phrases after final is out
                                }
                            }
                        } else if (t === 'error') {
                            log('[asr] ' + (obj.message || obj.error || 'error'));
                        }

                        const e = qs('#asrEvt'); if (e) e.textContent = t;
                    } catch { }
                });

                const ev = qs('#asrEvt'); if (ev) ev.textContent = 'connecting';

                if (viaNkn) {
                    await Net.nknStream(
                        { url: base.replace(/\/+$/, '') + `/recognize/stream/${encodeURIComponent(sid)}/events`, method: 'GET', headers: Net.auth({ 'X-Relay-Stream': 'chunks' }, api), timeout_ms: 10 * 60 * 1000 },
                        relay,
                        {
                            onBegin: () => { const e = qs('#asrEvt'); if (e) e.textContent = 'open'; this.setState('streaming', 'ok'); },
                            onChunk: (bytes) => pump(bytes),
                            onEnd: () => {
                                const e = qs('#asrEvt'); if (e) e.textContent = 'ended';
                                clearInterval(ASR._vadWatch); ASR._vadWatch = null;
                            }
                        }
                    );
                } else {
                    const r = await fetch(base.replace(/\/+$/, '') + `/recognize/stream/${encodeURIComponent(sid)}/events`, { headers: Net.auth({}, api) });
                    if (!r.ok || !r.body) { const e = qs('#asrEvt'); if (e) e.textContent = 'error'; return }
                    const e = qs('#asrEvt'); if (e) e.textContent = 'open';
                    const reader = r.body.getReader();
                    while (true) { const { value, done } = await reader.read(); if (done) break; if (value && value.byteLength) pump(value) }
                    const ed = qs('#asrEvt'); if (ed) ed.textContent = 'ended';
                    clearInterval(ASR._vadWatch); ASR._vadWatch = null;
                }
            },

            async flushLoop(rate, chunk, viaNkn, base, relay, api) {
                const need = () => Math.round(rate * (chunk / 1000));
                while (this.running && this.sid) {
                    if (this.bufF32.length >= need() && this.out < 4) {
                        const f32 = this.drainF32(need());
                        const bytes = this.i16(f32);
                        const url = base.replace(/\/+$/, '') + `/recognize/stream/${encodeURIComponent(this.sid)}/audio?format=pcm16&sr=${rate}`;
                        this.out++; const ao = qs('#asrOut'); if (ao) ao.textContent = String(this.out);
                        try {
                            this._lastPostAt = performance.now();
                            if (viaNkn) {
                                await Net.nknSend({ url, method: 'POST', headers: Net.auth({ 'Content-Type': 'application/octet-stream' }, api), body_b64: btoa(String.fromCharCode(...bytes)), timeout_ms: 20000 }, relay, 20000);
                            } else {
                                const r = await fetch(url, { method: 'POST', headers: Net.auth({ 'Content-Type': 'application/octet-stream' }, api), body: bytes });
                                if (!r.ok) throw new Error(r.status + ' ' + r.statusText);
                            }
                            this._lastPostAt = performance.now();
                        } catch (e) { log('[asr] audio send ' + (e && e.message || e)) }
                        finally { this.out--; const ao2 = qs('#asrOut'); if (ao2) ao2.textContent = String(this.out) }
                    }
                    await new Promise(r => setTimeout(r, Math.max(10, chunk / 2)));
                }
            },

            shouldDropAsHallucination(text, meta) {
                const SIGNOFF_RE = /\b(thanks(?:,)?\s+for\s+(?:watching|listening)|(?:don['’]t\s+forget\s+to\s+)?(?:like|subscribe)|like\s+and\s+subscribe|link\s+in\s+(?:the\s+)?description)\b/i;
                if (!SIGNOFF_RE.test(text)) return false;
                const words = (text.match(/\S+/g) || []).length;
                const shortGeneric = words <= 7;
                const weSawNoSpeech = !this._sawSpeech;
                const inSilenceNow = this.vad?.state === 'silence';
                const noSpeechProb = (meta && typeof meta.no_speech_prob === 'number') ? meta.no_speech_prob : null;
                const lowConf = (noSpeechProb !== null && noSpeechProb > 0.6) ||
                    (meta && typeof meta.avg_logprob === 'number' && meta.avg_logprob < -1.0) ||
                    (meta && typeof meta.compression_ratio === 'number' && meta.compression_ratio > 2.4);
                return shortGeneric && (weSawNoSpeech || inSilenceNow || lowConf);
            }
        };







        /* ======== LLM ======== */
        const EOT_TOKENS = ["<|eot_id|>", "</s>"];
        function stripEOT(s) { let out = s || ''; for (const t of EOT_TOKENS) { if (t) out = out.split(t).join('') } return out }
        function makeSeqAligner(deliver) {
            let expected = null;
            const stash = new Map();
            const seen = new Set();

            function flush() {
                while (expected != null && stash.has(expected)) {
                    const v = stash.get(expected);
                    stash.delete(expected);
                    deliver(v);
                    expected++;
                }
            }

            return {
                push(line, seqRaw) {
                    const seq = (seqRaw | 0);
                    if (seen.has(seq)) return;   // drop dupes
                    seen.add(seq);

                    if (expected == null) expected = seq;
                    if (seq === expected) {
                        deliver(line);
                        expected++;
                        flush();
                    } else if (seq > expected) {
                        stash.set(seq, line);
                    }
                    // silently ignore late (< expected)
                },
                end(lastSeq) {
                    // best effort: drain up to lastSeq if provided
                    if (typeof lastSeq === 'number') {
                        flush();
                    } else {
                        flush();
                    }
                }
            };
        }

        // JSON-aware NDJSON pump: emits complete JSON objects even without trailing '\n'
        function makeNdjsonPump(onLine) {
            const dec = new TextDecoder('utf-8');
            let buf = '';
            let inStr = false, esc = false, depth = 0;

            function feed(text) {
                buf += text;
                let start = 0;

                for (let i = 0; i < buf.length; i++) {
                    const ch = buf[i];

                    if (inStr) {
                        if (esc) { esc = false; continue; }
                        if (ch === '\\') { esc = true; continue; }
                        if (ch === '"') { inStr = false; continue; }
                        continue;
                    }

                    // not in string
                    if (ch === '"') { inStr = true; continue; }

                    if (ch === '{') { depth++; continue; }
                    if (ch === '}') {
                        depth--;
                        if (depth === 0) {
                            // complete JSON object [start..i]
                            let ln = buf.slice(start, i + 1).trim();
                            if (ln.startsWith('data:')) ln = ln.slice(5).trim();
                            if (ln && ln !== '[DONE]') onLine(ln);
                            start = i + 1;
                        }
                        continue;
                    }

                    // swallow bare [DONE] lines that may appear between JSONs
                    if (ch === '\n') {
                        const line = buf.slice(start, i).trim();
                        if (line === '[DONE]' || line === 'data: [DONE]') start = i + 1;
                    }
                }

                // keep only unclosed tail
                buf = buf.slice(start);
            }

            return {
                push(chunk) {
                    const s = (chunk instanceof Uint8Array || chunk instanceof ArrayBuffer)
                        ? dec.decode(chunk, { stream: true })
                        : String(chunk);
                    feed(s);
                },
                flush() {
                    // Emit a last object if it's complete but lacked '\n'
                    const tail = buf.trim();
                    if (tail && depth === 0) {
                        let ln = tail;
                        if (ln.startsWith('data:')) ln = ln.slice(5).trim();
                        if (ln && ln !== '[DONE]') onLine(ln);
                    }
                    buf = '';
                    inStr = false; esc = false; depth = 0;
                }
            };
        }


        // Sentence mux for TTS (settled EOS streaming)
        const SentenceMux = {
            // config knobs
            stableMs: 250,               // time of no changes before we accept the last sentence
            // state
            carry: '',
            pending: '',
            emitTimer: null,

            // Exhaustive-ish end-of-sentence detector with closers, bullets, emoji
            SENT_RE: /([\s\S]*?)(?:([.!?;:](?:["')\]]+)*)\s+|(\n{2,}|\r?\n[-*•]\s+)|((?:\p{Extended_Pictographic}|\p{Emoji_Presentation})+\s+))/u,

            // push ordered delta; only emit "settled" sentences
            pushDelta(delta, emitFn) {
                if (!delta) return;

                // add new text to the buffer
                this.carry += delta;

                // extract as many complete sentences as possible from carry
                const produced = [];
                let guard = 0;
                while (guard++ < 1000) {
                    const m = this.SENT_RE.exec(this.carry);
                    if (!m) break;

                    const head = (m[1] || '').trim();
                    const punc = (m[2] || '').trim();
                    const bullet = (m[3] || '').trim();
                    const emoji = (m[4] || '').trim();
                    const boundary = punc || bullet || emoji;
                    if (!boundary) break;

                    const sentence = (head + (punc ? punc : '')).trim();
                    const cut = m.index + (m[0] || '').length;
                    this.carry = this.carry.slice(cut);

                    if (sentence) produced.push(sentence);
                }

                // If we produced any *new* complete sentence(s), we can now COMMIT whatever was pending.
                if (produced.length) {
                    if (this.pending) emitFn(this.pending); // settled by new boundary evidence
                    // keep the *last* as the new pending; emit any earlier immediately
                    for (let i = 0; i < produced.length - 1; i++) emitFn(produced[i]);
                    this.pending = produced[produced.length - 1];
                    this._armTimer(emitFn); // re-arm stability timer for the new pending
                    return;
                }

                // No new boundary yet; if *any* non-space showed up after the pending boundary,
                // that's sufficient look-ahead to settle it (low-latency).
                if (this.pending && /\S/.test(this.carry)) {
                    emitFn(this.pending);
                    this.pending = '';
                    this._clearTimer();
                    return;
                }

                // Otherwise, keep waiting but ensure we have a fallback timer for silence gaps.
                if (this.pending) this._armTimer(emitFn);
            },

            flush(emitFn) {
                // At stream end, everything left is considered final
                this._clearTimer();
                if (this.pending) { emitFn(this.pending); this.pending = ''; }
                const tail = this.carry.trim();
                if (tail) emitFn(tail);
                this.carry = '';
            },

            _armTimer(emitFn) {
                this._clearTimer();
                this.emitTimer = setTimeout(() => {
                    if (this.pending) {
                        emitFn(this.pending);
                        this.pending = '';
                    }
                }, this.stableMs);
            },
            _clearTimer() {
                if (this.emitTimer) { clearTimeout(this.emitTimer); this.emitTimer = null; }
            }
        };


        const LLM = {
            // ---- conversation state ----
            _memLoaded: false,
            _history: [],            // [{role:'user'|'assistant'|'system', content:string}, ...]
            _lastUserText: '',       // captured per-turn so we can save to memory after streaming

            // Pull toggles from DOM or CFG with sane fallbacks
            _useSystem() { return (qs('#llmUseSystem')?.value === 'true') || !!CFG.llm?.useSystem; },
            _systemText() { return (qs('#llmSystem')?.value || CFG.llm?.system || '').trim(); },
            _memoryOn() { return (qs('#llmMemory')?.value === 'true') || !!CFG.llm?.memoryOn; },
            _persistOn() { return (qs('#llmPersistMemory')?.value === 'true') || !!CFG.llm?.persistMemory; },
            _maxTurns() {
                // number of user/assistant pairs to keep (not counting system)
                const n = parseInt(qs('#llmMaxTurns')?.value || (CFG.llm?.maxTurns ?? 16), 10);
                return Number.isFinite(n) && n > 0 ? n : 16;
            },

            _ensureMemoryLoaded() {
                if (this._memLoaded) return;
                // load any persisted memory
                if (CFG.llm && Array.isArray(CFG.llm.memory)) {
                    // make a shallow copy to avoid accidental shared mutation
                    this._history = CFG.llm.memory.slice();
                } else {
                    this._history = [];
                }
                this._memLoaded = true;
            },

            clearMemory() {
                this._history = [];
                if (CFG.llm) { CFG.llm.memory = []; saveCFG(); }
                Router.send('llm:memory', { type: 'cleared' });
            },

            _trimHistoryInPlace() {
                // Keep only last N user/assistant turns (plus leading system if present)
                const maxPairs = this._maxTurns();

                // Identify an initial system message (only first is kept)
                let sys = null;
                const rest = [];
                for (const m of this._history) {
                    if (!sys && m.role === 'system') { sys = m; continue; }
                    rest.push(m);
                }

                // Walk from end and keep last maxPairs pairs (user+assistant). If odd count, keep the last message anyway.
                const pruned = [];
                let pairs = 0;
                for (let i = rest.length - 1; i >= 0; i--) {
                    pruned.push(rest[i]);
                    if (rest[i].role === 'user') {
                        // Count a pair when we see a user message, assuming assistant follows it earlier in the array
                        pairs++;
                        if (pairs >= maxPairs) { break; }
                    }
                }
                pruned.reverse();
                this._history = (sys ? [sys] : []).concat(pruned);
            },

            _rememberTurn(userText, assistantText) {
                if (!this._memoryOn()) return; // memory off → do not store
                this._ensureMemoryLoaded();

                // If a system message is configured AND memory has no system yet, pin it at the front (once).
                if (this._useSystem()) {
                    const sysText = this._systemText();
                    if (sysText && !this._history.some(m => m.role === 'system')) {
                        this._history.unshift({ role: 'system', content: sysText });
                    }
                }

                // Append the turn
                if (userText?.trim()) this._history.push({ role: 'user', content: userText.trim() });
                if (assistantText?.trim()) this._history.push({ role: 'assistant', content: assistantText.trim() });

                // Trim & optionally persist
                this._trimHistoryInPlace();
                if (this._persistOn()) {
                    if (!CFG.llm) CFG.llm = {};
                    CFG.llm.memory = this._history.slice();
                    saveCFG();
                }

                Router.send('llm:memory', { type: 'updated', size: this._history.length });
            },

            _buildMessages(latestUserText) {
                const msgs = [];
                const useSys = this._useSystem();
                const memOn = this._memoryOn();
                this._ensureMemoryLoaded();

                // System message (explicit UI or CFG)
                const sysText = this._systemText();
                if (useSys && sysText) {
                    // If history already contains a system (persisted), ensure the first message is that one,
                    // and update its content if it differs (so the toggle updates future calls).
                    const hasSysIdx = this._history.findIndex(m => m.role === 'system');
                    if (hasSysIdx >= 0) {
                        if (this._history[hasSysIdx].content !== sysText) {
                            this._history[hasSysIdx] = { role: 'system', content: sysText };
                            if (this._persistOn()) { CFG.llm.memory = this._history.slice(); saveCFG(); }
                        }
                    } else {
                        // don't modify stored history at build time; only send system transiently unless we later save
                        msgs.push({ role: 'system', content: sysText });
                    }
                }

                // History (if enabled)
                if (memOn) {
                    // If history contains a system and we didn't add one above transiently,
                    // include from stored history.
                    let i = 0;
                    if (this._history.length && this._history[0].role === 'system') {
                        if (!msgs.length) msgs.push(this._history[0]);
                        i = 1;
                    }
                    for (; i < this._history.length; i++) msgs.push(this._history[i]);
                }

                // Finally add the new user message
                if (latestUserText?.trim()) {
                    msgs.push({ role: 'user', content: latestUserText.trim() });
                }

                return msgs;
            },

            async refreshModels() {
                try {
                    const data = await Net.getJSON(CFG.llm.base, '/api/tags', CFG.llm.api, CFG.transport === 'nkn', CFG.llm.relay);
                    const arr = (data?.models || []).map(m => m.name || m.model).filter(Boolean);
                    const sel = qs('#llmModel'); if (!sel) return; sel.innerHTML = ''; arr.forEach(n => { const o = document.createElement('option'); o.value = n; o.textContent = n; sel.appendChild(o) });
                    if (arr.length) { CFG.llm.model = (CFG.llm.model && arr.includes(CFG.llm.model)) ? CFG.llm.model : arr[0]; sel.value = CFG.llm.model; saveCFG(); log('[llm] models ok') }
                } catch (e) { log('[llm] tags ' + e.message) }
            },

            setState(txt, cls = 'ok') { const s = qs('#llmState'); const d = qs('#llmDot'); if (s) s.textContent = txt; if (d) d.className = 'dot ' + (cls === 'ok' ? 'ok' : cls === 'err' ? 'err' : 'warn') },

            async onPrompt(payload) {
                const text = (payload && (payload.text || payload.prompt || payload)) || '';
                const model = qs('#llmModel')?.value || CFG.llm.model || '';
                if (!model) { this.setState('no model', 'err'); return }
                const stream = (qs('#llmStream')?.value) === 'true';
                const viaNkn = CFG.transport === 'nkn', base = CFG.llm.base, api = CFG.llm.api, relay = CFG.llm.relay;

                // Build message list with system + history + latest user
                const messages = this._buildMessages(text);
                this._lastUserText = text; // remember for saving after we get assistant final

                const out = qs('#llmTokens'); if (out) out.textContent = '';
                let full = ''; let tok = 0; let bytes = 0; const t0 = performance.now();
                const upd = () => { const t = qs('#llmTok'); if (t) t.textContent = String(tok); const b = qs('#llmBytes'); if (b) b.textContent = String(bytes); const m = qs('#llmMs'); if (m) m.textContent = String(Math.round(performance.now() - t0)) + 'ms' };

                const emitSentence = (s) => { Router.send('tts:text', { text: s, eos: true }); };

                const handleLine = (ln) => {
                    try {
                        const obj = JSON.parse(ln);

                        // prefer streaming delta
                        let delta =
                            (obj.message && typeof obj.message.content === 'string' && obj.message.content) ||
                            (typeof obj.response === 'string' && obj.response) ||
                            (typeof obj.delta === 'string' && obj.delta) || '';

                        // terminal-only content fallbacks
                        if (!delta && (obj.done || obj.complete) && obj.final && typeof obj.final === 'string') {
                            delta = obj.final;
                        }
                        if (!delta && (obj.done || obj.complete) && obj.message && typeof obj.message.content === 'string') {
                            delta = obj.message.content;
                        }

                        if (delta) {
                            const clean = stripEOT(delta);
                            full += clean;
                            if (out) { out.textContent += clean; out.scrollTop = out.scrollHeight; }
                            tok += (clean.match(/\S+/g) || []).length; bytes += clean.length; upd();
                            SentenceMux.pushDelta(clean, emitSentence);
                            Router.send('llm:delta', { type: 'text', text: clean });
                        }
                    } catch {
                        // ignore mid-JSON fragments — the NDJSON pump will deliver complete objects
                    }
                };

                try {
                    if (stream) {
                        this.setState('streaming', 'warn'); upd();
                        const pump = makeNdjsonPump(handleLine);

                        if (viaNkn) {
                            const order = makeSeqAligner(line => pump.push(line + '\n'));
                            await Net.nknStream({
                                url: base.replace(/\/+$/, '') + '/api/chat',
                                method: 'POST',
                                headers: Net.auth({ 'X-Relay-Stream': 'chunks', 'Accept': 'application/x-ndjson' }, api),
                                json: { model, messages, stream: true },
                                timeout_ms: 180000
                            }, relay, {
                                onBegin: () => { this.setState('stream open', 'warn') },
                                onLine: (line, seq) => { order.push(line, seq) },
                                onChunk: (u8) => pump.push(u8),
                                onEnd: (m) => {
                                    order.end(m && (m.last_seq | 0));
                                    pump.flush();
                                    SentenceMux.flush(emitSentence);
                                    this.setState('done', 'ok');

                                    // Save the completed turn if memory is on
                                    const finalText = stripEOT(full || '');
                                    this._rememberTurn(this._lastUserText, finalText);
                                }
                            }, 180000);
                        } else {
                            const r = await fetch(base.replace(/\/+$/, '') + '/api/chat', {
                                method: 'POST',
                                headers: Net.auth({ 'Accept': 'application/x-ndjson', 'Content-Type': 'application/json' }, api),
                                body: JSON.stringify({ model, messages, stream: true })
                            });
                            if (!r.ok || !r.body) throw new Error(`${r.status} ${r.statusText}`);
                            const reader = r.body.getReader();
                            while (true) { const { value, done } = await reader.read(); if (done) break; if (value && value.byteLength) pump.push(value) }
                            pump.flush();
                            SentenceMux.flush(emitSentence);
                            this.setState('done', 'ok');

                            const finalText = stripEOT(full || '');
                            this._rememberTurn(this._lastUserText, finalText);
                        }
                    } else {
                        const data = await Net.postJSON(base, '/api/chat', { model, messages, stream: false }, api, viaNkn, relay, 120000);
                        full = stripEOT((data?.message?.content) || (data?.response) || '');
                        const finalText = full || '';
                        tok = (finalText.match(/\S+/g) || []).length; bytes = finalText.length; upd();
                        const outEl = qs('#llmTokens'); if (outEl) outEl.textContent = finalText;
                        this.setState('done', 'ok');

                        SentenceMux.pushDelta(finalText + '\n', emitSentence);
                        SentenceMux.flush(emitSentence);

                        // Save turn if memory is on
                        this._rememberTurn(this._lastUserText, finalText);
                    }

                    Router.send('llm:final', { type: 'text', text: full });
                } catch (e) {
                    this.setState('error', 'err');
                    log('[llm] ' + e.message);
                }
            }
        };

        /* ======== TTS ======== */
        const TTS = {
            models: [], lastOk: 0, timer: null, slow: 180000, fast: 30000,

            async _probeVoices() {
                const viaNkn = CFG.transport === 'nkn', base = CFG.tts.base, relay = CFG.tts.relay, api = CFG.tts.api;
                const paths = ['/voices', '/models', '/api/voices', '/api/models'];
                const normalize = (data) => {
                    const pick = (arr) => arr.map(v => {
                        if (typeof v === 'string') return v;
                        if (v && typeof v === 'object') { return v.name || v.model || v.id || v.voice || '' }
                        return '';
                    }).filter(Boolean);
                    if (Array.isArray(data)) return pick(data);
                    if (!data || typeof data !== 'object') return [];
                    if (Array.isArray(data.voices)) return pick(data.voices);
                    if (Array.isArray(data.models)) return pick(data.models);
                    if (Array.isArray(data.items)) return pick(data.items);
                    if (data.data && Array.isArray(data.data)) return pick(data.data);
                    return [];
                };
                for (const p of paths) {
                    try {
                        const resp = await Net.getJSON(base, p, api, viaNkn, relay);
                        const arr = normalize(resp);
                        if (arr.length) return arr;
                    } catch { }
                }
                return [];
            },

            _timer: null,
            _slow: 180000,
            _fast: 30000,

            async refreshModels() {
                try {
                    const arr = await this._probeVoices();
                    this.models = arr;

                    const dl = qs('#ttsModelList');
                    if (dl) {
                        const prev = (qs('#ttsModel')?.value || '').trim();
                        dl.innerHTML = '';
                        arr.forEach(n => { const o = document.createElement('option'); o.value = n; dl.appendChild(o) });

                        const want = (CFG.tts.model && arr.includes(CFG.tts.model)) ? CFG.tts.model
                            : (prev && arr.includes(prev)) ? prev
                                : (arr[0] || '');
                        CFG.tts.model = want;
                        const inp = qs('#ttsModel'); if (inp) inp.value = want;
                        saveCFG();
                    }
                } catch (e) {
                    log('[tts] voices ' + (e?.message || e));
                } finally {
                    clearTimeout(this._timer);
                    const ok = (qs('#ttsModelList')?.options?.length || 0) > 0;
                    this._timer = setTimeout(() => this.refreshModels(), ok ? this._slow : this._fast);
                }
            },
            setState(txt, cls = 'ok') { const s = qs('#ttsState'); const d = qs('#ttsDot'); if (s) s.textContent = txt; if (d) d.className = 'dot ' + (cls === 'ok' ? 'ok' : cls === 'err' ? 'err' : 'warn') },

            _ac: null, _node: null, _q: [], _queued: 0, _underruns: 0, _sr: 22050,

            // Text FIFO to enforce strict sentence ordering
            _textQ: [],
            _busy: false,

            ensureAC() {
                if (this._ac) return this._ac;
                this._ac = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 22050 });
                this._sr = this._ac.sampleRate || 22050; const ac = qs('#ttsAC'); if (ac) ac.textContent = this._sr + 'Hz';
                const n = this._node = this._ac.createScriptProcessor(4096, 1, 1);
                n.onaudioprocess = (e) => {
                    const out = e.outputBuffer.getChannelData(0);
                    if (!this._q.length) { out.fill(0); this._underruns++; const u = qs('#ttsUrun'); if (u) u.textContent = String(this._underruns); return }
                    let need = out.length, off = 0;
                    while (need > 0) {
                        if (!this._q.length) { out.fill(0, off); this._underruns++; const u = qs('#ttsUrun'); if (u) u.textContent = String(this._underruns); break }
                        const head = this._q[0]; const take = Math.min(need, head.length);
                        out.set(head.subarray(0, take), off);
                        if (take === head.length) this._q.shift(); else this._q[0] = head.subarray(take);
                        this._queued -= take; off += take; need -= take;
                    }
                    const tb = qs('#ttsBuf'); if (tb) tb.textContent = String(this._queued);
                    const tbm = qs('#ttsBufMs'); if (tbm) tbm.textContent = String(Math.round(this._queued / this._sr * 1000));
                };
                n.connect(this._ac.destination);
                return this._ac;
            },
            int16ToF32(int16) { const f = new Float32Array(int16.length); for (let i = 0; i < int16.length; i++) f[i] = Math.max(-1, Math.min(1, int16[i] / 32768)); return f },
            enqueueF32(f) { this._q.push(f); this._queued += f.length; const tb = qs('#ttsBuf'); if (tb) tb.textContent = String(this._queued); const tbm = qs('#ttsBufMs'); if (tbm) tbm.textContent = String(Math.round(this._queued / this._sr * 1000)); },
            resampleLinear(input, fromRate, toRate) {
                if (fromRate === toRate) return input;
                const ratio = toRate / fromRate;
                const L = Math.round(input.length * ratio);
                const out = new Float32Array(L);
                for (let i = 0; i < L; i++) {
                    const pos = i / ratio;
                    const i0 = Math.floor(pos);
                    const i1 = Math.min(i0 + 1, input.length - 1);
                    const t = pos - i0;
                    out[i] = input[i0] * (1 - t) + input[i1] * t;
                }
                return out;
            },

            // simple sentence buffer / dedupe
            _ingressCarry: '', _lastSentences: [],
            _splitComplete(buf) {
                const closes = `"'’”)]`; const isClose = c => closes.includes(c); const isWS = c => /\s/.test(c || '');
                const out = []; let start = 0, i = 0;
                while (i < buf.length) {
                    const ch = buf[i];
                    if ('.!?;:…'.includes(ch)) {
                        let j = i + 1; while (j < buf.length && isClose(buf[j])) j++;
                        if (j >= buf.length || isWS(buf[j])) {
                            const sent = buf.slice(start, j).trim();
                            if (sent) out.push(sent);
                            while (j < buf.length && isWS(buf[j])) j++;
                            start = j; i = j; continue;
                        }
                    }
                    i++;
                }
                return { complete: out, rest: buf.slice(start) };
            },
            _seenRecently(s) {
                const key = s.slice(0, 120);
                const hit = this._lastSentences.includes(key);
                if (!hit) { this._lastSentences.push(key); if (this._lastSentences.length > 8) this._lastSentences.shift(); }
                return hit;
            },

            // ─────────────────────────────────────────────────────────────
            // NEW: punctuation/symbol scrubber (runs just before synth)
            // ─────────────────────────────────────────────────────────────
            // replace the whole function with this:
            _sanitizeForTTS(text) {
                if (!text) return '';
                let s = text;
                try { s = s.normalize('NFKC'); } catch { }

                // 1) kill URLs and markdown artifacts
                s = s.replace(/\bhttps?:\/\/\S+/gi, ' ');
                s = s.replace(/[*_~`]+/g, ' ');

                // 2) readable ampersands
                s = s.replace(/&/g, ' and ');

                // 3) STRIP apostrophes entirely (ASCII + curly) so "don't" → "dont"
                //    do this BEFORE generic punctuation so we don't create "don t"
                s = s.replace(/['’]/g, '');

                // 4) remove common quotes/brackets explicitly (avoids engine differences)
                s = s.replace(/[“”"«»‹›„‟]/g, ' ');
                s = s.replace(/[\[\](){}<>]/g, ' ');

                // 5) remove emojis/symbols ranges
                try { s = s.replace(/[\u{1F300}-\u{1FAFF}\u{2600}-\u{27BF}]/gu, ' '); } catch { }

                // 6) generic punctuation/symbol sweep (fallback-safe)
                try {
                    s = s.replace(/[\p{P}\p{S}]/gu, ' ');
                } catch {
                    // apostrophes already stripped above; avoid adding them here
                    s = s.replace(/[!#$%()*+,\-.\/:;<=>?@\\^_|~…—–‘•··]+/g, ' ');
                }

                // 7) collapse whitespace
                s = s.replace(/\s+/g, ' ').trim();

                return s;
            },

            async onText(payload) {
                const raw = (payload && (payload.text || payload)) || '';
                const eos = !!(payload && payload.eos);
                const piece = raw.trim();
                if (!piece) return;

                const combined = (this._ingressCarry ? (this._ingressCarry + ' ') : '') + piece;
                const { complete, rest } = this._splitComplete(combined);
                this._ingressCarry = rest;

                for (const s of complete) { if (!this._seenRecently(s)) this._textQ.push(s); }
                if (eos) { const tail = this._ingressCarry.trim(); if (tail && !this._seenRecently(tail)) this._textQ.push(tail); this._ingressCarry = ''; }
                if (complete.length || eos) this._pumpQueue().catch(() => { });
            },

            async _pumpQueue() {
                if (this._busy) return;
                this._busy = true;
                try {
                    while (this._textQ.length) {
                        const nextText = this._textQ.shift();
                        await this._speakOne(nextText);
                        this.enqueueF32(new Float32Array(Math.round((this._sr || 22050) * 0.03)));
                    }
                } finally { this._busy = false; }
            },

            async _speakOne(text) {
                // sanitize here — AFTER sentence concatenation, BEFORE synth
                const clean = this._sanitizeForTTS(text);
                if (!clean) return;

                const mode = qs('#ttsMode')?.value || 'stream';
                const model = (qs('#ttsModel')?.value || CFG.tts.model || '').trim();
                const viaNkn = CFG.transport === 'nkn';
                const base = CFG.tts.base;
                const relay = CFG.tts.relay;
                const api = CFG.tts.api;

                const a = qs('#ttsAudio');
                this._underruns = 0; const ur = qs('#ttsUrun'); if (ur) ur.textContent = '0';

                if (mode === 'stream') {
                    this.setState('streaming…', 'warn');
                    this.ensureAC(); await this._ac.resume();

                    const preroll = Math.round((this._sr || 22050) * 0.04);
                    if (preroll > 0) this.enqueueF32(new Float32Array(preroll));

                    const req = { text: clean, mode: 'stream', format: 'raw', ...(model ? { model, voice: model } : {}) };
                    let chunks = 0, bytes = 0;
                    const ch = qs('#ttsChunks'); const by = qs('#ttsBytes');
                    let leftover = new Uint8Array(0);
                    const sinkRate = this._sr || 22050;

                    const handleBytes = (u8) => {
                        const merged = new Uint8Array(leftover.length + u8.length);
                        merged.set(leftover, 0); merged.set(u8, leftover.length);
                        const even = (merged.length >> 1) << 1;
                        const body = merged.subarray(0, even);
                        leftover = merged.subarray(even);
                        if (!body.length) return;

                        const frames = body.length >> 1;
                        const dv = new DataView(body.buffer, body.byteOffset, body.length);
                        const i16 = new Int16Array(frames);
                        for (let i = 0; i < frames; i++) i16[i] = dv.getInt16(i * 2, true);

                        let f32 = this.int16ToF32(i16);
                        if (sinkRate !== 22050) f32 = this.resampleLinear(f32, 22050, sinkRate);
                        this.enqueueF32(f32);

                        chunks++; bytes += u8.length;
                        if (ch) ch.textContent = String(chunks);
                        if (by) by.textContent = String(bytes);
                    };

                    if (viaNkn) {
                        const spec = {
                            url: base.replace(/\/+$/, '') + '/speak',
                            method: 'POST',
                            headers: Net.auth({ 'X-Relay-Stream': 'chunks' }, api),
                            json: req,
                            timeout_ms: 120000
                        };

                        let expected = null;
                        const stash = new Map();
                        const seen = new Set();
                        const flush = () => { while (expected != null && stash.has(expected)) { const u8 = stash.get(expected); stash.delete(expected); handleBytes(u8); expected++; } };

                        await Net.nknStream(spec, relay, {
                            onBegin: () => { this.setState('stream open', 'warn') },
                            onChunk: (u8, seqRaw) => {
                                const seq = (seqRaw | 0);
                                if (seen.has(seq)) return; seen.add(seq);
                                if (expected == null) expected = seq;
                                if (seq === expected) { handleBytes(u8); expected++; flush(); }
                                else if (seq > expected) stash.set(seq, u8);
                            },
                            onEnd: () => { leftover = new Uint8Array(0); this.setState('ok', 'ok'); }
                        }, 120000);
                    }
                    else {
                        const r = await fetch(base.replace(/\/+$/, '') + '/speak', { method: 'POST', headers: Net.auth({}, api), body: JSON.stringify(req) });
                        if (!r.ok || !r.body) throw new Error(`${r.status} ${r.statusText}`);
                        const rd = r.body.getReader();
                        let httpLeftover = new Uint8Array(0);
                        while (true) {
                            const { value, done } = await rd.read();
                            if (done) break;
                            if (!value || !value.byteLength) continue;

                            const merged = new Uint8Array(httpLeftover.length + value.length);
                            merged.set(httpLeftover, 0); merged.set(value, httpLeftover.length);
                            const even = (merged.length >> 1) << 1;
                            if (even) { handleBytes(merged.subarray(0, even)); httpLeftover = merged.subarray(even); }
                            else { httpLeftover = merged; }
                        }
                        httpLeftover = new Uint8Array(0);
                        this.setState('ok', 'ok');
                    }

                    if (a) a.src = ''; // streaming via WebAudio
                    const tm = qs('#ttsMeta'); if (tm) tm.textContent = `live pcm 16-bit mono 22050Hz → ${sinkRate}Hz`;
                } else {
                    this.setState('synth…', 'warn');
                    try {
                        const data = await Net.postJSON(
                            base, '/speak',
                            { text: clean, mode: 'file', format: 'ogg', ...(model ? { model, voice: model } : {}) },
                            api, CFG.transport === 'nkn', CFG.tts.relay, 10 * 60 * 1000
                        );
                        let blob = null, mime = 'audio/ogg';
                        if (data?.files?.[0]?.url) {
                            const fileUrl = base.replace(/\/+$/, '') + data.files[0].url;
                            blob = await Net.fetchBlob(fileUrl, CFG.transport === 'nkn', CFG.tts.relay, api);
                            mime = blob.type || mime;
                        } else if (data?.audio_b64) {
                            const u8 = b64ToBytes(data.audio_b64);
                            blob = new Blob([u8], { type: mime });
                        } else { throw new Error('no audio'); }

                        if (a) { const url = URL.createObjectURL(blob); a.src = url; a.play().catch(() => { }); }
                        const tm = qs('#ttsMeta'); if (tm) tm.textContent = `${mime} • ${(blob.size / 1024).toFixed(1)} KB`;
                        this.setState('ok', 'ok');
                    } catch (e) { this.setState('error', 'err'); log('[tts] ' + e.message); }
                }
            }
        };


        /* ======== boot / bindings ======== */
        function bindUI() {
            // global
            const tr = qs('#transport'); if (tr) { tr.value = CFG.transport; tr.addEventListener('change', e => { CFG.transport = e.target.value; saveCFG(); if (CFG.transport === 'nkn') Net.ensureNkn(); setBadge('Saved') }) }
            const c1 = qs('#nknConnect'); if (c1) c1.addEventListener('click', () => Net.ensureNkn());
            const c2 = qs('#nknDisconnect'); if (c2) c2.addEventListener('click', () => { try { Net.nkn.client && Net.nkn.client.close() } catch { } Net.nkn.client = null; Net.nkn.ready = false; const i = qs('#nknInfo'); if (i) i.textContent = 'disconnected'; setBadge('NKN off') });
            const sv = qs('#saveAll'); if (sv) sv.addEventListener('click', () => { saveCFG(); setBadge('Saved') });

            // ASR inputs
            if (qs('#asrBase')) qs('#asrBase').value = CFG.asr.base; if (qs('#asrRelay')) qs('#asrRelay').value = CFG.asr.relay; if (qs('#asrApi')) qs('#asrApi').value = CFG.asr.api;
            if (qs('#asrRate')) qs('#asrRate').value = CFG.asr.rate; if (qs('#asrChunk')) qs('#asrChunk').value = CFG.asr.chunk; if (qs('#asrLive')) qs('#asrLive').value = String(!!CFG.asr.live);
            if (qs('#asrRms')) qs('#asrRms').value = CFG.asr.rms; if (qs('#asrHold')) qs('#asrHold').value = CFG.asr.hold; if (qs('#asrEmaMs')) qs('#asrEmaMs').value = CFG.asr.emaMs;
            if (qs('#asrPhraseOn')) qs('#asrPhraseOn').value = String(!!CFG.asr.phraseOn); if (qs('#asrPhraseMin')) qs('#asrPhraseMin').value = CFG.asr.phraseMin; if (qs('#asrPhraseStable')) qs('#asrPhraseStable').value = CFG.asr.phraseStable;
            if (qs('#asrSilence')) qs('#asrSilence').value = CFG.asr.silence;
            if (qs('#asrPrompt')) qs('#asrPrompt').value = CFG.asr.prompt || '';
            if (qs('#asrModel')) qs('#asrModel').value = CFG.asr.model || '';

            qsa('#asrCard input, #asrCard select, #asrCard textarea').forEach(el => el.addEventListener('change', () => {
                CFG.asr.base = qs('#asrBase')?.value.trim() || CFG.asr.base; CFG.asr.relay = qs('#asrRelay')?.value.trim() || ''; CFG.asr.api = qs('#asrApi')?.value.trim() || '';
                CFG.asr.rate = parseInt(qs('#asrRate')?.value || '16000', 10) || 16000; CFG.asr.chunk = parseInt(qs('#asrChunk')?.value || '120', 10) || 120;
                CFG.asr.live = (qs('#asrLive')?.value) === 'true';
                CFG.asr.rms = parseFloat(qs('#asrRms')?.value || '0.015') || 0.015; CFG.asr.hold = parseInt(qs('#asrHold')?.value || '250', 10) || 250; CFG.asr.emaMs = parseInt(qs('#asrEmaMs')?.value || '120', 10) || 120;
                CFG.asr.silence = parseInt(qs('#asrSilence')?.value || '900', 10) || 900;
                CFG.asr.phraseOn = (qs('#asrPhraseOn')?.value) === 'true'; CFG.asr.phraseMin = parseInt(qs('#asrPhraseMin')?.value || '3', 10) || 3; CFG.asr.phraseStable = parseInt(qs('#asrPhraseStable')?.value || '350', 10) || 350;
                CFG.asr.prompt = (qs('#asrPrompt')?.value || '').trim();
                CFG.asr.model = (qs('#asrModel')?.value || '').trim();
                saveCFG(); setBadge('Saved')
            }));
            const ab = qs('#asrStart'); if (ab) ab.addEventListener('click', () => ASR.start());
            const as = qs('#asrStop'); if (as) as.addEventListener('click', () => ASR.stop());
            const arf = qs('#asrRefresh'); if (arf) arf.addEventListener('click', () => ASR.refreshModels());

            // LLM inputs

            // Ensure LLM config defaults exist
            CFG.llm = Object.assign({
                base: '',
                relay: '',
                api: '',
                model: '',
                stream: true,
                useSystem: false,
                system: '',
                memoryOn: false,
                persistMemory: false,
                maxTurns: 16,
                memory: []   // persisted history (optional)
            }, CFG.llm || {});


            if (qs('#llmBase')) qs('#llmBase').value = CFG.llm.base; if (qs('#llmRelay')) qs('#llmRelay').value = CFG.llm.relay; if (qs('#llmApi')) qs('#llmApi').value = CFG.llm.api;
            if (qs('#llmStream')) qs('#llmStream').value = String(!!CFG.llm.stream);
            // New LLM memory/system UI defaults
            if (qs('#llmUseSystem')) qs('#llmUseSystem').value = String(!!CFG.llm.useSystem);
            if (qs('#llmSystem')) qs('#llmSystem').value = CFG.llm.system || '';
            if (qs('#llmMemory')) qs('#llmMemory').value = String(!!CFG.llm.memoryOn);
            if (qs('#llmPersistMemory')) qs('#llmPersistMemory').value = String(!!CFG.llm.persistMemory);
            if (qs('#llmMaxTurns')) qs('#llmMaxTurns').value = (CFG.llm.maxTurns ?? 16);
            if (qs('#llmMemSize')) qs('#llmMemSize').textContent = String((CFG.llm.memory && CFG.llm.memory.length) || 0);

            qsa('#llmCard input, #llmCard select, #llmCard textarea').forEach(el => el.addEventListener('change', () => {
                CFG.llm.base = qs('#llmBase')?.value.trim() || CFG.llm.base;
                CFG.llm.relay = qs('#llmRelay')?.value.trim() || '';
                CFG.llm.api = qs('#llmApi')?.value.trim() || '';
                CFG.llm.model = qs('#llmModel')?.value || CFG.llm.model;
                CFG.llm.stream = (qs('#llmStream')?.value) === 'true';

                // new fields
                CFG.llm.useSystem = (qs('#llmUseSystem')?.value) === 'true';
                CFG.llm.system = (qs('#llmSystem')?.value || '').trim();
                CFG.llm.memoryOn = (qs('#llmMemory')?.value) === 'true';
                CFG.llm.persistMemory = (qs('#llmPersistMemory')?.value) === 'true';
                CFG.llm.maxTurns = parseInt(qs('#llmMaxTurns')?.value || '16', 10) || 16;

                saveCFG(); setBadge('Saved');
            }));

            const lr = qs('#llmRefresh'); if (lr) lr.addEventListener('click', () => LLM.refreshModels());
            const lcm = qs('#llmClearMemory');
            if (lcm) lcm.addEventListener('click', () => {
                LLM.clearMemory();
                const ms = qs('#llmMemSize'); if (ms) ms.textContent = '0';
                setBadge('Memory cleared');
            });

            // TTS inputs
            if (qs('#ttsBase')) qs('#ttsBase').value = CFG.tts.base; if (qs('#ttsRelay')) qs('#ttsRelay').value = CFG.tts.relay; if (qs('#ttsApi')) qs('#ttsApi').value = CFG.tts.api;
            if (qs('#ttsModel')) qs('#ttsModel').value = CFG.tts.model || ''; if (qs('#ttsMode')) qs('#ttsMode').value = CFG.tts.mode || 'stream';
            qsa('#ttsCard input, #ttsCard select').forEach(el => el.addEventListener('change', () => {
                CFG.tts.base = qs('#ttsBase')?.value.trim() || CFG.tts.base; CFG.tts.relay = qs('#ttsRelay')?.value.trim() || ''; CFG.tts.api = qs('#ttsApi')?.value.trim() || '';
                CFG.tts.model = qs('#ttsModel')?.value.trim() || ''; CFG.tts.mode = qs('#ttsMode')?.value || 'stream'; saveCFG();
            }));
            const trf = qs('#ttsRefresh'); if (trf) trf.addEventListener('click', () => TTS.refreshModels());

            // wires
            const state = qs('#wireState'); if (state) state.textContent = CFG.wireMode ? 'ON' : 'OFF';
            const wt = qs('#wireToggle'); if (wt) wt.addEventListener('click', () => { CFG.wireMode = !CFG.wireMode; if (state) state.textContent = CFG.wireMode ? 'ON' : 'OFF'; saveCFG() });
            const cw = qs('#clearWires'); if (cw) cw.addEventListener('click', () => Router.clear());
        }

        function bindPorts() {
            Router.register('asr:partial', qsa('[data-port="asr:partial"]')[0], () => { });
            Router.register('asr:phrase', qsa('[data-port="asr:phrase"]')[0], (p) => LLM.onPrompt(p));
            Router.register('asr:final', qsa('[data-port="asr:final"]')[0], (p) => LLM.onPrompt(p));
            Router.register('llm:prompt', qsa('[data-port="llm:prompt"]')[0], (p) => LLM.onPrompt(p));
            Router.register('llm:delta', qsa('[data-port="llm:delta"]')[0], () => { });
            Router.register('llm:final', qsa('[data-port="llm:final"]')[0], (p) => TTS.onText(p));
            Router.register('tts:text', qsa('[data-port="tts:text"]')[0], (p) => TTS.onText(p));
            Router.render();
        }

        /* boot */
        function init() {
            bindUI(); bindPorts();
            if (!CFG.asr.prompt || !CFG.asr.prompt.trim()) {
                CFG.asr.prompt = ASR_DEFAULT_PROMPT;
                const p = qs('#asrPrompt'); if (p) p.value = CFG.asr.prompt;
                saveCFG();
            }
            if (CFG.transport === 'nkn') Net.ensureNkn();
            setBadge('Ready');
            ASR.refreshModels();
            LLM.refreshModels();
            TTS.refreshModels();
            const wb = qs('#wiresBox');
            if (wb) wb.textContent = CFG.wires.length ? CFG.wires.map((w, i) => `${i + 1}. ${w.from} → ${w.to}`).join('\n') : '(no wires)';
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>

</body>

</html>
