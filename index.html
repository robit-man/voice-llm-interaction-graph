<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Realtime Graph — ASR → LLM → TTS (Node‑Isolated)</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: rgba(255, 255, 255, .07);
      --panel2: rgba(255, 255, 255, .05);
      --accent: #66e0ff;
      --accent2: #a8ff60;
      --text: #e8f1f8;
      --muted: #a9b6c3;
      --ok: #7dffb0;
      --warn: #f9c846;
      --err: #ff6b6b;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      --r: 16px;
      --shadow: 0 10px 30px rgba(0, 0, 0, .35), inset 0 0 1px rgba(255, 255, 255, .12)
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      color: var(--text);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial
    }

    body::after {
      content: '';
      position: fixed;
      inset: 0;
      z-index: -1;
      background: black;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 18px
    }

    .header-actions {
      display: flex;
      gap: 12px;
      align-items: center
    }

    .transport-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 8px 18px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, .25);
      background: transparent;
      color: var(--text);
      font-weight: 600;
      cursor: pointer;
      transition: background .2s ease, color .2s ease, border .2s ease, box-shadow .2s ease;
    }

    .transport-btn .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      box-shadow: 0 0 12px currentColor;
    }

    .transport-btn.active {
      border-color: rgba(102, 224, 255, .65);
      box-shadow: 0 0 18px rgba(102, 224, 255, 0.25);
    }

    @media(max-width: 640px) {
      .brand-text {
        display: none;
      }
      .card{
        padding:unset!important;border:0px!important;background:unset!important;
      }
    }

    option {
      background: #000a;
    }

    .brand {
      display: flex;
      gap: 12px;
      align-items: center
    }

    .logo {
      width: 36px;
      height: 36px
    }

    .brand-text h1 {
      margin: 0;
      font-size: 18px
    }

    .brand-text .hint {
      color: var(--muted);
      font-size: 12px
    }

    .badge {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, .15);
      background: rgba(255, 255, 255, .06)
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%
    }

    .dot.ok {
      background: var(--ok);
      box-shadow: 0 0 10px var(--ok)
    }

    .dot.warn {
      background: var(--warn);
      box-shadow: 0 0 10px var(--warn)
    }

    .dot.err {
      background: var(--err);
      box-shadow: 0 0 10px var(--err)
    }

    main {
      display: grid;
      gap: 14px;
      padding: 0 18px 24px;
      grid-template-columns: repeat(12, 1fr)
    }

    .card {
      grid-column: span 12;
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, .08);
      border-radius: var(--r);
      backdrop-filter: blur(8px);
      padding: 14px
    }

    @media(min-width:980px) {
      .span-4 {
        grid-column: span 4
      }

      .span-8 {
        grid-column: span 8
      }
    }

    h2 {
      margin: 0 0 8px;
      font-size: 15px
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center
    }

    label {
      font-size: 12px;
      color: var(--muted);
      margin-right: 6px
    }

    input,
    select,
    textarea {
      width: 100%;
      background: var(--panel2);
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, .15);
      border-radius: 12px;
      padding: 9px 11px;
      outline: none
    }

    textarea {
      min-height: 84px;
      resize: vertical
    }

    .input-with-btn {
      display: flex;
      gap: 8px;
      align-items: center
    }

    .input-with-btn > :first-child {
      flex: 1 1 auto
    }

    .input-with-btn button {
      flex: 0 0 auto;
    }

    #qrModal video {
      width: 100%;
      max-height: 320px;
      border-radius: 12px;
      background: black
    }

    #qrModal canvas {
      display: none
    }

    .qr-body {
      display: flex;
      flex-direction: column;
      gap: 12px
    }

    button {
      background: white;
      color: #000000;
      border: 0;
      border-radius: 8px;
      padding: 9px 12px;
      font-weight: 700;
      cursor: pointer
    }

    button.secondary {
      background: white;
      color: #000000
    }

    button.ghost {
      background: transparent;
      border: 1px solid rgba(255, 255, 255, .2);
      color: var(--text)
    }

    button.danger {
      background: indianred;
      color: #280a0a
    }

    .code {
      font-family: var(--mono);
      font-size: 12px;
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid rgba(255, 255, 255, .12);
      border-radius: 4px;
      padding: 10px;
      white-space: pre-wrap;
      max-height: 260px;
      overflow: auto
    }

    .bubble {
      background: rgba(0, 0, 0, .25);
      max-height: 150px;
      overflow: auto;
      border: 1px solid rgba(255, 255, 255, .12);
      padding: 10px;
      border-radius: 4px
    }

    .muted {
      color: var(--muted);
      font-size: 12px
    }

    .vu {
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .08);
      border: 1px solid rgba(255, 255, 255, .15);
      overflow: hidden
    }

    .vu>b {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #22c55e, #eab308, #ef4444)
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border: 1px solid rgba(255, 255, 255, .18);
      border-radius: 999px;
      background: rgba(255, 255, 255, .06);
      font-family: var(--mono);
      font-size: 12px
    }

    /* Workspace */
    #workspaceWrap {
      position: relative;
      min-height: 520px;
      height: calc(100vh - 50rem);
      border-radius: calc(var(--r) / 2);
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, .12);
      background:
        linear-gradient(var(--panel2), var(--panel2)),
        repeating-linear-gradient(0deg, transparent 0 28px, rgba(255, 255, 255, .06) 28px 29px),
        repeating-linear-gradient(90deg, transparent 0 28px, rgba(255, 255, 255, .06) 28px 29px);
      touch-action: none;
    }

    #workspace {
      position: absolute;
      inset: 0;
      touch-action: none;
    }

    #wsCanvas {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      transform-origin: 0 0;
      will-change: transform;
      touch-action: none;
    }


    #linksSvg {
      position: absolute;
      inset: 0;
      pointer-events: none
    }

    /* Node */
    .node {
      position: absolute;
      min-width: 230px;
      min-height: 230px;
      min-height: min-content;
      max-width: 512px;
      max-height: 512px;
      background: rgba(255, 255, 255, .08);
      border: 1px solid rgba(255, 255, 255, .18);
      border-radius: 14px;
      box-shadow: var(--shadow);
      user-select: none
    }

    .node .head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 8px 10px;
      cursor: grab;
      background: rgba(0, 0, 0, .15);
      border-bottom: 1px solid rgba(255, 255, 255, .12);
      border-top-left-radius: 14px;
      border-top-right-radius: 14px
    }

    .node .titleRow {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1 1 auto;
    }

    .node .node-transport {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, .25);
      background: transparent;
      color: var(--text);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background .2s ease, color .2s ease, border .2s ease, box-shadow .2s ease;
    }

    .node .node-transport .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      box-shadow: 0 0 10px currentColor;
    }

    .node .node-transport.active {
      border-color: rgba(102, 224, 255, .65);
      box-shadow: 0 0 12px rgba(102, 224, 255, 0.25);
    }

    .node .head:active {
      cursor: grabbing
    }

    .node .title {
      font-weight: 700;
      font-size: 13px
    }

    .node .gear {
      width: 24px;
      height: 24px;
      border-radius: 8px;
      padding: 0;
      line-height: 24px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: 1px solid rgba(255, 255, 255, .25);
      color: var(--text)
    }

    .node .gear:hover {
      background: rgba(255, 255, 255, .08)
    }

    .node .body {
      padding: 10px
    }

    .node .ports {
      display: flex;
      justify-content: space-between;
      gap: 10px
    }

    .node .side {
      display: flex;
      flex-direction: column;
      gap: 8px
    }

    .wp-port {
      --sz: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
      font-family: var(--mono);
      font-size: 12px;
      cursor: pointer
    }

    .wp-port .dot {
      width: var(--sz);
      height: var(--sz);
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, .8);
      background: rgba(255, 255, 255, .15)
    }

    .wp-port.drop-hover {
      border-radius: 999px;
      outline: 2px solid rgba(102, 224, 255, .6);
      outline-offset: 3px;
    }

    .wp-port.drop-hover .dot {
      box-shadow: 0 0 12px rgba(102, 224, 255, .8);
    }

    .wp-port.out .dot {
      box-shadow: 0 0 0 2px rgba(102, 224, 255, .25)
    }

    .right .out {
      justify-content: flex-end;
    }

    .wp-port.in .dot {
      box-shadow: 0 0 0 2px rgba(168, 255, 96, .25)
    }

    .wp-port.sel .dot {
      background: var(--accent)
    }

    /* Modal */
    .modal.hidden {
      display: none
    }

    .modal {
      position: fixed;
      inset: 0;
      z-index: 1000
    }

    .modal-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, .5);
      backdrop-filter: blur(20px)
    }

    .modal-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: min(880px, calc(100% - 28px));
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, .18);
      border-radius: 16px;
      padding: 14px;
      max-height: calc(100vh - 80px);
      overflow: auto
    }

    .modal-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px
    }

    .modal-title {
      font-weight: 800;
      font-size: 15px
    }

    .form-grid {
      display: grid;
      grid-template-columns: 160px 1fr;
      gap: 8px
    }

    .help {
      font-size: 11px;
      color: var(--muted)
    }

    audio {
      width: 100%;
      height: 32px
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/nkn-sdk@1.3.6/dist/nkn.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
</head>

<body>
  <header>
    <div class="brand">
      <div class="logo">
        <svg xmlns="http://www.w3.org/2000/svg" width="2rem" height="2rem" viewBox="0 0 24 24" fill="none">
          <path
            d="M8 6.5H16M7.70502 8.70919L12.2826 15.3034M4.6 9H6.4C6.96005 9 7.24008 9 7.45399 8.89101C7.64215 8.79513 7.79513 8.64215 7.89101 8.45399C8 8.24008 8 7.96005 8 7.4V5.6C8 5.03995 8 4.75992 7.89101 4.54601C7.79513 4.35785 7.64215 4.20487 7.45399 4.10899C7.24008 4 6.96005 4 6.4 4H4.6C4.03995 4 3.75992 4 3.54601 4.10899C3.35785 4.20487 3.20487 4.35785 3.10899 4.54601C3 4.75992 3 5.03995 3 5.6V7.4C3 7.96005 3 8.24008 3.10899 8.45399C3.20487 8.64215 3.35785 8.79513 3.54601 8.89101C3.75992 9 4.03995 9 4.6 9ZM13.6 20H15.4C15.9601 20 16.2401 20 16.454 19.891C16.6422 19.7951 16.7951 19.6422 16.891 19.454C17 19.2401 17 18.9601 17 18.4V16.6C17 16.0399 17 15.7599 16.891 15.546C16.7951 15.3578 16.6422 15.2049 16.454 15.109C16.2401 15 15.9601 15 15.4 15H13.6C13.0399 15 12.7599 15 12.546 15.109C12.3578 15.2049 12.2049 15.3578 12.109 15.546C12 15.7599 12 16.0399 12 16.6V18.4C12 18.9601 12 19.2401 12.109 19.454C12.2049 19.6422 12.3578 19.7951 12.546 19.891C12.7599 20 13.0399 20 13.6 20ZM17.6 9H19.4C19.9601 9 20.2401 9 20.454 8.89101C20.6422 8.79513 20.7951 8.64215 20.891 8.45399C21 8.24008 21 7.96005 21 7.4V5.6C21 5.03995 21 4.75992 20.891 4.54601C20.7951 4.35785 20.6422 4.20487 20.454 4.10899C20.2401 4 19.9601 4 19.4 4H17.6C17.0399 4 16.7599 4 16.546 4.10899C16.3578 4.20487 16.2049 4.35785 16.109 4.54601C16 4.75992 16 5.03995 16 5.6V7.4C16 7.96005 16 8.24008 16.109 8.45399C16.2049 8.64215 16.3578 8.79513 16.546 8.89101C16.7599 9 17.0399 9 17.6 9Z"
            stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </svg>
      </div>
      <div class="brand-text">
        <h1>Inference Graph Playground</h1>
        <div class="hint">ASR → LLM → TTS · HTTP or NKN Endpoints · Node‑Isolated</div>
      </div>
    </div>
    <div class="header-actions">
      <button id="transportToggle" class="transport-btn">HTTP</button>
    </div>
  </header>

  <main>

    <!-- GRAPH WORKSPACE -->
    <section class="card span-12" id="graphCard">
      <h2>Graph Workspace</h2>
      <div class="row" style="margin-bottom:10px;">
        <button id="addASR">+ ASR</button>
        <button id="addLLM" class="secondary">+ LLM</button>
        <button id="addTTS" class="ghost">+ TTS</button>
        <button id="exportGraph" class="ghost">Export</button>
        <button id="importGraph" class="ghost">Import</button>
        <span class="muted">Drag nodes, click an output port then an input port to link. Alt/⌥‑click a wire to
          remove.</span>
      </div>

      <div id="workspaceWrap">
        <svg id="linksSvg" width="100%" height="100%" preserveAspectRatio="none"></svg>
        <div id="workspace">
          <div id="wsCanvas"></div>
        </div>
      </div>
    </section>

    <!-- ROUTES -->
    <section class="card span-12">
      <h2>Routes</h2>
      <div id="wiresBox" class="code" style="min-height:54px"></div>
    </section>

    <!-- LOGS -->
    <section class="card span-12">
      <h2>Status / Logs</h2>
      <div id="logBox" class="code" style="min-height:120px">(logs)</div>
    </section>
  </main>

  <!-- SETTINGS MODAL (dynamic contents) -->
  <div id="settingsModal" class="modal hidden" aria-hidden="true">
    <div class="modal-backdrop" id="closeBackdrop"></div>
    <div class="modal-panel">
      <div class="modal-head">
        <div class="modal-title">Node Settings</div>
        <button class="ghost" id="closeSettings">✕</button>
      </div>
      <form id="settingsForm">
        <div id="settingsFields" class="form-grid"></div>
        <div class="help" id="settingsHelp" style="margin-top:6px;">—</div>
        <div class="row" style="margin-top:12px;">
          <button id="saveSettings">Save to Node</button>
          <button class="ghost" id="cancelSettings" type="button">Close</button>
        </div>
      </form>
    </div>
  </div>

  <div id="qrModal" class="modal hidden" aria-hidden="true">
    <div class="modal-backdrop" id="qrBackdrop"></div>
    <div class="modal-panel" style="max-width:420px;">
      <div class="modal-head">
        <div class="modal-title">Scan NKN Address</div>
        <button class="ghost" id="qrClose">✕</button>
      </div>
      <div class="qr-body">
        <video id="qrVideo" autoplay playsinline muted></video>
        <canvas id="qrCanvas" width="0" height="0"></canvas>
        <div class="help">Align the QR code within the frame. The scanned value will populate the field automatically.</div>
        <button class="ghost" type="button" id="qrStop">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    /* ============================================================
       Helpers & persistence
       ============================================================ */
    const ASR_DEFAULT_PROMPT =
      "Context: live interactive conversation, not a video or broadcast. " +
      "Transcribe exactly what is spoken. Do not add generic media sign-offs. " +
      "Avoid phrases such as: \"thanks for watching\", \"like and subscribe\", " +
      "\"don't forget to subscribe\", \"link in the description\".";

    const SIGNOFF_RE = /\b(thanks(?:,)?\s+for\s+(?:watching|listening)|(?:don['’]t\s+forget\s+to\s+)?(?:like|subscribe)|like\s+and\s+subscribe|link\s+in\s+(?:the\s+)?description)\b/i;

    const LS = {
      get(k, d) { try { const v = localStorage.getItem(k); return v ? JSON.parse(v) : d } catch { return d } },
      set(k, v) { localStorage.setItem(k, JSON.stringify(v)) },
      del(k) { localStorage.removeItem(k) }
    };
    const qs = s => document.querySelector(s);
    const qsa = s => Array.from(document.querySelectorAll(s));
    const td = new TextDecoder();
    const b64ToBytes = (b64) => { const bin = atob(b64); const u8 = new Uint8Array(bin.length); for (let i = 0; i < bin.length; i++)u8[i] = bin.charCodeAt(i); return u8 };
    function j(x) { try { return JSON.stringify(x, null, 2) } catch { return String(x) } }
    function log(s) { const b = qs('#logBox'); if (!b) return; b.textContent = (b.textContent + '\n' + s).trim().slice(-9000); b.scrollTop = b.scrollHeight }
    function setBadge(msg, ok = true) { const el = qs('#logBox'); if (!el) return; log(msg); }

    function updateTransportButton() {
      const btn = qs('#transportToggle');
      if (!btn) return;
      btn.innerHTML = '';

      const dot = document.createElement('span');
      dot.className = 'dot';
      const label = document.createElement('span');

      if (CFG.transport === 'nkn') {
        btn.classList.add('active');
        label.textContent = 'NKN';
        if (Net?.nkn?.ready) {
          dot.classList.add('ok');
          btn.title = Net.nkn.addr || 'NKN relay address';
        } else {
          dot.classList.add(Net?.nkn?.client ? 'warn' : 'err');
          btn.title = 'NKN relay connecting';
        }
      } else {
        btn.classList.remove('active');
        label.textContent = 'HTTP';
        dot.classList.add('err');
        btn.title = 'HTTP transport';
      }

      btn.append(dot, label);
    }

    const QRScan = {
      modal: null,
      video: null,
      canvas: null,
      ctx: null,
      stream: null,
      raf: null,
      target: null,
      onResult: null,
      ready: false
    };

    function setupQrScanner() {
      if (QRScan.ready) return;
      QRScan.modal = qs('#qrModal');
      QRScan.video = qs('#qrVideo');
      QRScan.canvas = qs('#qrCanvas');
      if (QRScan.canvas) QRScan.ctx = QRScan.canvas.getContext('2d');
      qs('#qrClose')?.addEventListener('click', () => closeQrScanner());
      qs('#qrStop')?.addEventListener('click', () => closeQrScanner());
      qs('#qrBackdrop')?.addEventListener('click', () => closeQrScanner());
      window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && QRScan.modal && !QRScan.modal.classList.contains('hidden')) closeQrScanner(); });
      QRScan.ready = true;
    }

    async function openQrScanner(targetInput, onResult) {
      setupQrScanner();
      if (!QRScan.modal) return;
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { setBadge('Camera not available', false); return; }
      if (!window.jsQR) { setBadge('QR library missing', false); return; }
      try { closeQrScanner(); } catch { }
      QRScan.target = targetInput || null;
      QRScan.onResult = (typeof onResult === 'function') ? onResult : null;
      QRScan.modal.classList.remove('hidden');
      QRScan.modal.setAttribute('aria-hidden', 'false');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
        QRScan.stream = stream;
        if (QRScan.video) {
          QRScan.video.srcObject = stream;
          await QRScan.video.play().catch(() => { });
        }
        QRScan.raf = requestAnimationFrame(scanQrFrame);
      } catch (err) {
        closeQrScanner();
        setBadge('Camera access denied', false);
      }
    }

    function stopQrStream() {
      if (QRScan.raf) cancelAnimationFrame(QRScan.raf);
      QRScan.raf = null;
      if (QRScan.stream) {
        QRScan.stream.getTracks().forEach(t => { try { t.stop() } catch { } });
      }
      QRScan.stream = null;
      if (QRScan.video) {
        QRScan.video.pause();
        QRScan.video.srcObject = null;
      }
    }

    function closeQrScanner() {
      stopQrStream();
      if (QRScan.modal) {
        QRScan.modal.classList.add('hidden');
        QRScan.modal.setAttribute('aria-hidden', 'true');
      }
      QRScan.target = null;
      QRScan.onResult = null;
    }

    function scanQrFrame() {
      if (!QRScan.video || !QRScan.canvas || !QRScan.ctx) {
        QRScan.raf = requestAnimationFrame(scanQrFrame);
        return;
      }
      if (QRScan.video.readyState < 2) {
        QRScan.raf = requestAnimationFrame(scanQrFrame);
        return;
      }
      const vw = QRScan.video.videoWidth || 0;
      const vh = QRScan.video.videoHeight || 0;
      if (!vw || !vh) {
        QRScan.raf = requestAnimationFrame(scanQrFrame);
        return;
      }
      if (QRScan.canvas.width !== vw) QRScan.canvas.width = vw;
      if (QRScan.canvas.height !== vh) QRScan.canvas.height = vh;
      QRScan.ctx.drawImage(QRScan.video, 0, 0, vw, vh);
      try {
        const img = QRScan.ctx.getImageData(0, 0, vw, vh);
        const code = window.jsQR ? window.jsQR(img.data, vw, vh) : null;
        if (code && code.data) {
          const txt = code.data.trim();
            if (txt) {
              if (QRScan.target) {
                QRScan.target.value = txt;
                QRScan.target.dispatchEvent(new Event('input', { bubbles: true }));
              }
              if (QRScan.onResult) {
                try { QRScan.onResult(txt); } catch { }
              }
              const form = qs('#settingsForm');
              const nodeId = form?.dataset?.nodeId;
              if (nodeId) {
                try {
                  NodeStore.setRelay(nodeId, NodeStore.load(nodeId)?.type || 'LLM', txt);
                  if (typeof Graph !== 'undefined' && Graph.refreshTransportButtons) Graph.refreshTransportButtons();
                  if (typeof updateTransportButton === 'function') updateTransportButton();
                  if (typeof saveGraph === 'function') saveGraph();
                } catch { }
              }
            setBadge('QR scanned');
            closeQrScanner();
            return;
          }
        }
      } catch { }
      QRScan.raf = requestAnimationFrame(scanQrFrame);
    }

    /* ============================================================
       Global CFG (only global flags; all node configs are per‑node)
       ============================================================ */
    const CFG = LS.get('graph.cfg', {
      transport: 'http',
      wires: []      // [{ from:'nodeId:out:port', to:'nodeId:in:port' }]
    });
    function saveCFG() { LS.set('graph.cfg', CFG) }

    /* ============================================================
       Net (HTTP + NKN)
       ============================================================ */
    const Net = {
      nkn: { client: null, ready: false, addr: '', pend: new Map(), streams: new Map() },
      auth(h = {}, api) {
        const out = { ...h };
        if (!out['Content-Type']) out['Content-Type'] = 'application/json';
        if (api) {
          if (/^Bearer\s+/i.test(api)) out['Authorization'] = api;
          else out['X-API-Key'] = api;
        }
        return out;
      },
      async getJSON(base, path, api, useNkn, relay) {
        if (!useNkn) {
          const headers = this.auth({}, api);
          delete headers['Content-Type'];
          headers['Accept'] = 'application/json';
          const r = await fetch(base.replace(/\/+$/, '') + path, { headers });
          if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
          return r.json();
        }
        return this.nknFetch(base, path, 'GET', null, api, relay);
      },
      async postJSON(base, path, body, api, useNkn, relay, timeout = 45000) {
        if (!useNkn) {
          const r = await fetch(base.replace(/\/+$/, '') + path, { method: 'POST', headers: this.auth({}, api), body: JSON.stringify(body || {}) });
          if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
          return r.json();
        }
        return this.nknFetch(base, path, 'POST', body, api, relay, timeout);
      },
      async fetchBlob(fullUrl, useNkn, relay, api) {
        if (!useNkn) { const r = await fetch(fullUrl, { headers: this.auth({}, api) }); if (!r.ok) throw new Error(`${r.status} ${r.statusText}`); return r.blob() }
        return this.nknFetchBlob(fullUrl, relay, api)
      },

      ensureNkn() {
        if (CFG.transport !== 'nkn') return;
        if (this.nkn.client) return;
        if (!window.nkn || !window.nkn.MultiClient) { setBadge('nkn-sdk missing', false); return }
        const c = new window.nkn.MultiClient({ identifier: 'graph', numSubClients: 4, wsConnHeartbeatTimeout: 60000 });
        this.nkn.client = c;
        updateTransportButton();
        c.on('connect', () => { this.nkn.ready = true; this.nkn.addr = c.addr || ''; updateTransportButton(); setBadge('NKN ready') });
        c.on('close', () => { this.nkn.ready = false; updateTransportButton(); });
        c.on('message', (a, b) => {
          let p = (a && typeof a === 'object' && a.payload !== undefined) ? a.payload : b;
          try {
            const msg = JSON.parse((p && p.toString) ? p.toString() : String(p));
            const ev = msg.event || ''; const id = msg.id;
            if (ev === 'relay.response' && id) { const pr = this.nkn.pend.get(id); if (pr) { clearTimeout(pr.t); this.nkn.pend.delete(id); pr.res(msg) } return }
            if (/^relay\.response\.(begin|chunk|end|lines)$/.test(ev) && id) {
              const st = this.nkn.streams.get(id); if (!st) return;
              if (ev === 'relay.response.begin') { st.onBegin && st.onBegin(msg); return }
              if (ev === 'relay.response.chunk') { const u8 = b64ToBytes(msg.b64 || ''); st.onChunk && st.onChunk(u8, msg.seq | 0); return }
              if (ev === 'relay.response.lines') {
                const arr = Array.isArray(msg.lines) ? msg.lines : [];
                for (const it of arr) { try { st.onLine && st.onLine(it.line, it.seq | 0, it.ts) } catch { } }
                return;
              }
              if (ev === 'relay.response.end') {
                // Linger a bit to allow straggler chunks to arrive out-of-order.
                // We keep delivering chunks to the same handler during this window.
                if (!st) return;
                try { if (st._lingerTimer) clearTimeout(st._lingerTimer) } catch { }
                st._ended = true;
                st._endMsg = msg;
                const linger = Math.max(0, Number(st.lingerEndMs ?? 150));
                st._lingerTimer = setTimeout(() => {
                  try { st.onEnd && st.onEnd(st._endMsg || msg) }
                  finally {
                    try { clearTimeout(st._lingerTimer) } catch { }
                    this.nkn.streams.delete(id);
                  }
                }, linger);
                return;
              }
            }
          } catch { }
        });
      },
      async nknSend(req, relay, timeout = 45000) {
        if (!relay) throw new Error('No relay');
        if (!this.nkn.client) this.ensureNkn();
        const id = 'g-' + Date.now() + '-' + Math.random().toString(36).slice(2);
        return new Promise((res, rej) => {
          const t = setTimeout(() => { this.nkn.pend.delete(id); rej(new Error('NKN relay timeout')) }, timeout);
          this.nkn.pend.set(id, { res, rej, t });
          this.nkn.client.send(relay, JSON.stringify({ event: 'http.request', id, req }), { noReply: true, maxHoldingSeconds: 120 })
            .catch(e => { clearTimeout(t); this.nkn.pend.delete(id); rej(e) });
        });
      },
      async nknStream(req, relay, handlers = {}, timeout = 300000) {
        if (!relay) throw new Error('No relay');
        if (!this.nkn.client) this.ensureNkn();
        const id = 'g-' + Date.now() + '-' + Math.random().toString(36).slice(2);
        return new Promise(async (resolve, reject) => {
          let to = null;
          const wrapped = {
            onBegin: (...a) => { try { handlers.onBegin && handlers.onBegin(...a) } catch { } },
            onLine: (...a) => { try { handlers.onLine && handlers.onLine(...a) } catch { } },
            onChunk: (...a) => { try { handlers.onChunk && handlers.onChunk(...a) } catch { } },
            onEnd: (...a) => { try { handlers.onEnd && handlers.onEnd(...a) } finally { clearTimeout(to); this.nkn.streams.delete(id); resolve(); } },
            onError: (err) => { clearTimeout(to); this.nkn.streams.delete(id); reject(err instanceof Error ? err : new Error(String(err || 'nkn stream error'))) }
          };
          // Hint for the message loop to linger after 'end'
          wrapped.lingerEndMs = handlers.lingerEndMs ?? 150;
          this.nkn.streams.set(id, wrapped);
          try {
            await this.nkn.client.send(
              relay,
              JSON.stringify({ event: 'http.request', id, req: Object.assign({ stream: 'chunks' }, req) }),
              { noReply: true, maxHoldingSeconds: 120 }
            );
          } catch (e) { this.nkn.streams.delete(id); return reject(e) }
          to = setTimeout(() => {
            const st = this.nkn.streams.get(id);
            if (st) { this.nkn.streams.delete(id); reject(new Error('NKN stream timeout')) }
          }, timeout);
        });
      },
      async nknFetch(base, path, method, json, api, relay, timeout = 45000) {
        const headers = this.auth({}, api);
        if (method === 'GET') { delete headers['Content-Type']; headers['Accept'] = 'application/json' }
        const req = { url: base.replace(/\/+$/, '') + path, method, headers, timeout_ms: timeout };
        if (json !== null) req.json = json;
        const r = await this.nknSend(req, relay, timeout);
        if (!r || r.ok === false) throw new Error((r && r.error) || ('HTTP ' + (r && r.status)));
        if (r.json !== undefined && r.json !== null) return r.json;
        if (r.body_b64) { const u8 = b64ToBytes(r.body_b64); return JSON.parse(td.decode(u8)) }
        return null;
      },
      async nknFetchBlob(fullUrl, relay, api) {
        const parts = []; let ctype = 'application/octet-stream';
        await this.nknStream(
          { url: fullUrl, method: 'GET', headers: this.auth({ 'X-Relay-Stream': 'chunks' }, api), timeout_ms: 10 * 60 * 1000 },
          relay,
          { onBegin: (m) => { const h = m.headers || {}; ctype = h['content-type'] || h['Content-Type'] || ctype }, onChunk: (u8) => parts.push(u8), onEnd: () => { } }
        );
        return new Blob(parts, { type: ctype });
      }
    };

    /* ============================================================
       Router (graph wires)
       ============================================================ */
    const Router = {
      ports: new Map(), wires: CFG.wires.slice(), sel: null,
      register(key, el, onrecv) {
        this.ports.set(key, { el, onrecv });
        // also register alias id:in:port or type:id:port when possible
        const m = /^([a-z]+):([^:]+):(.+)$/.exec(key);
        if (m) { this.ports.set(`${m[2]}:in:${m[3]}`, { el, onrecv }); }
        const n = /^([^:]+):in:(.+)$/.exec(key);
        if (n && el) {
          const typeGuess = el.closest('.node')?.querySelector('.title')?.textContent?.trim()?.toLowerCase();
          if (typeGuess) this.ports.set(`${typeGuess}:${n[1]}:${n[2]}`, { el, onrecv });
        }
        if (!el) return;
        el.addEventListener('click', () => {
          if (!this.sel) { this.sel = key; el.classList.add('sel'); return }
          const from = this.sel; this.clearSel();
          if (from === key) return;
          if (!this.wires.find(w => w.from === from && w.to === key)) {
            this.wires.push({ from, to: key });
            CFG.wires = this.wires.slice(); saveCFG(); this.render();
            log(`wired ${from} → ${key}`);
          }
        });
      },
      sendFrom(nodeId, portName, payload) {
        this.send(`${nodeId}:out:${portName}`, payload);
      },
      clearSel() { qsa('.wp-port.sel').forEach(e => e.classList.remove('sel')); this.sel = null },
      send(from, payload) {
        for (const w of this.wires) {
          if (w.from === from) { const p = this.ports.get(w.to); try { p && p.onrecv && p.onrecv(payload, from, w.to) } catch (e) { log(`wire error ${w.from}→${w.to}: ${e.message}`) } }
        }
      },
      render() {
        const box = qs('#wiresBox'); if (!box) return;
        box.textContent = this.wires.length ? this.wires.map((w, i) => `${i + 1}. ${w.from} → ${w.to}`).join('\n') : '(no wires)';
      },
      clear() { this.wires.length = 0; CFG.wires = []; saveCFG(); this.render() }
    };

    /* ============================================================
       NodeStore — per‑node isolated configs (localStorage)
       ============================================================ */
    const NodeStore = {
      key: (id) => `graph.node.${id}`,
      defaultsByType: {
        ASR: {
          base: 'http://localhost:8126', relay: '', api: '', model: '',
          mode: 'fast', rate: 16000, chunk: 120, live: true,
          rms: 0.015, hold: 250, emaMs: 120,
          phraseOn: true, phraseMin: 3, phraseStable: 350,
          silence: 900, prompt: ASR_DEFAULT_PROMPT,
          prevWin: '', prevStep: '', prevModel: ''
        },
        LLM: {
          base: 'http://127.0.0.1:11434', relay: '', api: '', model: '',
          stream: true, useSystem: false, system: '',
          memoryOn: false, persistMemory: false, maxTurns: 16, memory: []
        },
        TTS: {
          base: 'http://localhost:8123', relay: '', api: '', model: '', mode: 'stream'
        }
      },
      ensure(id, type) {
        let o = LS.get(this.key(id), null);
        if (!o || o.type !== type) {
          o = { id, type, config: { ...this.defaultsByType[type] } };
          this.saveObj(id, o);
        }
        return o;
      },
      load(id) { return LS.get(this.key(id), null) },
      saveObj(id, obj) { LS.set(this.key(id), obj) },
      saveCfg(id, type, cfg) { this.saveObj(id, { id, type, config: cfg }) },
      update(id, patch) {
        const cur = this.load(id) || this.ensure(id, patch.type);
        const cfg = { ...(cur.config || {}), ...patch };
        this.saveCfg(id, cur.type, cfg);
        return cfg;
      },
      erase(id) { LS.del(this.key(id)) },
      setRelay(id, type, relay) {
        const cur = this.ensure(id, type);
        const cfg = { ...(cur.config || {}), relay: relay };
        this.saveCfg(id, type, cfg);
        return cfg;
      }
    };

    /* ============================================================
       Sentence Mux (per request instance)
       ============================================================ */
    function createSentenceMux(stableMs = 250) {
      let carry = '', pending = '', timer = null;
      const SENT_RE = /([\s\S]*?)(?:([.!?;:](?:["')\]]+)*)\s+|(\n{2,}|\r?\n[-*•]\s+)|((?:\p{Extended_Pictographic}|\p{Emoji_Presentation})+\s+))/u;
      function arm(emit) { clear(); timer = setTimeout(() => { if (pending) { emit(pending); pending = '' } }, stableMs) }
      function clear() { if (timer) { clearTimeout(timer); timer = null } }
      return {
        push(delta, emit) {
          if (!delta) return;
          carry += delta;
          const produced = [];
          let guard = 0;
          while (guard++ < 1000) {
            const m = SENT_RE.exec(carry); if (!m) break;
            const head = (m[1] || '').trim();
            const punc = (m[2] || '').trim();
            const bullet = (m[3] || '').trim();
            const emoji = (m[4] || '').trim();
            const boundary = punc || bullet || emoji;
            if (!boundary) break;
            const sentence = (head + (punc ? punc : ''))?.trim();
            const cut = m.index + (m[0] || '').length;
            carry = carry.slice(cut);
            if (sentence) produced.push(sentence);
          }
          if (produced.length) {
            if (pending) emit(pending);
            for (let i = 0; i < produced.length - 1; i++) emit(produced[i]);
            pending = produced[produced.length - 1];
            arm(emit);
            return;
          }
          if (pending && /\S/.test(carry)) { emit(pending); pending = ''; clear(); return }
          if (pending) arm(emit);
        },
        flush(emit) {
          clear();
          if (pending) { emit(pending); pending = '' }
          const tail = carry.trim(); if (tail) emit(tail); carry = ''
        }
      }
    }

    /* ============================================================
       LLM (node‑scoped)
       ============================================================ */
    const EOT_TOKENS = ["<|eot_id|>", "</s>"];
    const stripEOT = (s) => { let out = s || ''; for (const t of EOT_TOKENS) { if (t) out = out.split(t).join('') } return out };

    function makeNdjsonPump(onLine) {
      const dec = new TextDecoder('utf-8');
      let buf = '', inStr = false, esc = false, depth = 0;
      function feed(text) {
        buf += text; let start = 0;
        for (let i = 0; i < buf.length; i++) {
          const ch = buf[i];
          if (inStr) { if (esc) { esc = false; continue } if (ch === '\\') { esc = true; continue } if (ch === '"') { inStr = false; continue } continue }
          if (ch === '"') { inStr = true; continue }
          if (ch === '{') { depth++; continue }
          if (ch === '}') {
            depth--;
            if (depth === 0) {
              let ln = buf.slice(start, i + 1).trim();
              if (ln.startsWith('data:')) ln = ln.slice(5).trim();
              if (ln && ln !== '[DONE]') onLine(ln);
              start = i + 1;
            }
            continue
          }
          if (ch === '\n') {
            const line = buf.slice(start, i).trim();
            if (line === '[DONE]' || line === 'data: [DONE]') start = i + 1;
          }
        }
        buf = buf.slice(start);
      }
      return {
        push(chunk) {
          const s = (chunk instanceof Uint8Array || chunk instanceof ArrayBuffer) ? dec.decode(chunk, { stream: true }) : String(chunk);
          feed(s);
        },
        flush() {
          const tail = buf.trim();
          if (tail && depth === 0) { let ln = tail; if (ln.startsWith('data:')) ln = ln.slice(5).trim(); if (ln && ln !== '[DONE]') onLine(ln) }
          buf = ''; inStr = false; esc = false; depth = 0;
        }
      }
    }

    const LLM = {
      async onPrompt(nodeId, payload) {
        const node = Graph.getNode(nodeId); if (!node) return;
        const rec = NodeStore.ensure(nodeId, 'LLM'); const cfg = rec.config || {};
        const base = (cfg.base || '').trim(), api = (cfg.api || '').trim(), relay = (cfg.relay || '').trim(), model = (cfg.model || '').trim();
        const viaNkn = (CFG.transport === 'nkn');
        const stream = !!cfg.stream;
        const sysUse = !!cfg.useSystem;
        const sysTxt = (cfg.system || '').trim();
        const memOn = !!cfg.memoryOn;
        const persist = !!cfg.persistMemory;
        const maxTurns = Number.isFinite(cfg.maxTurns) ? cfg.maxTurns : 16;

        const text = String(payload && (payload.text ?? payload.prompt ?? payload) || '');
        const memory = Array.isArray(cfg.memory) ? cfg.memory.slice() : [];

        function buildMessages(latest) {
          const msgs = []; let iStart = 0;
          if (sysUse && sysTxt) msgs.push({ role: 'system', content: sysTxt });
          if (memOn) {
            if (memory.length && memory[0].role === 'system') {
              if (!msgs.length) msgs.push(memory[0]);
              iStart = 1;
            }
            for (let i = iStart; i < memory.length; i++) msgs.push(memory[i]);
          }
          if (latest?.trim()) msgs.push({ role: 'user', content: latest.trim() });
          if (memOn) {
            let userCount = msgs.filter(m => m.role === 'user').length;
            while (userCount > maxTurns) {
              const si = (msgs[0]?.role === 'system') ? 1 : 0;
              const uIdx = msgs.findIndex((m, i) => i >= si && m.role === 'user');
              if (uIdx < 0) break;
              msgs.splice(uIdx, 1);
              if (msgs[uIdx]?.role === 'assistant') msgs.splice(uIdx, 1);
              userCount--;
            }
          }
          return msgs;
        }

        const messages = buildMessages(text);
        const mux = createSentenceMux(250); // unchanged: sentence segmentation for TTS
        let full = '';

        // ---- NEW: tiny helper to stream to the LLM node UI -----------------
        const outEl = node.el?.querySelector('[data-llm-out]');
        let uiLines = [];   // committed (sentence-complete) lines
        let uiBuf = '';   // in-flight chunk buffer
        const setOut = (txt) => {
          if (!outEl) return;
          outEl.textContent = txt || '';
          outEl.scrollTop = outEl.scrollHeight;
        };
        // clear the window for this prompt
        setOut(''); uiLines = []; uiBuf = '';
        // --------------------------------------------------------------------

        // emitters (unchanged routing, now sentence-sized)
        const emitSentenceFinal = (s) => { Router.sendFrom(nodeId, 'final', { nodeId, text: s, eos: true }); };
        const emitSentenceDelta = (s) => { Router.sendFrom(nodeId, 'delta', { nodeId, type: 'text', text: s, eos: true }); };
        const emitBoth = (s) => {
          emitSentenceDelta(s);
          emitSentenceFinal(s);
          // also commit a line to the node UI on sentence boundary
          const line = String(s || '').trim();
          if (line) {
            uiLines.push(line);
            uiBuf = '';
            setOut(uiLines.join('\n'));
          }
        };

        try {
          if (stream) {
            const pump = makeNdjsonPump((ln) => {
              try {
                const obj = JSON.parse(ln);
                let delta =
                  (obj.message && typeof obj.message.content === 'string' && obj.message.content) ||
                  (typeof obj.response === 'string' && obj.response) ||
                  (typeof obj.delta === 'string' && obj.delta) || '';
                if (!delta && (obj.done || obj.complete) && typeof obj.final === 'string') delta = obj.final;
                if (!delta && (obj.done || obj.complete) && obj.message && typeof obj.message.content === 'string') delta = obj.message.content;

                if (delta) {
                  const clean = stripEOT(delta);
                  full += clean;

                  // show live tokens/words in the UI
                  uiBuf += clean;
                  // display committed sentences + the in-flight buffer
                  setOut(uiLines.length ? (uiLines.join('\n') + '\n' + uiBuf) : uiBuf);

                  // but only SEND sentences downstream to TTS
                  mux.push(clean, emitBoth);
                }
              } catch { }
            });

            if (viaNkn) {
              let expected = null; const stash = new Map(); const seen = new Set();
              const flushReorder = () => { while (expected != null && stash.has(expected)) { pump.push(stash.get(expected) + '\n'); stash.delete(expected); expected++ } };
              await Net.nknStream({
                url: base.replace(/\/+$/, '') + '/api/chat', method: 'POST',
                headers: Net.auth({ 'X-Relay-Stream': 'chunks', 'Accept': 'application/x-ndjson' }, api),
                json: { model, messages, stream: true }, timeout_ms: 180000
              }, relay, {
                onBegin: () => { },
                onLine: (line, seqRaw) => {
                  const seq = (seqRaw | 0); if (seen.has(seq)) return; seen.add(seq); if (expected == null) expected = seq;
                  if (seq === expected) { pump.push(line + '\n'); expected++; flushReorder(); } else if (seq > expected) { stash.set(seq, line) }
                },
                onChunk: (u8) => pump.push(u8),
                onEnd: () => { flushReorder(); pump.flush(); mux.flush(emitBoth); }
              }, 180000);
            } else {
              const r = await fetch(base.replace(/\/+$/, '') + '/api/chat', {
                method: 'POST',
                headers: Net.auth({ 'Accept': 'application/x-ndjson', 'Content-Type': 'application/json' }, api),
                body: JSON.stringify({ model, messages, stream: true })
              });
              if (!r.ok || !r.body) throw new Error(`${r.status} ${r.statusText}`);
              const rd = r.body.getReader();
              while (true) { const { value, done } = await rd.read(); if (done) break; if (value && value.byteLength) pump.push(value) }
              pump.flush(); mux.flush(emitBoth);
            }
          } else {
            const data = await Net.postJSON(base, '/api/chat', { model, messages, stream: false }, api, viaNkn, relay, 120000);
            full = stripEOT((data?.message?.content) || (data?.response) || '') || '';
            if (full) {
              // Show entire response and also send sentence-sized (mux will emit once)
              uiLines = [full.trim()]; uiBuf = '';
              setOut(uiLines.join('\n'));
              mux.push(full + '\n', emitBoth);
              mux.flush(emitBoth);
            }
          }

          // memory (unchanged)
          if (cfg.memoryOn) {
            const newMem = (memory || []).slice();
            if (sysUse && sysTxt && !(newMem.length && newMem[0].role === 'system')) {
              newMem.unshift({ role: 'system', content: sysTxt });
            }
            if (text?.trim()) newMem.push({ role: 'user', content: text.trim() });
            const finalText = full.trim();
            if (finalText) newMem.push({ role: 'assistant', content: finalText });
            let pairs = 0; const pruned = [];
            let i = (newMem.length && newMem[0].role === 'system') ? 1 : 0;
            for (let k = newMem.length - 1; k >= i; k--) {
              pruned.push(newMem[k]);
              if (newMem[k].role === 'user') { pairs++; if (pairs >= maxTurns) break; }
            }
            pruned.reverse();
            const out = (newMem[0] && newMem[0].role === 'system') ? [newMem[0], ...pruned] : pruned;
            NodeStore.update(nodeId, { memory: out });
            Router.sendFrom(nodeId, 'memory', { type: 'updated', size: out.length });
          }
        } catch (e) {
          log(`[llm ${nodeId}] ${e.message}`);
        }
      },

      onSystem(nodeId, payload) {
        const s = String(payload && (payload.text ?? payload.prompt ?? payload) || '').trim();
        NodeStore.update(nodeId, { system: s, useSystem: true });
        setBadge(`System prompt set on ${nodeId}`);
      }
    };

    /* ============================================================
       TTS (node-scoped) — streaming waveform + file toggle
       ============================================================ */
    const TTS = {
      _state: new Map(), // nodeId -> { ac, node, an, q:[], queued:0, sr, underruns, audioEl?, canvas?, ctx?, raf?, _resizeObs?, chain }

      ensure(nodeId) {
        let s = this._state.get(nodeId);
        if (s) return s;

        const ac = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 22050 });
        const node = ac.createScriptProcessor(4096, 1, 1);

        // Analyser for waveform
        const an = ac.createAnalyser();
        an.fftSize = 2048;
        an.smoothingTimeConstant = 0.85;

        // Connect ScriptProcessor -> Analyser -> Destination
        node.connect(an);
        an.connect(ac.destination);

        const st = {
          ac, node, an,
          q: [], queued: 0, sr: ac.sampleRate || 22050, underruns: 0,
          canvas: null, ctx: null, raf: null, _resizeObs: null,
          audioEl: null,
          chain: Promise.resolve()
        };

        node.onaudioprocess = (e) => {
          const out = e.outputBuffer.getChannelData(0);
          if (!st.q.length) { out.fill(0); st.underruns++; return }
          let need = out.length, off = 0;
          while (need > 0) {
            if (!st.q.length) { out.fill(0, off); st.underruns++; break }
            const head = st.q[0]; const take = Math.min(need, head.length);
            out.set(head.subarray(0, take), off);
            if (take === head.length) st.q.shift(); else st.q[0] = head.subarray(take);
            st.queued -= take; off += take; need -= take;
          }
        };

        // UI: attach both, but we toggle visibility based on mode
        const box = Graph.getNode(nodeId)?.el?.querySelector('.body');
        if (box) {
          // Waveform canvas (hidden by default; shown in stream mode)
          if (!box.querySelector('[data-tts-vis]')) {
            const cv = document.createElement('canvas');
            cv.dataset.ttsVis = '';                          // marker
            cv.style.cssText = 'margin-top:6px;width:100%;height:56px;background:rgba(0,0,0,.25);border-radius:4px;display:none';
            box.appendChild(cv);
            st.canvas = cv; st.ctx = cv.getContext('2d');
          }
          // File playback audio element (hidden during streaming)
          if (!box.querySelector('audio')) {
            const au = document.createElement('audio');
            au.controls = true; au.style.marginTop = '6px';
            box.appendChild(au); st.audioEl = au;
          } else {
            st.audioEl = box.querySelector('audio');
          }
        }
        try {
          const cfg = NodeStore.ensure(nodeId, 'TTS').config || {};
          if ((cfg.mode || 'stream') === 'stream') this._showStreamUI(st);
          else this._showFileUI(st);
        } catch { /* noop */ }
        this._state.set(nodeId, st);
        return st;
      },

      // visualizer helpers
      _startVis(st) {
        if (!st.canvas || !st.ctx || !st.an || st.raf) return;
        // responsive sizing
        const resize = () => {
          try {
            const b = st.canvas.getBoundingClientRect();
            st.canvas.width = Math.max(150, Math.floor(b.width));
            st.canvas.height = 56;
          } catch { }
        };
        if ('ResizeObserver' in window) {
          st._resizeObs = new ResizeObserver(resize);
          st._resizeObs.observe(st.canvas.parentNode || st.canvas);
        }
        resize();

        const buf = new Uint8Array(st.an.fftSize);
        const draw = () => {
          st.raf = requestAnimationFrame(draw);
          st.an.getByteTimeDomainData(buf);

          const { width: w, height: h } = st.canvas;
          const c = st.ctx;
          c.clearRect(0, 0, w, h);
          c.fillStyle = 'rgba(0,0,0,0.15)';
          c.fillRect(0, 0, w, h);

          c.lineWidth = 2;
          c.strokeStyle = 'rgba(255,255,255,0.9)';
          c.beginPath();

          const step = Math.max(1, Math.floor(buf.length / w));
          for (let x = 0, i = 0; x < w; x++, i += step) {
            const v = buf[i] / 128.0;      // 0..255 -> ~0..2
            const y = (v * 0.5) * h;       // center around midline
            if (x === 0) c.moveTo(x, y);
            else c.lineTo(x, y);
          }
          c.stroke();

          // midline
          c.strokeStyle = 'rgba(255,255,255,0.25)';
          c.lineWidth = 1;
          c.beginPath();
          c.moveTo(0, h / 2);
          c.lineTo(w, h / 2);
          c.stroke();
        };
        draw();
      },
      _stopVis(st) {
        if (st.raf) { cancelAnimationFrame(st.raf); st.raf = null; }
        if (st._resizeObs) { try { st._resizeObs.disconnect(); } catch { } st._resizeObs = null; }
      },
      _showStreamUI(st) {
        if (st.audioEl) st.audioEl.style.display = 'none';
        if (st.canvas) { st.canvas.style.display = 'block'; this._startVis(st); }
      },
      _showFileUI(st) {
        this._stopVis(st);
        if (st.canvas) st.canvas.style.display = 'none';
        if (st.audioEl) st.audioEl.style.display = 'block';
      },

      f32FromI16(int16) {
        const f = new Float32Array(int16.length);
        for (let i = 0; i < int16.length; i++) f[i] = Math.max(-1, Math.min(1, int16[i] / 32768));
        return f;
      },
      resampleLinear(input, fromRate, toRate) {
        if (fromRate === toRate) return input;
        const ratio = toRate / fromRate, L = Math.round(input.length * ratio);
        const out = new Float32Array(L);
        for (let i = 0; i < L; i++) {
          const pos = i / ratio, i0 = Math.floor(pos), i1 = Math.min(i0 + 1, input.length - 1), t = pos - i0;
          out[i] = input[i0] * (1 - t) + input[i1] * t;
        }
        return out;
      },
      enqueue(st, f32) { st.q.push(f32); st.queued += f32.length },

      _sanitize(s) {
        if (!s) return '';
        try { s = s.normalize('NFKC') } catch { }
        s = s.replace(/[\u2019\u2018]/g, "'");
        s = s.replace(/\bhttps?:\/\/\S+/gi, ' ');
        s = s.replace(/[*_~`]+/g, ' ');
        s = s.replace(/\u2026/g, '.').replace(/\.{3,}/g, '.');
        s = s.replace(/[“”"«»‹›„‟]/g, ' ');
        s = s.replace(/[\[\](){}<>]/g, ' ');
        return s.replace(/[^\S\r\n]+/g, ' ').replace(/\s*([.,?!])\s*/g, '$1 ').trim();
      },

      refreshUI(nodeId) {
        const st = this.ensure(nodeId);
        const cfg = NodeStore.ensure(nodeId, 'TTS').config || {};
        if ((cfg.mode || 'stream') === 'stream') {
          this._showStreamUI(st);   // shows canvas + starts visualizer
        } else {
          this._showFileUI(st);     // shows <audio> player
        }
      },

      async onText(nodeId, payload) {
        const node = Graph.getNode(nodeId); if (!node) return;
        const cfg = NodeStore.ensure(nodeId, 'TTS').config || {};
        const base = (cfg.base || '').trim(), api = (cfg.api || '').trim(), relay = (cfg.relay || '').trim(), model = (cfg.model || '').trim();
        const viaNkn = (CFG.transport === 'nkn');
        const mode = cfg.mode || 'stream';

        const raw = (payload && (payload.text || payload)) || '';
        const eos = !!(payload && payload.eos);
        if (!raw) return;

        const st = this.ensure(nodeId);
        const clean = this._sanitize(String(raw));
        if (!clean) return;

        const speakOnce = async () => {
          if (mode === 'stream') {
            await st.ac.resume();
            this._showStreamUI(st);

            // short preroll
            this.enqueue(st, new Float32Array(Math.round((st.sr || 22050) * 0.04)));

            const req = { text: clean, mode: 'stream', format: 'raw', ...(model ? { model, voice: model } : {}) };
            const handleBytes = (u8) => {
              if (!u8 || !u8.length) return;
              const even = (u8.length >> 1) << 1; if (!even) return;
              const body = u8.subarray(0, even);
              const frames = body.length >> 1; const dv = new DataView(body.buffer, body.byteOffset, body.length);
              const i16 = new Int16Array(frames); for (let i = 0; i < frames; i++) i16[i] = dv.getInt16(i * 2, true);
              let f32 = this.f32FromI16(i16); if (st.sr !== 22050) f32 = this.resampleLinear(f32, 22050, st.sr);
              this.enqueue(st, f32);
            };

            try {
              if (viaNkn) {
                let expected = null; const stash = new Map(); const seen = new Set();
                const flush = () => { while (expected != null && stash.has(expected)) { handleBytes(stash.get(expected)); stash.delete(expected); expected++ } };
                await Net.nknStream(
                  { url: base.replace(/\/+$/, '') + '/speak', method: 'POST', headers: Net.auth({ 'X-Relay-Stream': 'chunks' }, api), json: req, timeout_ms: 120000 },
                  relay,
                  {
                    onBegin: () => { },
                    onChunk: (u8, seqRaw) => {
                      const seq = (seqRaw | 0); if (seen.has(seq)) return; seen.add(seq);
                      if (expected == null) expected = seq;
                      if (seq === expected) { handleBytes(u8); expected++; flush() }
                      else if (seq > expected) { stash.set(seq, u8) }
                    },
                    onEnd: () => { flush(); },   // lingered end will call this after late chunks
                    lingerEndMs: 350             // <-- tolerate late-arriving tail packets
                  },
                  120000
                );
              } else {
                const r = await fetch(base.replace(/\/+$/, '') + '/speak', { method: 'POST', headers: Net.auth({}, api), body: JSON.stringify(req) });
                if (!r.ok || !r.body) throw new Error(`${r.status} ${r.statusText}`);
                const rd = r.body.getReader(); let leftover = new Uint8Array(0);
                while (true) {
                  const { value, done } = await rd.read(); if (done) break; if (!value || !value.byteLength) continue;
                  const merged = new Uint8Array(leftover.length + value.length); merged.set(leftover, 0); merged.set(value, leftover.length);
                  const even = (merged.length >> 1) << 1;
                  if (even) { handleBytes(merged.subarray(0, even)); leftover = merged.subarray(even) }
                  else leftover = merged;
                }
              }
            } catch (e) { log(`[tts ${nodeId}] ${e.message}`) }

            // small inter-sentence spacer
            this.enqueue(st, new Float32Array(Math.round((st.sr || 22050) * 0.03)));

          } else {
            // file (ogg) path
            this._showFileUI(st);
            try {
              const data = await Net.postJSON(base, '/speak', { text: clean, mode: 'file', format: 'ogg', ...(model ? { model, voice: model } : {}) }, api, viaNkn, relay, 10 * 60 * 1000);
              let blob = null, mime = 'audio/ogg';
              if (data?.files?.[0]?.url) {
                const fileUrl = base.replace(/\/+$/, '') + data.files[0].url;
                blob = await Net.fetchBlob(fileUrl, viaNkn, relay, api);
                mime = blob.type || mime;
              } else if (data?.audio_b64) {
                const u8 = b64ToBytes(data.audio_b64);
                blob = new Blob([u8], { type: mime });
              } else {
                throw new Error('no audio');
              }
              const url = URL.createObjectURL(blob);
              if (st.audioEl) {
                await new Promise(res => {
                  const onEnd = () => { st.audioEl.removeEventListener('ended', onEnd); res() };
                  st.audioEl.addEventListener('ended', onEnd);
                  st.audioEl.src = url; st.audioEl.play().catch(() => { /* ignore */ });
                });
              }
            } catch (e) { log(`[tts ${nodeId}] ${e.message}`) }
          }
        };

        // Serialize utterances per node to prevent interleaving of frames
        st.chain = st.chain.then(speakOnce).catch(e => log(`[tts ${nodeId}] ${e?.message || e}`));
        return st.chain;
      }
    };



    /* ============================================================
       ASR (node‑scoped mic owner; isolated config usage)
       ============================================================ */
    const ASR = {
      ownerId: null, running: false, ac: null, media: null, source: null, node: null,
      an: null, _vis: new Map(),
      bufF32: new Float32Array(0), out: 0, sid: null, _startingSid: false,
      _rate: 16000, _chunk: 120, _base: '', _api: '', _relay: '', _viaNkn: false, _live: true,
      _sawSpeech: false, finalizing: false, _vadWatch: null, _lastFinal: { text: '', at: 0 },
      _DEDUP_MS: 1500, vad: { ema: 0, state: 'silence', lastVoice: 0, lastSilence: 0 },
      aggr: { prev: '', pend: '', pendStart: 0, lastChange: 0, lastEmit: 0 },
      _uplinkOn: false, _tailDeadline: 0, _preMs: 450, _preMaxSamples: 0, _preSamples: 0, _preChunks: [],
      _sawPartialForUplink: false, _lastPartialAt: 0, _lastPostAt: 0, _ignorePartials: false, _silenceSince: 0,
      _lingerMs: 700, _minTailMs: 350, _forceQuietMaxMs: 2800,

      _nodeEl() { return this.ownerId ? Graph.getNode(this.ownerId)?.el : null },
      _setVU(p) { const w = Math.max(0, Math.min(100, Math.round(p * 150))); const el = this._nodeEl()?.querySelector('.vu > b'); if (el) el.style.width = w + '%' },
      _setPartial(t) { const el = this._nodeEl()?.querySelector('[data-asr-partial]'); if (el) el.textContent = t || '' },
      _setFinal(t) { const el = this._nodeEl()?.querySelector('[data-asr-final]'); if (!el) return; el.textContent = (el.textContent ? el.textContent + '\n' : '') + t; el.scrollTop = el.scrollHeight },

      pushF32(f32) { const a = this.bufF32, b = f32; const out = new Float32Array(a.length + b.length); out.set(a, 0); out.set(b, a.length); this.bufF32 = out },
      drainF32(n) { const a = this.bufF32; const take = Math.min(a.length, n); const head = a.subarray(0, take); this.bufF32 = a.subarray(take).slice(0); return head },
      resample(f, fr, tr) { if (fr === tr) return f.slice(0); const r = tr / fr, L = Math.round(f.length * r), o = new Float32Array(L); for (let i = 0; i < L; i++) { const pos = i / r, i0 = Math.floor(pos), i1 = Math.min(i0 + 1, f.length - 1), t = pos - i0; o[i] = f[i0] * (1 - t) + f[i1] * t } return o },
      i16(f32) { const o = new Int16Array(f32.length); for (let i = 0; i < f32.length; i++) { const v = Math.max(-1, Math.min(1, f32[i])); o[i] = v < 0 ? v * 0x8000 : v * 0x7FFF } return new Uint8Array(o.buffer) },

      _preInit(rate) { this._preMaxSamples = Math.max(1, Math.round(rate * (this._preMs / 1000))); this._preSamples = 0; this._preChunks = [] },
      _prePush(f32) { this._preChunks.push(f32); this._preSamples += f32.length; while (this._preSamples > this._preMaxSamples && this._preChunks.length) { const drop = this._preChunks.shift(); this._preSamples -= drop.length } },
      _preFlush() { for (const ch of this._preChunks) this.pushF32(ch); this._preChunks = []; this._preSamples = 0 },

      _openUplink(now, tailMs, current) { if (this._uplinkOn) return; this._uplinkOn = true; this._sawPartialForUplink = false; this._lastPartialAt = 0; this._ignorePartials = false; this._tailDeadline = now + tailMs; this._preFlush(); if (current) this.pushF32(current) },
      _extendTail(now, tailMs) { this._tailDeadline = now + tailMs },
      _closeUplinkAndMaybeFinalize() { if (!this._uplinkOn) return; this._uplinkOn = false; this._ignorePartials = true; this._drainAndEnd().catch(e => log('[asr] finalize(gate) ' + (e?.message || e))) },
      _startVis(nodeId) {
        const n = Graph.getNode(nodeId);
        const cv = n?.el?.querySelector('[data-asr-vis]');
        if (!cv) return;
        const ctx = cv.getContext('2d');
        const st = { canvas: cv, ctx, raf: null, ro: null };
        const resize = () => {
          try {
            const b = cv.getBoundingClientRect();
            cv.width = Math.max(150, Math.floor(b.width));
            cv.height = 56;
          } catch { }
        };
        if ('ResizeObserver' in window) {
          st.ro = new ResizeObserver(resize);
          st.ro.observe(cv.parentNode || cv);
        }
        resize();

        const draw = () => {
          st.raf = requestAnimationFrame(draw);
          const { width: w, height: h } = cv;

          // background
          ctx.clearRect(0, 0, w, h);
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(0, 0, w, h);

          // midline
          ctx.strokeStyle = 'rgba(255,255,255,0.25)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(0, h / 2);
          ctx.lineTo(w, h / 2);
          ctx.stroke();

          // if no analyser yet, stay idle
          if (!ASR.an) return;

          // waveform
          const buf = new Uint8Array(ASR.an.fftSize || 2048);
          ASR.an.getByteTimeDomainData(buf);
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'rgba(255,255,255,0.9)';
          ctx.beginPath();
          const step = Math.max(1, Math.floor(buf.length / w));
          for (let x = 0, i = 0; x < w; x++, i += step) {
            const v = buf[i] / 128.0;     // 0..255 -> ~0..2
            const y = (v * 0.5) * h;      // center around midline
            if (x === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        };

        draw();
        this._vis.set(nodeId, st);
      },

      _stopVis(nodeId) {
        const st = this._vis.get(nodeId);
        if (!st) return;
        if (st.raf) { cancelAnimationFrame(st.raf); st.raf = null; }
        if (st.ro) { try { st.ro.disconnect(); } catch { } st.ro = null; }
        this._vis.delete(nodeId);
      },

      resetAggr() { this.aggr.prev = ''; this.aggr.pend = ''; this.aggr.pendStart = 0; this.aggr.lastChange = 0 },
      handlePartialForPhrases(text, cfg) {
        if (!cfg.phraseOn) return;
        const minW = cfg.phraseMin | 0 || 3; const stableMs = cfg.phraseStable | 0 || 350;
        const prev = this.aggr.prev || '';
        if (!text.startsWith(prev)) { this.aggr.prev = text; this.aggr.pend = ''; this.aggr.pendStart = performance.now(); this.aggr.lastChange = this.aggr.pendStart; return }
        const added = text.slice(prev.length); const now = performance.now();
        if (added.length > 0) { if (!this.aggr.pend) this.aggr.pendStart = now; this.aggr.pend += added; this.aggr.prev = text; this.aggr.lastChange = now }
        else {
          const words = (this.aggr.pend.trim().match(/\S+/g) || []).length;
          const punct = /[.!?;:,]$/.test(this.aggr.pend.trim());
          if (this.aggr.pend && words >= minW && (punct || (now - this.aggr.lastChange) >= stableMs)) {
            const phrase = this.aggr.pend.trim();
            this._routePhrase(phrase);
            this.aggr.pend = ''; this.aggr.pendStart = 0; this.aggr.lastChange = now;
          }
        }
      },
      handleFinalFlush(text) { if (this.aggr.pend) { this._routePhrase(this.aggr.pend.trim()); this.aggr.pend = '' } else if (text.startsWith(this.aggr.prev || '')) { const extra = text.slice((this.aggr.prev || '').length).trim(); if (extra) this._routePhrase(extra) } this.aggr.prev = text },
      _routePartial(t) { if (this.ownerId) Router.sendFrom(this.ownerId, 'partial', { type: 'text', text: t || '' }) },
      _routePhrase(t) { if (!t) return; if (this.ownerId) Router.sendFrom(this.ownerId, 'phrase', { type: 'text', text: t }) },
      _routeFinal(s) { if (!s) return; if (this.ownerId) Router.sendFrom(this.ownerId, 'final', { type: 'text', text: s, eos: true }) },

      printPartial(t, cfg) { this._setPartial(t || ''); this._routePartial(t || ''); this.handlePartialForPhrases(t || '', cfg) },
      appendFinal(t) {
        const s = (t || '').trim().replace(/\s+/g, ' '); if (!s) return;
        const now = performance.now(); if (s === this._lastFinal.text && (now - this._lastFinal.at) <= this._DEDUP_MS) return;
        this._lastFinal.text = s; this._lastFinal.at = now; this._setFinal(s); this._routeFinal(s)
      },

      shouldDropAsHallucination(text, meta) {
        if (!SIGNOFF_RE.test(text)) return false;
        const words = (text.match(/\S+/g) || []).length;
        const shortGeneric = words <= 7;
        const weSawNoSpeech = !this._sawSpeech;
        const inSilenceNow = this.vad?.state === 'silence';
        const noSpeechProb = (meta && typeof meta.no_speech_prob === 'number') ? meta.no_speech_prob : null;
        const lowConf = (noSpeechProb !== null && noSpeechProb > 0.6) ||
          (meta && typeof meta.avg_logprob === 'number' && meta.avg_logprob < -1.0) ||
          (meta && typeof meta.compression_ratio === 'number' && meta.compression_ratio > 2.4);
        return shortGeneric && (weSawNoSpeech || inSilenceNow || lowConf);
      },

      async _ensureLiveSession(cfg) {
        if (!this._live || this.sid || this._startingSid || !this.running) return;
        this._startingSid = true;
        try {
          const prompt = (cfg.prompt || '').trim();
          const mode = cfg.mode || 'fast';
          const preview_model = (cfg.prevModel || '').trim();
          const preview_window_s = cfg.prevWin ? Number(cfg.prevWin) : undefined;
          const preview_step_s = cfg.prevStep ? Number(cfg.prevStep) : undefined;
          const model = (cfg.model || '').trim();
          const body = {
            ...(prompt ? { prompt } : {}), mode,
            ...(preview_model ? { preview_model } : {}),
            ...(Number.isFinite(preview_window_s) ? { preview_window_s } : {}),
            ...(Number.isFinite(preview_step_s) ? { preview_step_s } : {}),
            temperature: 0.0, condition_on_previous_text: false, no_speech_threshold: 0.6, logprob_threshold: -1.0,
            ...(model ? { model } : {})
          };
          const data = await Net.postJSON(this._base, '/recognize/stream/start', body, this._api, this._viaNkn, this._relay, 45000);
          this.sid = (data && (data.sid || data.id || data.session)) || null;
          if (!this.sid) throw new Error('no sid');
          const sid = this.sid;
          this.openEvents(sid, this._viaNkn, this._base, this._relay, this._api, cfg).catch(() => { });
          this.flushLoop(this._rate, this._chunk, this._viaNkn, this._base, this._relay, this._api).catch(() => { });
        } catch (e) { log('[asr] start(lazy) ' + (e?.message || e)) }
        finally { this._startingSid = false }
      },

      async _drainAndEnd() {
        if (this.finalizing || !this.sid) return;
        this.finalizing = true;
        const oldSid = this.sid; this._ignorePartials = true;
        const softDeadline = performance.now() + Math.max(900, this._lingerMs + 600);
        while (performance.now() < softDeadline) {
          const now = performance.now();
          const postQuiet = (now - this._lastPostAt) >= this._lingerMs;
          const partialQuiet = (!this._sawPartialForUplink) || (now - this._lastPartialAt) >= this._lingerMs;
          const hardQuiet = (now - Math.max(this._lastPostAt, this._lastPartialAt || 0)) >= this._forceQuietMaxMs;
          if ((postQuiet && partialQuiet && this.out === 0 && this.bufF32.length === 0) || hardQuiet) break;
          await new Promise(r => setTimeout(r, 12));
        }
        try {
          const resp = await Net.postJSON(this._base, `/recognize/stream/${encodeURIComponent(oldSid)}/end`, {}, this._api, this._viaNkn, this._relay, 20000);
          const finalText = resp?.final?.text || resp?.final?.result?.text || resp?.text || resp?.result?.text || '';
          if (finalText) { this.handleFinalFlush(finalText); this.appendFinal(finalText) }
        } catch (e) { log('[asr] finalize-live ' + (e?.message || e)) }
        finally { this.sid = null; this.finalizing = false; }
      },

      async start(nodeId) {
        if (this.running && this.ownerId === nodeId) { setBadge('ASR already running'); return }
        // if another node owns the mic — stop it first
        if (this.running && this.ownerId && this.ownerId !== nodeId) { await this.stop() }

        const rec = NodeStore.ensure(nodeId, 'ASR'); const cfg = rec.config || {};
        this.ownerId = nodeId; this._rate = cfg.rate | 0 || 16000; this._chunk = cfg.chunk | 0 || 120; this._live = !!cfg.live;
        this._viaNkn = (CFG.transport === 'nkn'); this._base = cfg.base || ''; this._relay = cfg.relay || ''; this._api = cfg.api || '';
        this._sawSpeech = false; this.finalizing = false; this._uplinkOn = false; this._tailDeadline = 0; this._sawPartialForUplink = false; this._lastPartialAt = 0; this._lastPostAt = 0; this._ignorePartials = false; this._silenceSince = 0;
        this._preInit(this._rate); this._lastFinal = { text: '', at: 0 }; this.resetAggr();

        try {
          this.ac = new (window.AudioContext || window.webkitAudioContext)();
          this.media = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }, video: false });
          this.source = this.ac.createMediaStreamSource(this.media);
          this.node = (this.ac.createScriptProcessor ? this.ac.createScriptProcessor(2048, 1, 1) : new ScriptProcessorNode(this.ac, { bufferSize: 2048, numberOfInputs: 1, numberOfOutputs: 1 }));
          // analyser for live waveform
          this.an = this.ac.createAnalyser();
          this.an.fftSize = 2048;
          this.an.smoothingTimeConstant = 0.85;
          // fork the mic stream to analyser (parallel to script processor)
          this.source.connect(this.an);
          const from = this.ac.sampleRate | 0 || this._rate;
          const bufDurMs = (this.node.bufferSize / from) * 1000;
          const emaMs = cfg.emaMs | 0 || 120;
          const alpha = 1 - Math.exp(-bufDurMs / Math.max(emaMs, 1));
          const rmsTh = parseFloat(cfg.rms) || 0.015;
          const holdMs = cfg.hold | 0 || 250;
          const silence = cfg.silence | 0 || 900;
          const tailBaseMs = Math.max(this._minTailMs, silence);

          let batchQuietSince = null;
          const vuEl = this._nodeEl()?.querySelector('.vu > b');
          if (vuEl) vuEl.style.width = '0%';

          this.vad.ema = 0; this.vad.state = 'silence'; this.vad.lastVoice = 0; this.vad.lastSilence = performance.now();

          this.node.onaudioprocess = (e) => {
            const ch = e.inputBuffer.getChannelData(0);
            let sum = 0; for (let i = 0; i < ch.length; i++) sum += ch[i] * ch[i];
            const rmsCur = Math.sqrt(sum / ch.length);
            this.vad.ema = (1 - alpha) * this.vad.ema + alpha * rmsCur;
            const ema = this.vad.ema;
            const onTh = rmsTh, offTh = rmsTh * 0.7;
            const now = performance.now();
            const tailMs = tailBaseMs;

            const f32 = (from === this._rate) ? ch.slice(0) : this.resample(ch, from, this._rate);
            this._prePush(f32);

            if (this.vad.state === 'silence') {
              if (ema >= onTh) {
                this.vad.state = 'voice'; this.vad.lastVoice = now; this._sawSpeech = true; this._ignorePartials = false;
                this._ensureLiveSession(cfg).then(() => { if (this.sid) this._openUplink(now, tailMs, f32) });
              } else if (this._uplinkOn) {
                if (now > this._tailDeadline) {
                  const postQuiet = (now - this._lastPostAt) >= this._lingerMs;
                  const partialQuiet = (!this._sawPartialForUplink) || ((now - this._lastPartialAt) >= this._lingerMs);
                  const hardQuiet = (now - Math.max(this._lastPostAt, this._lastPartialAt || 0)) >= this._forceQuietMaxMs;
                  if ((postQuiet && partialQuiet) || hardQuiet) this._closeUplinkAndMaybeFinalize();
                }
              }
            } else { // voice
              if (ema >= offTh) { this.vad.lastVoice = now; if (this._uplinkOn) { this._extendTail(now, tailMs); this.pushF32(f32) } }
              else {
                const sinceVoice = now - (this.vad.lastVoice || now);
                if (sinceVoice >= holdMs) { this.vad.state = 'silence'; this.vad.lastSilence = now; this._silenceSince = now; this._ignorePartials = true; if (this.aggr.pend) { this._routePhrase(this.aggr.pend.trim()); this.aggr.pend = '' } }
                else { if (this._uplinkOn) this.pushF32(f32) }
              }
            }

            // UI VU
            this._setVU(ema);

            // batch: finalize after long silence
            if (!this._live) {
              if (ema < offTh) { batchQuietSince = batchQuietSince ?? now; if (now - batchQuietSince >= silence) { batchQuietSince = null; this.finalizeOnce(this._rate).catch(() => { }) } }
              else batchQuietSince = null;
            }
          };

          this.source.connect(this.node);
          this.node.connect(this.ac.destination);
          this._startVis(nodeId);
          clearInterval(this._vadWatch);
          if (this._live) {
            this._vadWatch = setInterval(() => {
              if (!this.sid || this.finalizing || !this._uplinkOn) return;
              const now = performance.now();
              if (this.vad.state !== 'silence') return;
              if (now <= this._tailDeadline) return;
              const postQuiet = (now - this._lastPostAt) >= this._lingerMs;
              const partialQuiet = (!this._sawPartialForUplink) || ((now - this._lastPartialAt) >= this._lingerMs);
              const hardQuiet = (now - Math.max(this._lastPostAt, this._lastPartialAt || 0)) >= this._forceQuietMaxMs;
              if ((postQuiet && partialQuiet) || hardQuiet) this._closeUplinkAndMaybeFinalize();
            }, Math.max(50, Math.min(200, this._chunk)));
          }
        } catch (e) {
          log('[asr] ' + e.message);
          return;
        }

        // node UI reset
        this._setPartial(''); const ff = this._nodeEl()?.querySelector('[data-asr-final]'); if (ff) ff.textContent = '';
        this.running = true;
      },

      async stop() {
        if (!this.running) return;
        this.running = false;
        const visId = this.ownerId;
        try { if (this.sid) await Net.postJSON(this._base, `/recognize/stream/${encodeURIComponent(this.sid)}/end`, {}, this._api, this._viaNkn, this._relay, 20000) } catch { }
        this.sid = null; this._uplinkOn = false;
        try { this.node && this.node.disconnect() } catch { }; try { this.source && this.source.disconnect() } catch { };
        try { this.media && this.media.getTracks().forEach(t => t.stop()) } catch { }; try { this.ac && this.ac.close() } catch { };
        this.an = null;
        this.node = this.source = this.media = this.ac = null;
        clearInterval(this._vadWatch); this._vadWatch = null;
        this.bufF32 = new Float32Array(0); this._preInit(this._rate || 16000);
        // stop waveform drawing
        if (visId) this._stopVis(visId);
        this._setVU(0);
        this.ownerId = null;
      },

      async finalizeOnce(rate) {
        if (!this.bufF32.length) return;
        const pcm = this.bufF32; const b = new ArrayBuffer(44 + pcm.length * 2); const v = new DataView(b); let o = 0;
        const W4 = s => { for (let i = 0; i < 4; i++) v.setUint8(o++, s.charCodeAt(i)) }; const U32 = n => { v.setUint32(o, n, true); o += 4 }; const U16 = n => { v.setUint16(o, n, true); o += 2 };
        const sr = rate, bps = 16, ch = 1, ba = ch * bps / 8, br = sr * ba;
        W4('RIFF'); U32(36 + pcm.length * 2); W4('WAVE'); W4('fmt '); U32(16); U16(1); U16(1); U32(sr); U32(br); U16(ba); U16(bps); W4('data'); U32(pcm.length * 2);
        for (let i = 0; i < pcm.length; i++) v.setInt16(44 + i * 2, Math.max(-1, Math.min(1, pcm[i])) < 0 ? pcm[i] * 0x8000 : pcm[i] * 0x7FFF, true);
        const b64 = btoa(String.fromCharCode(...new Uint8Array(b))); this.bufF32 = new Float32Array(0);
        try {
          const cfg = NodeStore.ensure(this.ownerId, 'ASR').config || {};
          const prompt = (cfg.prompt || '').trim();
          const body = Object.assign({ body_b64: b64, format: 'wav', sample_rate: rate }, prompt ? { prompt } : {});
          const data = await Net.postJSON(this._base, '/recognize', body, this._api, this._viaNkn, this._relay, 120000);
          const txt = (data && (data.text || data.transcript)) || ''; if (txt) this.appendFinal(txt);
        } catch (e) { log('[asr] finalize ' + e.message) }
      },

      async openEvents(sid, viaNkn, base, relay, api, cfg) {
        const pump = (function () {
          let buf = ''; return (u8) => {
            buf += td.decode(u8, { stream: true }); let i;
            while ((i = buf.indexOf('\n\n')) >= 0) {
              const chunk = buf.slice(0, i); buf = buf.slice(i + 2);
              let ev = null, data = ''; for (const line of chunk.split(/\r?\n/)) { if (!line) continue; if (line.startsWith(':')) continue; if (line.startsWith('event:')) ev = line.slice(6).trim(); else if (line.startsWith('data:')) data += (data ? '\n' : '') + line.slice(5).trim() }
              if (data) {
                try {
                  const obj = JSON.parse(data); const t = (obj.type || obj.event || '').toLowerCase();
                  if (t === 'asr.partial' || t === 'partial') {
                    const text = obj.text || (obj.result && obj.result.text) || '';
                    const sameSid = (sid === ASR.sid); const ok = sameSid && !ASR.finalizing && ASR._uplinkOn && ASR.vad.state === 'voice' && !ASR._ignorePartials;
                    if (ok) {
                      ASR.printPartial(text, cfg);
                      if (text) { ASR._sawSpeech = true; ASR._lastPartialAt = performance.now(); ASR._sawPartialForUplink = true }
                    }
                  } else if (t === 'asr.detected' || t === 'detected') {
                    const s = obj.text || (obj.result && obj.result.text) || ''; if (s) { const meta = obj.result || obj; if (!ASR.shouldDropAsHallucination(s, meta)) ASR._routePhrase(s) }
                  } else if (t === 'asr.final' || t === 'final') {
                    const s = (obj.result && obj.result.text) || obj.text || ''; const meta = obj.result || obj;
                    if (s) {
                      if (ASR.shouldDropAsHallucination(s, meta)) { log('[asr] dropped probable sign-off: "' + s + '"') }
                      else { ASR._ignorePartials = true; ASR.appendFinal(s); ASR.handleFinalFlush(s) }
                    }
                  }
                } catch { }
              }
            }
          }
        })();

        if (viaNkn) {
          await Net.nknStream(
            { url: base.replace(/\/+$/, '') + `/recognize/stream/${encodeURIComponent(sid)}/events`, method: 'GET', headers: Net.auth({ 'X-Relay-Stream': 'chunks' }, api), timeout_ms: 10 * 60 * 1000 },
            relay,
            { onBegin: () => { }, onChunk: (u8) => pump(u8), onEnd: () => { } }
          );
        } else {
          const r = await fetch(base.replace(/\/+$/, '') + `/recognize/stream/${encodeURIComponent(sid)}/events`, { headers: Net.auth({}, api) });
          if (!r.ok || !r.body) return;
          const reader = r.body.getReader();
          while (true) { const { value, done } = await reader.read(); if (done) break; if (value && value.byteLength) pump(value) }
        }
      },

      async flushLoop(rate, chunk, viaNkn, base, relay, api) {
        const need = () => Math.round(rate * (chunk / 1000));
        while (this.running && this.sid) {
          if (this.bufF32.length >= need() && this.out < 4 && this._uplinkOn) {
            const f32 = this.drainF32(need()); const bytes = this.i16(f32);
            const url = base.replace(/\/+$/, '') + `/recognize/stream/${encodeURIComponent(this.sid)}/audio?format=pcm16&sr=${rate}`;
            this.out++;
            try {
              this._lastPostAt = performance.now();
              if (viaNkn) {
                await Net.nknSend({ url, method: 'POST', headers: Net.auth({ 'Content-Type': 'application/octet-stream' }, api), body_b64: btoa(String.fromCharCode(...bytes)), timeout_ms: 20000 }, relay, 20000);
              } else {
                const r = await fetch(url, { method: 'POST', headers: Net.auth({ 'Content-Type': 'application/octet-stream' }, api), body: bytes });
                if (!r.ok) throw new Error(r.status + ' ' + r.statusText);
              }
              this._lastPostAt = performance.now();
            } catch (e) { log('[asr] audio send ' + (e && e.message || e)) }
            finally { this.out-- }
          }
          await new Promise(r => setTimeout(r, Math.max(10, chunk / 2)));
        }
      }
    };

    /* ============================================================
       Graph Editor (nodes, wires, dynamic settings)
       ============================================================ */
    const Graph = (() => {
      const WS = { el: null, svg: null, svgLayer: null, root: null, canvas: null, nodes: new Map(), wires: [], portSel: null, drag: null, view: { x: 0, y: 0, scale: 1 }, _redrawReq: false }; // NEW: pan/zoom + rAF + g-layer

      function applyViewTransform() {
        const t = `translate(${WS.view.x}px, ${WS.view.y}px) scale(${WS.view.scale})`;
        if (WS.canvas) { WS.canvas.style.transform = t; }
        if (WS.svgLayer) { WS.svgLayer.setAttribute('transform', `translate(${WS.view.x},${WS.view.y}) scale(${WS.view.scale})`); }
      }
      function ensureSvgLayer() {
        if (!WS.svg) return;
        let g = WS.svg.querySelector('g[data-links]');
        if (!g) {
          g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          g.setAttribute('data-links', '');
          WS.svg.appendChild(g);
        }
        WS.svgLayer = g;
        // keep the layer in lockstep with the viewport transform
        applyViewTransform();
      }

      function requestRedraw() {
        if (WS._redrawReq) return;
        WS._redrawReq = true;
        requestAnimationFrame(() => { WS._redrawReq = false; drawAllLinks(); });
      }

      // Convert client (screen) -> workspace coords (pre-transform)
      function clientToWorkspace(cx, cy) {
        const rr = WS.root?.getBoundingClientRect?.() || document.body.getBoundingClientRect();
        return { x: (cx - rr.left - WS.view.x) / WS.view.scale, y: (cy - rr.top - WS.view.y) / WS.view.scale };
      }

      const TYPES = {
        ASR: {
          title: 'ASR',
          inputs: [],
          outputs: [{ name: 'partial' }, { name: 'phrase' }, { name: 'final' }],
          schema: [
            { key: 'base', label: 'Base URL', type: 'text', placeholder: 'http://localhost:8126' },
            { key: 'relay', label: 'NKN Relay', type: 'text' },
            { key: 'api', label: 'API Key', type: 'text' },
            { key: 'model', label: 'Model', type: 'select', options: [] },
            { key: 'mode', label: 'ASR Mode', type: 'select', options: ['fast', 'accurate'], def: 'fast' },
            { key: 'rate', label: 'Rate (Hz)', type: 'number', def: 16000 },
            { key: 'chunk', label: 'Chunk (ms)', type: 'number', def: 120 },
            { key: 'live', label: 'Live', type: 'select', options: ['true', 'false'], def: 'true' },
            { key: 'rms', label: 'VAD Thresh', type: 'number', step: '0.001', def: 0.015 },
            { key: 'hold', label: 'VAD Hangover (ms)', type: 'number', def: 250 },
            { key: 'emaMs', label: 'EMA Window (ms)', type: 'number', def: 120 },
            { key: 'phraseOn', label: 'Phrase Stream', type: 'select', options: ['true', 'false'], def: 'true' },
            { key: 'phraseMin', label: 'Min Words', type: 'number', def: 3 },
            { key: 'phraseStable', label: 'Stable (ms)', type: 'number', def: 350 },
            { key: 'silence', label: 'Silence End (ms)', type: 'number', def: 900 },
            { key: 'prevWin', label: 'Preview Window (s)', type: 'text', placeholder: '(server default)' },
            { key: 'prevStep', label: 'Preview Step (s)', type: 'text', placeholder: '(server default)' },
            { key: 'prevModel', label: 'Preview Model', type: 'select', options: [] },
            { key: 'prompt', label: 'Prompt', type: 'textarea', placeholder: 'Bias decoding, names, spellings…' }
          ]
        },
        LLM: {
          title: 'LLM',
          inputs: [{ name: 'prompt' }, { name: 'system' }],
          outputs: [{ name: 'delta' }, { name: 'final' }, { name: 'memory' }],
          schema: [
            { key: 'base', label: 'Base URL', type: 'text', placeholder: 'http://127.0.0.1:11434' },
            { key: 'relay', label: 'NKN Relay', type: 'text' },
            { key: 'api', label: 'API Key', type: 'text' },
            { key: 'model', label: 'Model', type: 'select', options: [] },
            { key: 'stream', label: 'Stream', type: 'select', options: ['true', 'false'], def: 'true' },
            { key: 'useSystem', label: 'Use System Message', type: 'select', options: ['false', 'true'], def: 'false' },
            { key: 'system', label: 'System Prompt', type: 'textarea' },
            { key: 'memoryOn', label: 'Use Chat Memory', type: 'select', options: ['false', 'true'], def: 'false' },
            { key: 'persistMemory', label: 'Persist Memory', type: 'select', options: ['false', 'true'], def: 'false' },
            { key: 'maxTurns', label: 'Max Turns', type: 'number', def: 16 }
          ]
        },
        TTS: {
          title: 'TTS',
          inputs: [{ name: 'text' }],
          outputs: [],
          schema: [
            { key: 'base', label: 'Base URL', type: 'text', placeholder: 'http://localhost:8123' },
            { key: 'relay', label: 'NKN Relay', type: 'text' },
            { key: 'api', label: 'API Key', type: 'text' },
            { key: 'model', label: 'Voice/Model', type: 'select', options: [] },
            { key: 'mode', label: 'Mode', type: 'select', options: ['stream', 'file'], def: 'stream' }
          ]
        }
      };

      const uid = () => ('n' + Math.random().toString(36).slice(2, 8));

      function refreshNodeTransport(nodeId) {
        const node = WS.nodes.get(nodeId);
        if (!node) return;
        const btn = node.el?.querySelector('.node-transport');
        if (!btn) return;
        const rec = NodeStore.ensure(node.id, node.type);
        const relay = (rec.config?.relay || '').trim();
        btn.innerHTML = '';
        btn.classList.remove('active');
        const dot = document.createElement('span');
        dot.className = 'dot';
        const label = document.createElement('span');
        label.className = 'label';
        label.textContent = 'NKN';
        if (relay) {
          btn.classList.add('active');
          if (CFG.transport === 'nkn' && Net?.nkn?.ready && Net.nkn.addr) dot.classList.add('ok');
          else if (CFG.transport === 'nkn') dot.classList.add('warn');
          else dot.classList.add('warn');
          btn.title = relay;
        } else {
          dot.classList.add('err');
          btn.title = 'Scan a relay QR code';
        }
        btn.append(dot, label);
      }

      function refreshAllNodeTransport() {
        WS.nodes.forEach((n) => refreshNodeTransport(n.id));
      }

      function makeNodeEl(node) {
        const t = TYPES[node.type];
        const el = document.createElement('div');
        el.className = 'node';
        el.style.left = (node.x || 60) + 'px'; el.style.top = (node.y || 60) + 'px';
        if (node.w) el.style.width = node.w + 'px';
        if (node.h) el.style.height = node.h + 'px';
        el.dataset.id = node.id;

        el.innerHTML = `
      <div class="head">
        <div class="titleRow"><div class="title">${t.title}</div><button type="button" class="node-transport">NKN</button></div>
        <div class="row" style="gap:6px;">
          <button class="gear" title="Settings">⚙</button>
          ${node.type === 'ASR' ? `<button class="gear asrPlay" title="Start/Stop">▶</button>` : ''}
          <button class="gear" title="Remove">🗑</button>
        </div>
      </div>
    <div class="body">
      <div class="ports">
        <div class="side left"></div>
        <div class="side right"></div>
      </div>

      ${node.type === 'ASR' ? `
        <canvas data-asr-vis
          style="margin-top:6px;width:100%;height:56px;background:rgba(0,0,0,.25);border-radius:4px"></canvas>
        <div class="muted" style="margin-top:6px;">Partial</div>
        <div class="bubble" data-asr-partial style="min-height:28px"></div>
        <div class="muted" style="margin-top:6px;">Finals</div>
        <div class="code" data-asr-final style="min-height:60px;max-height:120px"></div>
      `: ''}

      ${node.type === 'LLM' ? `
        <div class="muted" style="margin-top:6px;">Output</div>
        <div class="code" data-llm-out
            style="min-height:60px;max-height:120px;overflow:auto;white-space:pre-wrap"></div>
      `: ''}

      ${node.type === 'TTS' ? `` : ''}
    </div>
    `;

        const transportBtn = el.querySelector('.node-transport');
        if (transportBtn) {
          transportBtn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            const rec = NodeStore.ensure(node.id, node.type);
            const relay = (rec.config?.relay || '').trim();
            if (relay) {
              NodeStore.setRelay(node.id, node.type, '');
              refreshNodeTransport(node.id);
              saveGraph();
              updateTransportButton();
              setBadge('Switched to HTTP');
            } else {
              openQrScanner(null, (txt) => {
                if (!txt) return;
                NodeStore.setRelay(node.id, node.type, txt.trim());
                refreshNodeTransport(node.id);
                saveGraph();
                updateTransportButton();
                setBadge('NKN relay saved');
              });
            }
          });
          refreshNodeTransport(node.id);
        }

        // ---- resize handle (bottom-right) -----------------------------------------
        const rh = document.createElement('div');
        rh.setAttribute('data-resize', '');
        rh.title = 'Resize';
        rh.style.cssText = [
          'position:absolute',
          'right:4px',
          'bottom:4px',
          'width:12px',
          'height:12px',
          'border-bottom-right-radius:10px',
          'cursor:se-resize',
          // simple L-shaped corner
          'border-right:2px solid rgba(255,255,255,0.6)',
          'border-bottom:2px solid rgba(255,255,255,0.6)',
          'box-sizing:border-box',
          'z-index:2'
        ].join(';');
        el.appendChild(rh);

        let rs = null;
        rh.addEventListener('pointerdown', (e) => {
          e.stopPropagation();
          const r = el.getBoundingClientRect();
          rs = {
            id: e.pointerId,
            startX: e.clientX,
            startY: e.clientY,
            startW: r.width,
            startH: r.height
          };
          rh.setPointerCapture(e.pointerId);
          document.body.style.cursor = 'se-resize';
        });

        rh.addEventListener('pointermove', (e) => {
          if (!rs) return;
          const dx = e.clientX - rs.startX;
          const dy = e.clientY - rs.startY;
          const minW = 180, minH = 120; // sensible minimums
          const w = Math.max(minW, Math.round(rs.startW + dx));
          const h = Math.max(minH, Math.round(rs.startH + dy));
          el.style.width = w + 'px';
          el.style.height = h + 'px';
          node.w = w; node.h = h;       // persist on next save
          requestRedraw();               // keep links glued to ports while resizing
        });

        const endResize = () => {
          if (!rs) return;
          rs = null;
          document.body.style.cursor = '';
          saveGraph();                   // commit new w/h
        };
        rh.addEventListener('pointerup', endResize);
        rh.addEventListener('pointercancel', endResize);
        // --------------------------------------------------------------------------

        // Ports
        const left = el.querySelector('.side.left'); const right = el.querySelector('.side.right');

        for (const p of (t.inputs || [])) {
          const r = document.createElement('div');
          r.className = 'wp-port in'; r.dataset.port = p.name; r.title = `${p.name} (Alt-click to disconnect)`;
          r.innerHTML = `<span class="dot"></span><span>${p.name}</span>`;
          r.addEventListener('click', (ev) => { if (ev.altKey || ev.metaKey || ev.ctrlKey) { removeWiresAt(node.id, 'in', p.name); return } onPortClick(node.id, 'in', p.name, r) });

          // NEW: drag from INPUT (newFromInput) or retarget an existing wire at this input
          r.addEventListener('pointerdown', (ev) => {
            if (ev.pointerType === 'touch') ev.preventDefault();
            const wires = connectedWires(node.id, 'in', p.name);
            if (wires.length) {
              // Retarget wire: drag the input end ("to")
              const w = wires[wires.length - 1];
              w.path?.setAttribute('stroke-dasharray', '6 4');
              const move = (e) => {
                if (e.pointerType === 'touch') e.preventDefault();
                if (WS.drag) WS.drag.lastClient = { x: e.clientX, y: e.clientY };
                const pt = clientToWorkspace(e.clientX, e.clientY);
                drawRetarget(w, 'to', pt.x, pt.y);
                if (WS.drag) updateDropHover(WS.drag.expected);
              };
              const up = (e) => { setDropHover(null); finishAnyDrag(e.clientX, e.clientY); };
              WS.drag = {
                kind: 'retarget',
                wireId: w.id,
                grabSide: 'to',
                path: w.path,
                pointerId: ev.pointerId,
                expected: 'out',
                lastClient: { x: ev.clientX, y: ev.clientY },
                _cleanup: () => window.removeEventListener('pointermove', move)
              };
              window.addEventListener('pointermove', move, { passive: false });
              window.addEventListener('pointerup', up, { once: true, passive: false });
              updateDropHover('out');
              return;
            }
            // Start a new temp from INPUT -> must drop on an OUTPUT
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', 'rgba(255,255,255,.6)');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('stroke-linecap', 'round');
            path.setAttribute('opacity', '0.9');
            path.setAttribute('stroke-dasharray', '6 4');
            path.setAttribute('vector-effect', 'non-scaling-stroke');
            path.setAttribute('pointer-events', 'none');
            WS.svgLayer.appendChild(path);

            const move = (e) => {
              if (e.pointerType === 'touch') e.preventDefault();
              if (WS.drag) WS.drag.lastClient = { x: e.clientX, y: e.clientY };
              const pt = clientToWorkspace(e.clientX, e.clientY);
              drawTempFromPort({ nodeId: node.id, side: 'in', portName: p.name }, pt.x, pt.y);
              updateDropHover(WS.drag?.expected);
            };
            const up = (e) => { setDropHover(null); finishAnyDrag(e.clientX, e.clientY); };
            WS.drag = {
              kind: 'newFromInput',
              toNodeId: node.id,
              toPort: p.name,
              path,
              pointerId: ev.pointerId,
              expected: 'out',
              lastClient: { x: ev.clientX, y: ev.clientY },
              _cleanup: () => window.removeEventListener('pointermove', move)
            };
            window.addEventListener('pointermove', move, { passive: false });
            window.addEventListener('pointerup', up, { once: true, passive: false });
            const pt = clientToWorkspace(ev.clientX, ev.clientY);
            drawTempFromPort({ nodeId: node.id, side: 'in', portName: p.name }, pt.x, pt.y);
            updateDropHover('out');
          });

          left.appendChild(r);
          Router.register(`${node.id}:in:${p.name}`, r, (payload) => {
            if (node.type === 'LLM') {
              if (p.name === 'prompt') return LLM.onPrompt(node.id, payload);
              if (p.name === 'system') return LLM.onSystem(node.id, payload);
            } else if (node.type === 'TTS') {
              if (p.name === 'text') return TTS.onText(node.id, payload);
            }
          });
        }

        for (const p of (t.outputs || [])) {
          const r = document.createElement('div');
          r.className = 'wp-port out'; r.dataset.port = p.name; r.title = `${p.name} (Alt-click to disconnect)`;
          r.innerHTML = `<span>${p.name}</span><span class="dot"></span>`;
          r.addEventListener('click', (ev) => { if (ev.altKey || ev.metaKey || ev.ctrlKey) { removeWiresAt(node.id, 'out', p.name); return } onPortClick(node.id, 'out', p.name, r) });

          // NEW: drag from OUTPUT (new) or retarget existing wire(s) at this output
          r.addEventListener('pointerdown', (ev) => {
            if (ev.pointerType === 'touch') ev.preventDefault();
            const wires = connectedWires(node.id, 'out', p.name);
            if (wires.length) {
              // Retarget: drag the output end ("from")
              const w = wires[wires.length - 1];
              w.path?.setAttribute('stroke-dasharray', '6 4');
              const move = (e) => {
                if (e.pointerType === 'touch') e.preventDefault();
                if (WS.drag) WS.drag.lastClient = { x: e.clientX, y: e.clientY };
                const pt = clientToWorkspace(e.clientX, e.clientY);
                drawRetarget(w, 'from', pt.x, pt.y);
                if (WS.drag) updateDropHover(WS.drag.expected);
              };
              const up = (e) => { setDropHover(null); finishAnyDrag(e.clientX, e.clientY); };
              WS.drag = {
                kind: 'retarget',
                wireId: w.id,
                grabSide: 'from',
                path: w.path,
                pointerId: ev.pointerId,
                expected: 'in',
                lastClient: { x: ev.clientX, y: ev.clientY },
                _cleanup: () => window.removeEventListener('pointermove', move)
              };
              window.addEventListener('pointermove', move, { passive: false });
              window.addEventListener('pointerup', up, { once: true, passive: false });
              updateDropHover('in');
              return;
            }
            // Start a new temp from OUTPUT -> must drop on an INPUT
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', 'rgba(255,255,255,.6)');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('stroke-linecap', 'round');
            path.setAttribute('opacity', '0.9');
            path.setAttribute('stroke-dasharray', '6 4');
            path.setAttribute('vector-effect', 'non-scaling-stroke');
            path.setAttribute('pointer-events', 'none');
            WS.svgLayer.appendChild(path);

            const move = (e) => {
              if (e.pointerType === 'touch') e.preventDefault();
              if (WS.drag) WS.drag.lastClient = { x: e.clientX, y: e.clientY };
              const pt = clientToWorkspace(e.clientX, e.clientY);
              drawTempFromPort({ nodeId: node.id, side: 'out', portName: p.name }, pt.x, pt.y);
              updateDropHover(WS.drag?.expected);
            };
            const up = (e) => { setDropHover(null); finishAnyDrag(e.clientX, e.clientY); };
            WS.drag = {
              kind: 'new',
              fromNodeId: node.id,
              fromPort: p.name,
              path,
              pointerId: ev.pointerId,
              expected: 'in',
              lastClient: { x: ev.clientX, y: ev.clientY },
              _cleanup: () => window.removeEventListener('pointermove', move)
            };
            window.addEventListener('pointermove', move, { passive: false });
            window.addEventListener('pointerup', up, { once: true, passive: false });
            const pt = clientToWorkspace(ev.clientX, ev.clientY);
            drawTempFromPort({ nodeId: node.id, side: 'out', portName: p.name }, pt.x, pt.y);
            updateDropHover('in');
          });

          right.appendChild(r);
        }

        // dragging nodes
        const head = el.querySelector('.head'); let drag = null;
        head.addEventListener('pointerdown', (e) => {
          if (e.target.closest('button')) return;
          const p0 = clientToWorkspace(e.clientX, e.clientY);
          drag = { dx: p0.x - (node.x || 0), dy: p0.y - (node.y || 0) };
          head.setPointerCapture(e.pointerId);
        });
        head.addEventListener('pointermove', (e) => {
          if (!drag) return;
          const p = clientToWorkspace(e.clientX, e.clientY);
          const gx = Math.round((p.x - drag.dx) / 14) * 14;
          const gy = Math.round((p.y - drag.dy) / 14) * 14;
          el.style.left = gx + 'px'; el.style.top = gy + 'px';
          node.x = gx; node.y = gy;
          requestRedraw();
        });
        head.addEventListener('pointerup', () => { drag = null; saveGraph() });

        // buttons
        const [btnGear, btnASR, btnDel] =
          node.type === 'ASR' ? el.querySelectorAll('.gear') : (() => { const a = el.querySelectorAll('.gear'); return [a[0], null, a[1]] })();
        btnGear.addEventListener('click', () => openSettings(node.id));
        if (btnASR) {
          const glyph = () => { btnASR.textContent = (ASR.running && ASR.ownerId === node.id) ? '■' : '▶' };
          glyph();
          btnASR.addEventListener('click', async () => {
            if (ASR.running && ASR.ownerId === node.id) { await ASR.stop() }
            else { await ASR.start(node.id) }
            setTimeout(glyph, 0);
          });
        }
        btnDel.addEventListener('click', () => removeNode(node.id));
        if ('ResizeObserver' in window) {
          const ro = new ResizeObserver(() => requestRedraw());
          ro.observe(el);
          node._ro = ro;
        }

        return el;
      }

      // wire helpers
      function onPortClick(nodeId, side, portName, el) {
        if (!WS.portSel) {
          if (side !== 'out') { setBadge('Pick an output first', false); return }
          WS.portSel = { nodeId, side, portName, el }; el.classList.add('sel'); return;
        }
        if (side !== 'in') { setBadge('Connect to an input port', false); return }
        if (nodeId === WS.portSel.nodeId) { setBadge('Cannot self-link', false); return }
        addLink(WS.portSel.nodeId, WS.portSel.portName, nodeId, portName);
        WS.portSel.el.classList.remove('sel'); WS.portSel = null;
      }

      // NEW: utility to find wires attached to a port
      function connectedWires(nodeId, side, portName) {
        return WS.wires.filter(w =>
          (side === 'out' && w.from.node === nodeId && w.from.port === portName) ||
          (side === 'in' && w.to.node === nodeId && w.to.port === portName)
        );
      }

      function addLink(fromNodeId, fromPort, toNodeId, toPort) {
        if (WS.wires.find(w => w.from.node === fromNodeId && w.from.port === fromPort && w.to.node === toNodeId && w.to.port === toPort)) return;
        const w = { id: uid(), from: { node: fromNodeId, port: fromPort }, to: { node: toNodeId, port: toPort }, path: null };
        WS.wires.push(w);
        const p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        p.setAttribute('fill', 'none');
        p.setAttribute('stroke', 'rgba(255,255,255,.7)');
        p.setAttribute('stroke-width', '2');
        p.setAttribute('stroke-linecap', 'round');
        p.setAttribute('opacity', '0.95');
        p.setAttribute('vector-effect', 'non-scaling-stroke');
        p.dataset.id = w.id;

        const kill = (e) => { removeWireById(w.id); e.stopPropagation() };
        p.addEventListener('click', (e) => { if (e.altKey || e.metaKey || e.ctrlKey) kill(e) });
        p.addEventListener('dblclick', kill);
        WS.svgLayer.appendChild(p); w.path = p;


        const fk = `${fromNodeId}:out:${fromPort}`; const tk = `${toNodeId}:in:${toPort}`;
        if (!Router.wires.find(x => x.from === fk && x.to === tk)) { Router.wires.push({ from: fk, to: tk }); CFG.wires = Router.wires.slice(); saveCFG(); Router.render(); log(`wired ${fk} → ${tk}`) }

        requestRedraw(); saveGraph();
      }

      // NEW: temp/retarget visuals + drag lifecycle
      let dropHoverEl = null;
      function setDropHover(el) {
        if (dropHoverEl === el) return;
        if (dropHoverEl) dropHoverEl.classList.remove('drop-hover');
        dropHoverEl = el;
        if (dropHoverEl) dropHoverEl.classList.add('drop-hover');
      }
      function updateDropHover(expected) {
        if (!WS.drag || !WS.drag.lastClient || !expected) { setDropHover(null); return; }
        const el = document.elementFromPoint(WS.drag.lastClient.x, WS.drag.lastClient.y);
        const selector = expected === 'in' ? '.wp-port.in' : '.wp-port.out';
        const target = el && el.closest?.(selector);
        setDropHover(target || null);
      }

      function clearTempLink() {
        if (WS.drag?.kind && WS.drag.path) {
          if (WS.drag.kind === 'retarget') WS.drag.path.setAttribute('stroke-dasharray', '');
          else WS.drag.path.remove();
        }
        WS.drag = null;
        setDropHover(null);
      }

      function drawTempFromPort(from, mx, my) {
        if (!WS.drag?.path) return;
        const a = portCenter(from.nodeId, from.side, from.portName);
        const b = { x: mx, y: my };
        const dx = Math.max(40, Math.abs(b.x - a.x) * 0.5);
        WS.drag.path.setAttribute('d', `M ${a.x},${a.y} C ${a.x + dx},${a.y} ${b.x - dx},${b.y} ${b.x},${b.y}`);
        if (WS.drag?.expected) updateDropHover(WS.drag.expected);
      }
      function drawRetarget(wire, grabSide, mx, my) {
        if (!wire?.path) return;
        const a = (grabSide === 'from') ? { x: mx, y: my } : portCenter(wire.from.node, 'out', wire.from.port);
        const b = (grabSide === 'to') ? { x: mx, y: my } : portCenter(wire.to.node, 'in', wire.to.port);
        const dx = Math.max(40, Math.abs(b.x - a.x) * 0.5);
        wire.path.setAttribute('d', `M ${a.x},${a.y} C ${a.x + dx},${a.y} ${b.x - dx},${b.y} ${b.x},${b.y}`);
        if (WS.drag?.expected) updateDropHover(WS.drag.expected);
      }
      function finishAnyDrag(cx, cy) {
        try { WS.drag?._cleanup && WS.drag._cleanup() } catch { }
        const el = document.elementFromPoint(cx, cy);
        setDropHover(null);

        // new from OUTPUT -> drop on INPUT
        if (WS.drag?.kind === 'new') {
          const target = el && (el.closest?.('.wp-port.in'));
          if (target) {
            const toNode = target.closest('.node')?.dataset?.id;
            const toPort = target.dataset.port;
            if (toNode && toPort && toNode !== WS.drag.fromNodeId) addLink(WS.drag.fromNodeId, WS.drag.fromPort, toNode, toPort);
            else setBadge('Invalid drop target', false);
          }
          clearTempLink(); return;
        }

        // new from INPUT -> drop on OUTPUT
        if (WS.drag?.kind === 'newFromInput') {
          const target = el && (el.closest?.('.wp-port.out'));
          if (target) {
            const fromNode = target.closest('.node')?.dataset?.id;
            const fromPort = target.dataset.port;
            if (fromNode && fromPort && fromNode !== WS.drag.toNodeId) addLink(fromNode, fromPort, WS.drag.toNodeId, WS.drag.toPort);
            else setBadge('Invalid drop target', false);
          }
          clearTempLink(); return;
        }

        // retarget existing wire
        if (WS.drag?.kind === 'retarget') {
          const wire = WS.wires.find(w => w.id === WS.drag.wireId);
          if (!wire) { clearTempLink(); return }
          const need = (WS.drag.grabSide === 'from') ? '.wp-port.in' : '.wp-port.out';
          const target = el && (el.closest?.(need));
          wire.path?.setAttribute('stroke-dasharray', '');

          if (!target) { // drop to nowhere -> delete
            removeWireById(wire.id);
            clearTempLink(); return;
          }

          const hitNodeId = target.closest('.node')?.dataset?.id;
          const hitPort = target.dataset?.port;
          if (!hitNodeId || !hitPort) { clearTempLink(); return }

          if (WS.drag.grabSide === 'from') {
            // moved output end -> must drop on input
            if (!target.classList.contains('in')) { setBadge('Drop on an input port', false); clearTempLink(); requestRedraw(); return }
            if (hitNodeId === wire.from.node) { setBadge('Cannot self-link', false); clearTempLink(); requestRedraw(); return }
            wire.to = { node: hitNodeId, port: hitPort };
          } else {
            // moved input end -> must drop on output
            if (!target.classList.contains('out')) { setBadge('Drop on an output port', false); clearTempLink(); requestRedraw(); return }
            if (hitNodeId === wire.to.node) { setBadge('Cannot self-link', false); clearTempLink(); requestRedraw(); return }
            wire.from = { node: hitNodeId, port: hitPort };
          }

          syncRouterFromWS(); saveGraph(); requestRedraw(); clearTempLink(); setBadge('Wire reconnected');
          return;
        }

        clearTempLink();
      }

      function portCenter(nodeId, side, portName) {
        const n = WS.nodes.get(nodeId); if (!n) return { x: 0, y: 0 };
        const dot = n.el.querySelector(`.wp-port.${side}[data-port="${CSS.escape(portName)}"] .dot`);
        if (!dot) return { x: 0, y: 0 };
        const dr = dot.getBoundingClientRect();
        const cx = dr.left + dr.width / 2;
        const cy = dr.top + dr.height / 2;
        return clientToWorkspace(cx, cy);
      }

      function drawLink(w) {
        const a = portCenter(w.from.node, 'out', w.from.port); const b = portCenter(w.to.node, 'in', w.to.port);
        const dx = Math.max(40, Math.abs(b.x - a.x) * 0.5);
        const d = `M ${a.x},${a.y} C ${a.x + dx},${a.y} ${b.x - dx},${b.y} ${b.x},${b.y}`;
        w.path.setAttribute('d', d);
      }
      function drawAllLinks() { for (const w of WS.wires) drawLink(w) }

      function removeWireById(id) {
        const w = WS.wires.find(x => x.id === id); if (!w) return;
        w.path?.remove(); WS.wires = WS.wires.filter(x => x !== w); syncRouterFromWS(); saveGraph(); requestRedraw(); setBadge('Wire removed');
      }
      function removeWiresAt(nodeId, side, portName) {
        const rm = WS.wires.filter(w => (side === 'out' && w.from.node === nodeId && w.from.port === portName) || (side === 'in' && w.to.node === nodeId && w.to.port === portName));
        rm.forEach(w => w.path?.remove());
        WS.wires = WS.wires.filter(w => !rm.includes(w));
        syncRouterFromWS(); saveGraph(); requestRedraw();
      }
      function syncRouterFromWS() {
        const newWires = WS.wires.map(w => ({ from: `${w.from.node}:out:${w.from.port}`, to: `${w.to.node}:in:${w.to.port}` }));
        Router.wires = newWires; CFG.wires = newWires.slice(); saveCFG(); Router.render();
      }

      // persistence
      function saveGraph() {
        const data = {
          nodes: Array.from(WS.nodes.values()).map(n => ({
            id: n.id,
            type: n.type,
            x: n.x,
            y: n.y,
            w: Math.round(n.el?.offsetWidth || n.w || 0),
            h: Math.round(n.el?.offsetHeight || n.h || 0)
          })),
          links: WS.wires.map(w => ({ from: w.from, to: w.to })),
          nodeConfigs: {}
        };
        for (const n of WS.nodes.values()) { const rec = NodeStore.load(n.id); if (rec) data.nodeConfigs[n.id] = rec }
        LS.set('graph.workspace', data);
      }
      function loadGraph() {
        const data = LS.get('graph.workspace', null);
        WS.canvas.innerHTML = '';     // was WS.el.innerHTML = '';
        WS.svg.innerHTML = '';
        ensureSvgLayer();
        WS.nodes.clear();
        WS.wires = [];
        if (!data) {
          const a = addNode('ASR', 90, 200);
          const l = addNode('LLM', 380, 180);
          const t = addNode('TTS', 680, 200);
          addLink(a.id, 'final', l.id, 'prompt');
          addLink(l.id, 'final', t.id, 'text');
          requestRedraw();
          saveGraph();
          return;
        }
        if (data.nodeConfigs) { for (const [id, obj] of Object.entries(data.nodeConfigs)) { if (obj && obj.type && obj.config) NodeStore.saveObj(id, obj) } }

        for (const n of (data.nodes || [])) {
          const node = { id: n.id, type: n.type, x: n.x, y: n.y, w: n.w, h: n.h };
          NodeStore.ensure(node.id, node.type);
          node.el = makeNodeEl(node);
          WS.canvas.appendChild(node.el);
          WS.nodes.set(node.id, node);
          if (node.type === 'TTS') requestAnimationFrame(() => TTS.refreshUI(node.id));
        }

        for (const l of (data.links || [])) addLink(l.from.node, l.from.port, l.to.node, l.to.port);
        requestRedraw();
      }
      async function discoverASRModels(base, api, useNkn, relay) {
        const b = (base || '').replace(/\/+$/, '');
        if (!b) return [];
        try {
          // expected: { current: {...}, models:[{name:...}, ...], ok:true }
          const j = await Net.getJSON(b, '/models', api, useNkn, relay);
          const arr = Array.isArray(j?.models) ? j.models : (Array.isArray(j) ? j : []);
          const names = arr
            .map(m => (m && (m.name || m.id || m)) ?? '')
            .filter(Boolean)
            .map(String);
          // keep server order; no need to sort (tiny → large-v3 looks natural)
          return Array.from(new Set(names));
        } catch {
          return [];
        }
      }

      async function discoverLLMModels(base, api, useNkn, relay) {
        const out = [];
        const b = (base || '').replace(/\/+$/, '');
        if (!b) return out;

        // 1) Ollama: GET /api/tags  -> { models:[{name:...}, ...] }
        try {
          const j = await Net.getJSON(b, '/api/tags', api, useNkn, relay);
          if (j && Array.isArray(j.models)) {
            for (const m of j.models) if (m && m.name) out.push(String(m.name));
          }
        } catch { }

        // 2) OpenAI-compatible: GET /v1/models -> { data:[{id:...}, ...] } (or array)
        try {
          const j = await Net.getJSON(b, '/v1/models', api, useNkn, relay);
          const arr = Array.isArray(j?.data) ? j.data : (Array.isArray(j) ? j : []);
          for (const m of arr) if (m && (m.id || m.name)) out.push(String(m.id || m.name));
        } catch { }

        // 3) Other servers: GET /models -> array or {data:[...]}
        try {
          const j = await Net.getJSON(b, '/models', api, useNkn, relay);
          if (Array.isArray(j)) {
            for (const m of j) out.push(String(m.id || m.name || m));
          } else if (Array.isArray(j?.data)) {
            for (const m of j.data) out.push(String(m.id || m.name));
          }
        } catch { }

        // dedupe & sort
        return Array.from(new Set(out.filter(Boolean))).sort((a, b) => a.localeCompare(b));
      }

      async function discoverTTSModels(base, api, useNkn, relay) {
        const b = (base || '').replace(/\/+$/, '');
        if (!b) return [];
        try {
          const j = await Net.getJSON(b, '/models', api, useNkn, relay);
          // expected: { models: [ { name, ... }, ... ] }
          let arr = [];
          if (Array.isArray(j?.models)) arr = j.models;
          else if (Array.isArray(j?.data)) arr = j.data;  // just-in-case variants
          else if (Array.isArray(j)) arr = j;

          const names = arr
            .map(m => (m && (m.name || m.id || m)) ?? '')
            .filter(Boolean)
            .map(String);

          return Array.from(new Set(names)).sort((a, b) => a.localeCompare(b));
        } catch {
          return [];
        }
      }

      // settings modal
      function openSettings(nodeId) {
        const n = WS.nodes.get(nodeId); if (!n) return;
        const rec = NodeStore.ensure(nodeId, n.type); const cfg = rec.config || {};
        const modal = qs('#settingsModal'); const fields = qs('#settingsFields'); const help = qs('#settingsHelp'); const form = qs('#settingsForm');
        fields.innerHTML = '';
        const schema = TYPES[n.type].schema || [];
        for (const f of schema) {
          const lab = document.createElement('label'); lab.textContent = f.label;
          const inp = (f.type === 'textarea') ? document.createElement('textarea') : document.createElement('input');
          if (f.type === 'select') {
            const sel = document.createElement('select');
            sel.name = f.key;

            const curVal = String((cfg[f.key] ?? f.def ?? ''));
            const addOpt = (val, txt = val) => { const opt = document.createElement('option'); opt.value = String(val); opt.textContent = String(txt); sel.appendChild(opt) };

            if ((f.key === 'model' || (n.type === 'ASR' && f.key === 'prevModel')) &&
              (n.type === 'LLM' || n.type === 'TTS' || n.type === 'ASR')) {
              // show a temporary "loading" option
              addOpt('', '— loading models… —');
              sel.value = '';

              // populate from the LLM endpoint
              (async () => {
                try {
                  const viaNkn = (CFG.transport === 'nkn');
                  const list =
                    n.type === 'LLM' ? await discoverLLMModels(cfg.base || '', cfg.api || '', viaNkn, cfg.relay || '') :
                      n.type === 'TTS' ? await discoverTTSModels(cfg.base || '', cfg.api || '', viaNkn, cfg.relay || '') :
                        await discoverASRModels(cfg.base || '', cfg.api || '', viaNkn, cfg.relay || '');

                  // clear and fill
                  sel.innerHTML = '';
                  if (!list.length) addOpt('', '— no models found —');
                  for (const name of list) addOpt(name);
                  // keep saved value if it isn't in the list
                  if (curVal && !list.includes(curVal)) addOpt(curVal, curVal + ' (saved)');
                  sel.value = curVal || (list[0] ?? '');
                } catch (e) {
                  sel.innerHTML = '';
                  if (curVal) addOpt(curVal, curVal + ' (saved)');
                  addOpt('', '— fetch failed —');
                  sel.value = curVal || '';
                }
              })();
            } else {
              for (const o of f.options || []) addOpt(o);
              sel.value = curVal;
            }

            fields.appendChild(lab); fields.appendChild(sel);
          } else {
            if (f.type !== 'textarea') inp.type = f.type || 'text';
            if (f.placeholder) inp.placeholder = f.placeholder;
            inp.name = f.key; inp.value = (cfg[f.key] !== undefined && cfg[f.key] !== null) ? String(cfg[f.key]) : String(f.def ?? '');
            if (f.step) inp.step = f.step;
            let control = inp;
            if (f.key === 'relay') {
              const wrap = document.createElement('div');
              wrap.className = 'input-with-btn';
              wrap.appendChild(inp);
              const btn = document.createElement('button');
              btn.type = 'button';
              btn.className = 'ghost';
              btn.textContent = 'Scan QR';
              btn.addEventListener('click', (e) => { e.preventDefault(); openQrScanner(inp); });
              wrap.appendChild(btn);
              control = wrap;
            }
            fields.appendChild(lab); fields.appendChild(control);
          }

      }
      form.dataset.nodeId = nodeId;
      help.textContent = `${TYPES[n.type].title} • ${nodeId}`;
      modal.classList.remove('hidden'); modal.setAttribute('aria-hidden', 'false');
    }
    function closeSettings() {
      const modal = qs('#settingsModal'); const form = qs('#settingsForm');
      delete form.dataset.nodeId; modal.classList.add('hidden'); modal.setAttribute('aria-hidden', 'true');
      closeQrScanner();
    }
      function bindModal() {
        qs('#closeSettings')?.addEventListener('click', closeSettings);
        qs('#cancelSettings')?.addEventListener('click', closeSettings);
        qs('#closeBackdrop')?.addEventListener('click', closeSettings);
        qs('#saveSettings')?.addEventListener('click', (e) => {
          e.preventDefault();
          const form = qs('#settingsForm'); const nodeId = form.dataset.nodeId;
          if (!nodeId) return;
          const n = WS.nodes.get(nodeId); if (!n) return;
          const fd = new FormData(form); const patch = {};
          for (const [k, v] of fd.entries()) {
            const sch = (TYPES[n.type].schema || []).find(s => s.key === k);
            if (!sch) { patch[k] = String(v); continue }
            if (sch.type === 'number') { const num = Number(String(v).trim()); patch[k] = Number.isFinite(num) ? num : undefined }
            else if (sch.type === 'select') { if (v === 'true' || v === 'false') patch[k] = (v === 'true'); else if (/^\d+$/.test(String(v))) patch[k] = Number(v); else patch[k] = String(v) }
            else patch[k] = String(v);
          }
          if (n.type === 'TTS') {
            TTS.refreshUI(n.id);
          }
          NodeStore.update(nodeId, patch);
          setBadge('Settings saved'); closeSettings();
        });
      }

      // toolbar / boot helpers
      function addNode(type, x = 70, y = 70) {
        const id = uid(); const n = { id, type, x, y }; NodeStore.ensure(id, type); n.el = makeNodeEl(n); WS.canvas.appendChild(n.el); WS.nodes.set(id, n); if (type === 'TTS') requestAnimationFrame(() => TTS.refreshUI(id)); saveGraph(); requestRedraw(); return n;
      }
      function removeNode(nodeId) {
        const n = WS.nodes.get(nodeId); if (!n) return;
        if (n._ro) { try { n._ro.disconnect() } catch { } delete n._ro }
        WS.wires.slice().forEach(w => { if (w.from.node === nodeId || w.to.node === nodeId) { w.path?.remove(); WS.wires = WS.wires.filter(x => x !== w) } });
        n.el.remove(); WS.nodes.delete(nodeId); NodeStore.erase(nodeId);
        syncRouterFromWS(); saveGraph(); requestRedraw();
        if (ASR.ownerId === nodeId) ASR.stop();
      }

      function exportGraph() {
        const data = LS.get('graph.workspace', { nodes: [], links: [], nodeConfigs: {} });
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'realtime-graph.json'; a.click(); URL.revokeObjectURL(url);
      }
      function importGraph() {
        const inp = document.createElement('input'); inp.type = 'file'; inp.accept = 'application/json';
        inp.onchange = () => {
          const f = inp.files?.[0]; if (!f) return;
          f.text().then(t => { const data = JSON.parse(t); LS.set('graph.workspace', data); loadGraph(); setBadge('Graph imported') }).catch(e => setBadge('Import failed: ' + e.message, false));
        }; inp.click();
      }
      function bindToolbar() {
        qs('#addASR')?.addEventListener('click', () => addNode('ASR', 90, 120));
        qs('#addLLM')?.addEventListener('click', () => addNode('LLM', 360, 160));
        qs('#addTTS')?.addEventListener('click', () => addNode('TTS', 650, 200));
        qs('#exportGraph')?.addEventListener('click', exportGraph);
        qs('#importGraph')?.addEventListener('click', importGraph);
      }
      function onResize() { requestRedraw() }

      // NEW: easy cancel of linking/drag
      function cancelLinking() {
        if (WS.portSel?.el) WS.portSel.el.classList.remove('sel');
        WS.portSel = null;
        clearTempLink();
        setBadge('Linking cancelled');
      }
      function bindWorkspaceCancels() {
        window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && (WS.portSel || WS.drag)) cancelLinking() });
        WS.el.addEventListener('pointerdown', (e) => { if (e.target === WS.el && (WS.portSel || WS.drag)) cancelLinking() });
        WS.svg.addEventListener('pointerdown', (e) => { if (e.target === WS.svg && (WS.portSel || WS.drag)) cancelLinking() });
      }
      function clamp(v, min, max) { return Math.max(min, Math.min(max, v)) }

      function zoomAt(clientX, clientY, dz) {
        const rr = WS.root?.getBoundingClientRect?.() || document.body.getBoundingClientRect();
        const mx = clientX - rr.left;
        const my = clientY - rr.top;

        const s0 = WS.view.scale;
        const s1 = clamp(s0 * Math.exp(dz), 0.4, 3.0);
        if (s1 === s0) return;

        const wx = (mx - WS.view.x) / s0;
        const wy = (my - WS.view.y) / s0;

        WS.view.x = mx - wx * s1;
        WS.view.y = my - wy * s1;
        WS.view.scale = s1;

        applyViewTransform();
      }

      function shouldLetElementScroll(e) {
        // Only consider when we're over a node at all
        const node = e.target.closest?.('.node');
        if (!node) return false;

        const dy = e.deltaY || 0;
        const dx = e.deltaX || 0;

        // Walk up from the leaf to the node root looking for scrollable ancestors
        let el = e.target;
        while (el && node.contains(el)) {
          const cs = getComputedStyle(el);

          // Vertical
          if (/(auto|scroll)/.test(cs.overflowY) && el.scrollHeight > el.clientHeight + 1) {
            // Can this element actually consume this delta (not stuck at edges)?
            if ((dy < 0 && el.scrollTop > 0) ||
              (dy > 0 && el.scrollTop + el.clientHeight < el.scrollHeight)) {
              return true;
            }
          }

          // Horizontal (for code panes, etc.)
          if (/(auto|scroll)/.test(cs.overflowX) && el.scrollWidth > el.clientWidth + 1) {
            if ((dx < 0 && el.scrollLeft > 0) ||
              (dx > 0 && el.scrollLeft + el.clientWidth < el.scrollWidth)) {
              return true;
            }
          }

          el = el.parentElement;
        }
        return false;
      }
      function _hasScrollableY(el) {
        const cs = getComputedStyle(el);
        return (cs.overflowY === 'auto' || cs.overflowY === 'scroll') && el.scrollHeight > el.clientHeight;
      }
      function _hasScrollableX(el) {
        const cs = getComputedStyle(el);
        return (cs.overflowX === 'auto' || cs.overflowX === 'scroll') && el.scrollWidth > el.clientWidth;
      }

      /**
       * Walk up from the event target but stop at the node boundary.
       * Return true if some ancestor inside the node could actually consume scroll
       * in the direction of the current wheel delta (both up and down).
       */
      function _nodeCanConsumeWheel(target, dx, dy, rootStop) {
        let cur = target instanceof Element ? target : null;
        while (cur && cur !== rootStop) {
          const isNode = cur.classList?.contains?.('node');

          // Vertical scrollable?
          if (_hasScrollableY(cur)) {
            const top = cur.scrollTop;
            const max = cur.scrollHeight - cur.clientHeight;
            if ((dy < 0 && top > 0) || (dy > 0 && top < max - 1)) return true;
          }
          // Horizontal scrollable? (trackpads / Shift+wheel)
          if (_hasScrollableX(cur)) {
            const left = cur.scrollLeft;
            const maxX = cur.scrollWidth - cur.clientWidth;
            if ((dx < 0 && left > 0) || (dx > 0 && left < maxX - 1)) return true;
          }

          // Stop climbing once we exit the node container; outside the node we use wheel for zoom.
          if (isNode) {
            cur = cur.parentElement; // check the node itself, then break on the next loop
            break;
          }
          cur = cur.parentElement;
        }
        return false;
      }

      function bindViewportControls() {
        let pan = null;
        const touches = new Map();
        let pinch = null;

        const updateTouch = (id, x, y) => {
          if (touches.has(id)) {
            touches.set(id, { x, y });
          }
        };

        const removeTouch = (id) => {
          touches.delete(id);
          if (pinch && !pinch.ids.every(pid => touches.has(pid))) {
            pinch = null;
          }
        };

        const maybeStartPinch = () => {
          if (pinch || touches.size < 2 || WS.drag) return;
          const entries = Array.from(touches.entries()).slice(0, 2);
          if (entries.length < 2) return;
          const [[idA, a], [idB, b]] = entries;
          const dist = Math.max(10, Math.hypot(a.x - b.x, a.y - b.y));
          pinch = { ids: [idA, idB], startDist: dist, startScale: WS.view.scale };
          pan = null;
        };

        const onPanDown = (e) => {
          const hitNode = e.target.closest('.node');
          const hitPort = e.target.closest('.wp-port');
          const hitResize = e.target.closest('[data-resize]');
          const hitWire = e.target.closest('path[data-id]');

          const isBackground =
            !hitNode && !hitPort && !hitResize && !hitWire &&
            (e.target === WS.root || e.target === WS.el || e.target === WS.svg ||
              e.target.closest('#workspace') || e.target.closest('#linksSvg'));

          if (e.pointerType === 'touch') {
            touches.set(e.pointerId, { x: e.clientX, y: e.clientY });
            maybeStartPinch();
            e.preventDefault();
            if (pinch) return;
          }

          if (!isBackground || pinch) return;

          pan = { id: e.pointerId, sx: e.clientX, sy: e.clientY, ox: WS.view.x, oy: WS.view.y, pointerType: e.pointerType };
          if (e.pointerType !== 'touch') (WS.root || WS.el).setPointerCapture?.(e.pointerId);
          if (e.pointerType === 'mouse') document.body.style.cursor = 'grabbing';
        };

        const onPanMove = (e) => {
          if (touches.has(e.pointerId)) {
            updateTouch(e.pointerId, e.clientX, e.clientY);
            if (!pinch) maybeStartPinch();
          }

          if (pinch) {
            const pts = pinch.ids.map(id => touches.get(id)).filter(Boolean);
            if (pts.length < 2) {
              pinch = null;
              return;
            }
            const dist = Math.max(10, Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y));
            const target = clamp(pinch.startScale * (dist / pinch.startDist), 0.4, 3.0);
            const current = WS.view.scale;
            if (target > 0 && Math.abs(target - current) > 1e-3) {
              const dz = Math.log(target / current);
              zoomAt((pts[0].x + pts[1].x) / 2, (pts[0].y + pts[1].y) / 2, dz);
            }
            return;
          }

          if (!pan || pan.id !== e.pointerId) return;
          const dx = e.clientX - pan.sx, dy = e.clientY - pan.sy;
          WS.view.x = pan.ox + dx;
          WS.view.y = pan.oy + dy;
          applyViewTransform();
        };

        const onPanUp = (e) => {
          if (pan && pan.id === e.pointerId) {
            pan = null;
            if (e.pointerType === 'mouse') document.body.style.cursor = '';
          }
          removeTouch(e.pointerId);
        };

        const onPanCancel = (e) => {
          if (pan && pan.id === e.pointerId) {
            pan = null;
            if (e.pointerType === 'mouse') document.body.style.cursor = '';
          }
          removeTouch(e.pointerId);
        };

        const onWheel = (e) => {
          // If we're over a node and that node (or a child) can scroll in the wheel direction,
          // let the browser handle the scroll; do NOT zoom.
          const dx = e.deltaX || 0;
          const dy = e.deltaY || 0;
          const insideScrollableNode = _nodeCanConsumeWheel(e.target, dx, dy, WS.root);

          if (insideScrollableNode) {
            // allow the scroll to happen naturally
            return;
          }

          // Otherwise, use wheel for zooming the canvas
          e.preventDefault();
          const intensity = (e.deltaMode === 1) ? 0.05 : 0.0015; // line vs pixel mode
          const dz = -dy * intensity;
          zoomAt(e.clientX, e.clientY, dz);
        };


        const rootEl = (WS.root || WS.el);
        rootEl.addEventListener('pointerdown', onPanDown, { passive: false });
        rootEl.addEventListener('pointermove', onPanMove, { passive: false });
        rootEl.addEventListener('pointerup', onPanUp, { passive: false });
        rootEl.addEventListener('pointercancel', onPanCancel, { passive: false });
        rootEl.addEventListener('pointerleave', onPanCancel, { passive: false });
        rootEl.addEventListener('wheel', onWheel, { passive: false });
      }
      function init() {
        WS.el = qs('#workspace');
        WS.svg = qs('#linksSvg');
        WS.root = WS.el?.parentElement || document.body;

        // ensure a canvas exists and is full-size inside #workspace
        WS.canvas = qs('#wsCanvas');
        if (!WS.canvas) {
          WS.canvas = document.createElement('div');
          WS.canvas.id = 'wsCanvas';
          WS.el.appendChild(WS.canvas);
        }

        // workspace stays pinned; canvas moves
        WS.root.style.position = 'relative';
        if (WS.svg) {
          WS.svg.style.position = 'absolute';
          WS.svg.style.left = '0'; WS.svg.style.top = '0';
          WS.svg.style.width = '100%'; WS.svg.style.height = '100%';
        }
        ensureSvgLayer();

        bindToolbar(); bindModal(); bindWorkspaceCancels();
        bindViewportControls();
        applyViewTransform();
        loadGraph();
        window.addEventListener('resize', () => { requestRedraw() });
        setTimeout(() => requestRedraw(), 50);
      }





      return { init, addNode, save: saveGraph, load: loadGraph, getNode: (id) => WS.nodes.get(id), refreshTransportButtons: refreshAllNodeTransport };
    })();

    /* ============================================================
       Boot / bindings
       ============================================================ */
    function bindUI() {
      const toggle = qs('#transportToggle');
      if (toggle) {
        toggle.addEventListener('click', () => {
          if (CFG.transport === 'nkn') {
            CFG.transport = 'http';
            try { Net.nkn.client && Net.nkn.client.close() } catch { }
            Net.nkn.client = null;
            Net.nkn.ready = false;
            Net.nkn.addr = '';
            saveCFG();
            updateTransportButton();
            setBadge('HTTP mode');
          } else {
            CFG.transport = 'nkn';
            saveCFG();
            updateTransportButton();
            Net.ensureNkn();
            setBadge('Connecting via NKN…');
          }
        });
      }

      // wires
      updateTransportButton();
    }

    function init() {
      setupQrScanner();
      bindUI();
      Graph.init();
      Router.render();
      if (CFG.transport === 'nkn') Net.ensureNkn();
      setBadge('Ready');
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>

</html>
