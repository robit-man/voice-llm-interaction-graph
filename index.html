<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Realtime Graph — ASR → LLM → TTS (Node‑Isolated)</title>
  <style>
    :root{
      --bg:#0b0f14;--panel:rgba(255,255,255,.07);--panel2:rgba(255,255,255,.05);
      --accent:#66e0ff;--accent2:#a8ff60;--text:#e8f1f8;--muted:#a9b6c3;
      --ok:#7dffb0;--warn:#f9c846;--err:#ff6b6b;--mono:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      --r:16px;--shadow:0 10px 30px rgba(0,0,0,.35), inset 0 0 1px rgba(255,255,255,.12)
    }
    *{box-sizing:border-box}
    body{margin:0;color:var(--text);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    body::after{content:'';position:fixed;inset:0;z-index:-1;background:
      radial-gradient(1200px 800px at 10% -10%,#163147,transparent 60%),
      radial-gradient(900px 600px at 100% 0%,#1b2d18,transparent 55%),
      var(--bg)}
    header{display:flex;justify-content:space-between;align-items:center;padding:18px}
    .brand{display:flex;gap:12px;align-items:center}
    .logo{width:36px;height:36px}
    h1{margin:0;font-size:18px}
    .hint{color:var(--muted);font-size:12px}
    .badge{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.15);background:rgba(255,255,255,.06)}
    .dot{width:10px;height:10px;border-radius:50%}
    .dot.ok{background:var(--ok);box-shadow:0 0 10px var(--ok)}
    .dot.warn{background:var(--warn);box-shadow:0 0 10px var(--warn)}
    .dot.err{background:var(--err);box-shadow:0 0 10px var(--err)}
    main{display:grid;gap:14px;padding:0 18px 24px;grid-template-columns:repeat(12,1fr)}
    .card{grid-column:span 12;background:var(--panel);border:1px solid rgba(255,255,255,.08);border-radius:var(--r);backdrop-filter:blur(8px);padding:14px}
    @media(min-width:980px){.span-4{grid-column:span 4}.span-8{grid-column:span 8}}
    h2{margin:0 0 8px;font-size:15px}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    label{font-size:12px;color:var(--muted);margin-right:6px}
    input,select,textarea{width:100%;background:var(--panel2);color:var(--text);border:1px solid rgba(255,255,255,.15);border-radius:12px;padding:9px 11px;outline:none}
    textarea{min-height:84px;resize:vertical}
    button{background:linear-gradient(180deg,rgba(102,224,255,.9),rgba(102,224,255,.6));color:#001018;border:0;border-radius:12px;padding:9px 12px;font-weight:700;cursor:pointer}
    button.secondary{background:linear-gradient(180deg,rgba(168,255,96,.9),rgba(168,255,96,.6));color:#021204}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,.2);color:var(--text)}
    button.danger{background:linear-gradient(180deg,rgba(255,107,107,.95),rgba(255,107,107,.7));color:#280a0a}
    .code{font-family:var(--mono);font-size:12px;background:#04070b;border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:10px;white-space:pre-wrap;max-height:260px;overflow:auto}
    .bubble{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);padding:10px;border-radius:12px}
    .muted{color:var(--muted);font-size:12px}
    .vu{height:8px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);overflow:hidden}
    .vu>b{display:block;height:100%;width:0%;background:linear-gradient(90deg,#22c55e,#eab308,#ef4444)}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border:1px solid rgba(255,255,255,.18);border-radius:999px;background:rgba(255,255,255,.06);font-family:var(--mono);font-size:12px}
    /* Workspace */
    #workspaceWrap{position:relative;height:520px;border-radius:var(--r);overflow:hidden;border:1px solid rgba(255,255,255,.12);background:
      linear-gradient(var(--panel2),var(--panel2)),
      repeating-linear-gradient(0deg,transparent 0 28px,rgba(255,255,255,.06) 28px 29px),
      repeating-linear-gradient(90deg,transparent 0 28px,rgba(255,255,255,.06) 28px 29px)}
    #workspace{position:absolute;inset:0}
    #linksSvg{position:absolute;inset:0;pointer-events:none}
    /* Node */
    .node{position:absolute;min-width:230px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.18);border-radius:14px;box-shadow:var(--shadow);user-select:none}
    .node .head{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:8px 10px;cursor:grab;background:rgba(0,0,0,.15);border-bottom:1px solid rgba(255,255,255,.12);border-top-left-radius:14px;border-top-right-radius:14px}
    .node .head:active{cursor:grabbing}
    .node .title{font-weight:700;font-size:13px}
    .node .gear{width:24px;height:24px;border-radius:8px;padding:0;line-height:24px;display:inline-flex;align-items:center;justify-content:center;background:transparent;border:1px solid rgba(255,255,255,.25);color:var(--text)}
    .node .gear:hover{background:rgba(255,255,255,.08)}
    .node .body{padding:10px}
    .node .ports{display:flex;justify-content:space-between;gap:10px}
    .node .side{display:flex;flex-direction:column;gap:8px}
    .wp-port{--sz:12px;display:flex;align-items:center;gap:6px;font-family:var(--mono);font-size:12px;cursor:pointer}
    .wp-port .dot{width:var(--sz);height:var(--sz);border-radius:50%;border:2px solid rgba(255,255,255,.8);background:rgba(255,255,255,.15)}
    .wp-port.out .dot{box-shadow:0 0 0 2px rgba(102,224,255,.25)}
    .wp-port.in .dot{box-shadow:0 0 0 2px rgba(168,255,96,.25)}
    .wp-port.sel .dot{background:var(--accent)}
    /* Modal */
    .modal.hidden{display:none}
    .modal{position:fixed;inset:0;z-index:1000}
    .modal-backdrop{position:absolute;inset:0;background:rgba(0,0,0,.5);backdrop-filter:blur(2px)}
    .modal-panel{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:min(880px,calc(100% - 28px));background:var(--panel);border:1px solid rgba(255,255,255,.18);border-radius:16px;padding:14px;max-height:calc(100vh - 80px);overflow:auto}
    .modal-head{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
    .modal-title{font-weight:800;font-size:15px}
    .form-grid{display:grid;grid-template-columns:160px 1fr;gap:8px}
    .help{font-size:11px;color:var(--muted)}
    audio{width:100%;height:32px}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/nkn-sdk@1.3.6/dist/nkn.min.js"></script>
</head>
<body>
<header>
  <div class="brand">
    <div class="logo">
      <svg xmlns="http://www.w3.org/2000/svg" width="2rem" height="2rem" viewBox="0 0 24 24" fill="none">
        <path d="M8 6.5H16M7.70502 8.70919L12.2826 15.3034M4.6 9H6.4C6.96005 9 7.24008 9 7.45399 8.89101C7.64215 8.79513 7.79513 8.64215 7.89101 8.45399C8 8.24008 8 7.96005 8 7.4V5.6C8 5.03995 8 4.75992 7.89101 4.54601C7.79513 4.35785 7.64215 4.20487 7.45399 4.10899C7.24008 4 6.96005 4 6.4 4H4.6C4.03995 4 3.75992 4 3.54601 4.10899C3.35785 4.20487 3.20487 4.35785 3.10899 4.54601C3 4.75992 3 5.03995 3 5.6V7.4C3 7.96005 3 8.24008 3.10899 8.45399C3.20487 8.64215 3.35785 8.79513 3.54601 8.89101C3.75992 9 4.03995 9 4.6 9ZM13.6 20H15.4C15.9601 20 16.2401 20 16.454 19.891C16.6422 19.7951 16.7951 19.6422 16.891 19.454C17 19.2401 17 18.9601 17 18.4V16.6C17 16.0399 17 15.7599 16.891 15.546C16.7951 15.3578 16.6422 15.2049 16.454 15.109C16.2401 15 15.9601 15 15.4 15H13.6C13.0399 15 12.7599 15 12.546 15.109C12.3578 15.2049 12.2049 15.3578 12.109 15.546C12 15.7599 12 16.0399 12 16.6V18.4C12 18.9601 12 19.2401 12.109 19.454C12.2049 19.6422 12.3578 19.7951 12.546 19.891C12.7599 20 13.0399 20 13.6 20ZM17.6 9H19.4C19.9601 9 20.2401 9 20.454 8.89101C20.6422 8.79513 20.7951 8.64215 20.891 8.45399C21 8.24008 21 7.96005 21 7.4V5.6C21 5.03995 21 4.75992 20.891 4.54601C20.7951 4.35785 20.6422 4.20487 20.454 4.10899C20.2401 4 19.9601 4 19.4 4H17.6C17.0399 4 16.7599 4 16.546 4.10899C16.3578 4.20487 16.2049 4.35785 16.109 4.54601C16 4.75992 16 5.03995 16 5.6V7.4C16 7.96005 16 8.24008 16.109 8.45399C16.2049 8.64215 16.3578 8.79513 16.546 8.89101C16.7599 9 17.0399 9 17.6 9Z"
              stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </div>
    <div>
      <h1>Inference Graph Playground</h1>
      <div class="hint">ASR → LLM → TTS · HTTP or NKN Endpoints · Node‑Isolated</div>
    </div>
  </div>
  <div id="status" class="badge"><span class="dot warn"></span><span>Booting…</span></div>
</header>

<main>
  <!-- GLOBAL -->
  <section class="card span-12">
    <h2>Global</h2>
    <div class="row">
      <label>Transport</label>
      <select id="transport">
        <option value="http">HTTP(S)</option>
        <option value="nkn">NKN Relay</option>
      </select>
      <button id="nknConnect">Connect NKN</button>
      <button class="ghost" id="nknDisconnect">Disconnect</button>
      <button class="secondary" id="saveAll">Save</button>
      <span class="muted">NKN: <b id="nknInfo">disconnected</b></span>
    </div>
  </section>

  <!-- GRAPH WORKSPACE -->
  <section class="card span-12" id="graphCard">
    <h2>Graph Workspace</h2>
    <div class="row" style="margin-bottom:10px;">
      <button id="addASR">+ ASR</button>
      <button id="addLLM" class="secondary">+ LLM</button>
      <button id="addTTS" class="ghost">+ TTS</button>
      <button id="exportGraph" class="ghost">Export</button>
      <button id="importGraph" class="ghost">Import</button>
      <span class="muted">Drag nodes, click an output port then an input port to link. Alt/⌥‑click a wire to remove.</span>
    </div>

    <div id="workspaceWrap">
      <svg id="linksSvg" width="100%" height="100%" preserveAspectRatio="none"></svg>
      <div id="workspace"></div>
    </div>
  </section>

  <!-- WIRES -->
  <section class="card span-12">
    <h2>Wires</h2>
    <div class="row">
      <button class="secondary" id="wireToggle">Wire Mode: <b id="wireState">ON</b></button>
      <button class="ghost" id="clearWires">Clear</button>
      <span class="muted">Click source then destination to connect.</span>
    </div>
    <div id="wiresBox" class="code" style="margin-top:8px;min-height:54px"></div>
  </section>

  <!-- LOGS -->
  <section class="card span-12">
    <h2>Status / Logs</h2>
    <div id="logBox" class="code" style="min-height:120px">(logs)</div>
  </section>
</main>

<!-- SETTINGS MODAL (dynamic contents) -->
<div id="settingsModal" class="modal hidden" aria-hidden="true">
  <div class="modal-backdrop"></div>
  <div class="modal-panel">
    <div class="modal-head">
      <div class="modal-title">Node Settings</div>
      <button class="ghost" id="closeSettings">✕</button>
    </div>
    <form id="settingsForm">
      <div id="settingsFields" class="form-grid"></div>
      <div class="help" id="settingsHelp" style="margin-top:6px;">—</div>
      <div class="row" style="margin-top:12px;">
        <button id="saveSettings">Save to Node</button>
        <button class="ghost" id="cancelSettings" type="button">Close</button>
      </div>
    </form>
  </div>
</div>

<script>
/* ============================================================
   Helpers & persistence
   ============================================================ */
const ASR_DEFAULT_PROMPT =
  "Context: live interactive conversation, not a video or broadcast. " +
  "Transcribe exactly what is spoken. Do not add generic media sign-offs. " +
  "Avoid phrases such as: \"thanks for watching\", \"like and subscribe\", " +
  "\"don't forget to subscribe\", \"link in the description\".";

const SIGNOFF_RE = /\b(thanks(?:,)?\s+for\s+(?:watching|listening)|(?:don['’]t\s+forget\s+to\s+)?(?:like|subscribe)|like\s+and\s+subscribe|link\s+in\s+(?:the\s+)?description)\b/i;

const LS = {
  get(k, d){ try{ const v = localStorage.getItem(k); return v ? JSON.parse(v):d } catch { return d } },
  set(k, v){ localStorage.setItem(k, JSON.stringify(v)) },
  del(k){ localStorage.removeItem(k) }
};
const qs = s=>document.querySelector(s);
const qsa = s=>Array.from(document.querySelectorAll(s));
const td = new TextDecoder();
const b64ToBytes = (b64)=>{ const bin=atob(b64); const u8=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++)u8[i]=bin.charCodeAt(i); return u8 };
function j(x){ try{return JSON.stringify(x,null,2)}catch{return String(x)} }
function log(s){ const b=qs('#logBox'); if(!b) return; b.textContent=(b.textContent+'\n'+s).trim().slice(-9000); b.scrollTop=b.scrollHeight }
function setBadge(msg, ok=true){ const el=qs('#status'); if(!el) return; el.innerHTML=`<span class="dot ${ok?'ok':'err'}"></span><span>${msg}</span>` }

/* ============================================================
   Global CFG (only global flags; all node configs are per‑node)
   ============================================================ */
const CFG = LS.get('graph.cfg', {
  transport: 'http',
  wireMode: true,
  wires: []      // [{ from:'nodeId:out:port', to:'nodeId:in:port' }]
});
function saveCFG(){ LS.set('graph.cfg', CFG) }

/* ============================================================
   Net (HTTP + NKN)
   ============================================================ */
const Net = {
  nkn: { client:null, ready:false, addr:'', pend:new Map(), streams:new Map() },
  auth(h={}, api){
    const out={...h};
    if(!out['Content-Type']) out['Content-Type']='application/json';
    if(api){
      if(/^Bearer\s+/i.test(api)) out['Authorization']=api;
      else out['X-API-Key']=api;
    }
    return out;
  },
  async getJSON(base, path, api, useNkn, relay){
    if(!useNkn){
      const headers = this.auth({}, api);
      delete headers['Content-Type'];
      headers['Accept'] = 'application/json';
      const r = await fetch(base.replace(/\/+$/,'')+path,{headers});
      if(!r.ok) throw new Error(`${r.status} ${r.statusText}`);
      return r.json();
    }
    return this.nknFetch(base, path, 'GET', null, api, relay);
  },
  async postJSON(base, path, body, api, useNkn, relay, timeout=45000){
    if(!useNkn){
      const r = await fetch(base.replace(/\/+$/,'')+path,{method:'POST',headers:this.auth({},api),body:JSON.stringify(body||{})});
      if(!r.ok) throw new Error(`${r.status} ${r.statusText}`);
      return r.json();
    }
    return this.nknFetch(base, path, 'POST', body, api, relay, timeout);
  },
  async fetchBlob(fullUrl, useNkn, relay, api){
    if(!useNkn){ const r=await fetch(fullUrl,{headers:this.auth({},api)}); if(!r.ok) throw new Error(`${r.status} ${r.statusText}`); return r.blob() }
    return this.nknFetchBlob(fullUrl, relay, api)
  },

  ensureNkn(){
    if(CFG.transport!=='nkn') return;
    if(this.nkn.client) return;
    if(!window.nkn || !window.nkn.MultiClient){ setBadge('nkn-sdk missing', false); return }
    const c = new window.nkn.MultiClient({ identifier:'graph', numSubClients:4, wsConnHeartbeatTimeout:60000 });
    this.nkn.client=c;
    c.on('connect',()=>{ this.nkn.ready=true; this.nkn.addr=c.addr||''; const i=qs('#nknInfo'); if(i) i.textContent=`connected • ${this.nkn.addr.slice(0,10)}…`; setBadge('NKN ready') });
    c.on('close',()=>{ this.nkn.ready=false; const i=qs('#nknInfo'); if(i) i.textContent='connecting…' });
    c.on('message',(a,b)=>{
      let p=(a&&typeof a==='object' && a.payload!==undefined)?a.payload:b;
      try{
        const msg=JSON.parse((p&&p.toString)?p.toString():String(p));
        const ev = msg.event||''; const id=msg.id;
        if(ev==='relay.response' && id){ const pr=this.nkn.pend.get(id); if(pr){ clearTimeout(pr.t); this.nkn.pend.delete(id); pr.res(msg) } return }
        if(/^relay\.response\.(begin|chunk|end|lines)$/.test(ev) && id){
          const st=this.nkn.streams.get(id); if(!st) return;
          if(ev==='relay.response.begin'){ st.onBegin && st.onBegin(msg); return }
          if(ev==='relay.response.chunk'){ const u8=b64ToBytes(msg.b64||''); st.onChunk && st.onChunk(u8, msg.seq|0); return }
          if(ev==='relay.response.lines'){
            const arr=Array.isArray(msg.lines)?msg.lines:[];
            for(const it of arr){ try{ st.onLine && st.onLine(it.line, it.seq|0, it.ts) }catch{} }
            return;
          }
          if(ev==='relay.response.end'){ try{ st.onEnd && st.onEnd(msg) } finally { this.nkn.streams.delete(id) } return }
        }
      }catch{}
    });
  },
  async nknSend(req, relay, timeout=45000){
    if(!relay) throw new Error('No relay');
    if(!this.nkn.client) this.ensureNkn();
    const id='g-'+Date.now()+'-'+Math.random().toString(36).slice(2);
    return new Promise((res,rej)=>{
      const t=setTimeout(()=>{ this.nkn.pend.delete(id); rej(new Error('NKN relay timeout')) }, timeout);
      this.nkn.pend.set(id,{res,rej,t});
      this.nkn.client.send(relay, JSON.stringify({event:'http.request', id, req}), { noReply:true, maxHoldingSeconds:120 })
        .catch(e=>{ clearTimeout(t); this.nkn.pend.delete(id); rej(e) });
    });
  },
  async nknStream(req, relay, handlers={}, timeout=300000){
    if(!relay) throw new Error('No relay');
    if(!this.nkn.client) this.ensureNkn();
    const id='g-'+Date.now()+'-'+Math.random().toString(36).slice(2);
    return new Promise(async (resolve,reject)=>{
      let to=null;
      const wrapped={
        onBegin:(...a)=>{ try{handlers.onBegin&&handlers.onBegin(...a)}catch{} },
        onLine:(...a)=>{ try{handlers.onLine&&handlers.onLine(...a)}catch{} },
        onChunk:(...a)=>{ try{handlers.onChunk&&handlers.onChunk(...a)}catch{} },
        onEnd:(...a)=>{ try{handlers.onEnd&&handlers.onEnd(...a)}finally{ clearTimeout(to); this.nkn.streams.delete(id); resolve(); } },
        onError:(err)=>{ clearTimeout(to); this.nkn.streams.delete(id); reject(err instanceof Error?err:new Error(String(err||'nkn stream error'))) }
      };
      this.nkn.streams.set(id, wrapped);
      try{
        await this.nkn.client.send(
          relay,
          JSON.stringify({ event:'http.request', id, req:Object.assign({stream:'chunks'}, req) }),
          { noReply:true, maxHoldingSeconds:120 }
        );
      }catch(e){ this.nkn.streams.delete(id); return reject(e) }
      to=setTimeout(()=>{
        const st=this.nkn.streams.get(id);
        if(st){ this.nkn.streams.delete(id); reject(new Error('NKN stream timeout')) }
      }, timeout);
    });
  },
  async nknFetch(base, path, method, json, api, relay, timeout=45000){
    const headers=this.auth({}, api);
    if(method==='GET'){ delete headers['Content-Type']; headers['Accept']='application/json' }
    const req={ url:base.replace(/\/+$/,'')+path, method, headers, timeout_ms:timeout };
    if(json!==null) req.json=json;
    const r=await this.nknSend(req, relay, timeout);
    if(!r || r.ok===false) throw new Error((r&&r.error)||('HTTP '+(r&&r.status)));
    if(r.json!==undefined && r.json!==null) return r.json;
    if(r.body_b64){ const u8=b64ToBytes(r.body_b64); return JSON.parse(td.decode(u8)) }
    return null;
  },
  async nknFetchBlob(fullUrl, relay, api){
    const parts=[]; let ctype='application/octet-stream';
    await this.nknStream(
      { url:fullUrl, method:'GET', headers:this.auth({'X-Relay-Stream':'chunks'}, api), timeout_ms:10*60*1000 },
      relay,
      { onBegin:(m)=>{ const h=m.headers||{}; ctype=h['content-type']||h['Content-Type']||ctype }, onChunk:(u8)=>parts.push(u8), onEnd:()=>{} }
    );
    return new Blob(parts,{type:ctype});
  }
};

/* ============================================================
   Router (graph wires)
   ============================================================ */
const Router = {
  ports:new Map(), wires:CFG.wires.slice(), sel:null,
  register(key, el, onrecv){
    this.ports.set(key, {el, onrecv});
    // also register alias id:in:port or type:id:port when possible
    const m=/^([a-z]+):([^:]+):(.+)$/.exec(key);
    if(m){ this.ports.set(`${m[2]}:in:${m[3]}`, {el, onrecv}); }
    const n=/^([^:]+):in:(.+)$/.exec(key);
    if(n && el){
      const typeGuess = el.closest('.node')?.querySelector('.title')?.textContent?.trim()?.toLowerCase();
      if(typeGuess) this.ports.set(`${typeGuess}:${n[1]}:${n[2]}`, {el, onrecv});
    }
    if(!el) return;
    el.addEventListener('click', ()=>{
      if(!CFG.wireMode) return;
      if(!this.sel){ this.sel=key; el.classList.add('sel'); return }
      const from=this.sel; this.clearSel();
      if(from===key) return;
      if(!this.wires.find(w=>w.from===from && w.to===key)){
        this.wires.push({from, to:key});
        CFG.wires=this.wires.slice(); saveCFG(); this.render();
        log(`wired ${from} → ${key}`);
      }
    });
  },
  sendFrom(nodeId, portName, payload){
    this.send(`${nodeId}:out:${portName}`, payload);
  },
  clearSel(){ qsa('.wp-port.sel').forEach(e=>e.classList.remove('sel')); this.sel=null },
  send(from, payload){
    for(const w of this.wires){
      if(w.from===from){ const p=this.ports.get(w.to); try{ p && p.onrecv && p.onrecv(payload, from, w.to) } catch(e){ log(`wire error ${w.from}→${w.to}: ${e.message}`) } }
    }
  },
  render(){
    const box=qs('#wiresBox'); if(!box) return;
    box.textContent = this.wires.length ? this.wires.map((w,i)=>`${i+1}. ${w.from} → ${w.to}`).join('\n') : '(no wires)';
  },
  clear(){ this.wires.length=0; CFG.wires=[]; saveCFG(); this.render() }
};

/* ============================================================
   NodeStore — per‑node isolated configs (localStorage)
   ============================================================ */
const NodeStore = {
  key:(id)=>`graph.node.${id}`,
  defaultsByType:{
    ASR:{
      base:'http://localhost:8126', relay:'', api:'', model:'',
      mode:'fast', rate:16000, chunk:120, live:true,
      rms:0.015, hold:250, emaMs:120,
      phraseOn:true, phraseMin:3, phraseStable:350,
      silence:900, prompt:ASR_DEFAULT_PROMPT,
      prevWin:'', prevStep:'', prevModel:''
    },
    LLM:{
      base:'http://127.0.0.1:11434', relay:'', api:'', model:'',
      stream:true, useSystem:false, system:'',
      memoryOn:false, persistMemory:false, maxTurns:16, memory:[]
    },
    TTS:{
      base:'http://localhost:8123', relay:'', api:'', model:'', mode:'stream'
    }
  },
  ensure(id, type){
    let o = LS.get(this.key(id), null);
    if(!o || o.type!==type){
      o = { id, type, config: {...this.defaultsByType[type]} };
      this.saveObj(id, o);
    }
    return o;
  },
  load(id){ return LS.get(this.key(id), null) },
  saveObj(id, obj){ LS.set(this.key(id), obj) },
  saveCfg(id, type, cfg){ this.saveObj(id, { id, type, config: cfg }) },
  update(id, patch){
    const cur=this.load(id) || this.ensure(id, patch.type);
    const cfg={...(cur.config||{}), ...patch};
    this.saveCfg(id, cur.type, cfg);
    return cfg;
  },
  erase(id){ LS.del(this.key(id)) }
};

/* ============================================================
   Sentence Mux (per request instance)
   ============================================================ */
function createSentenceMux(stableMs=250){
  let carry='', pending='', timer=null;
  const SENT_RE=/([\s\S]*?)(?:([.!?;:](?:["')\]]+)*)\s+|(\n{2,}|\r?\n[-*•]\s+)|((?:\p{Extended_Pictographic}|\p{Emoji_Presentation})+\s+))/u;
  function arm(emit){ clear(); timer=setTimeout(()=>{ if(pending){ emit(pending); pending='' } }, stableMs) }
  function clear(){ if(timer){ clearTimeout(timer); timer=null } }
  return {
    push(delta, emit){
      if(!delta) return;
      carry+=delta;
      const produced=[];
      let guard=0;
      while(guard++<1000){
        const m=SENT_RE.exec(carry); if(!m) break;
        const head=(m[1]||'').trim();
        const punc=(m[2]||'').trim();
        const bullet=(m[3]||'').trim();
        const emoji=(m[4]||'').trim();
        const boundary=punc||bullet||emoji;
        if(!boundary) break;
        const sentence=(head+(punc?punc:''))?.trim();
        const cut = m.index + (m[0]||'').length;
        carry = carry.slice(cut);
        if(sentence) produced.push(sentence);
      }
      if(produced.length){
        if(pending) emit(pending);
        for(let i=0;i<produced.length-1;i++) emit(produced[i]);
        pending = produced[produced.length-1];
        arm(emit);
        return;
      }
      if(pending && /\S/.test(carry)){ emit(pending); pending=''; clear(); return }
      if(pending) arm(emit);
    },
    flush(emit){
      clear();
      if(pending){ emit(pending); pending='' }
      const tail=carry.trim(); if(tail) emit(tail); carry=''
    }
  }
}

/* ============================================================
   LLM (node‑scoped)
   ============================================================ */
const EOT_TOKENS = ["<|eot_id|>", "</s>"];
const stripEOT = (s)=>{ let out=s||''; for(const t of EOT_TOKENS){ if(t) out=out.split(t).join('') } return out };

function makeNdjsonPump(onLine){
  const dec=new TextDecoder('utf-8');
  let buf='', inStr=false, esc=false, depth=0;
  function feed(text){
    buf+=text; let start=0;
    for(let i=0;i<buf.length;i++){
      const ch=buf[i];
      if(inStr){ if(esc){ esc=false; continue } if(ch==='\\'){ esc=true; continue } if(ch=== '"'){ inStr=false; continue } continue }
      if(ch==='"'){ inStr=true; continue }
      if(ch==='{'){ depth++; continue }
      if(ch==='}'){
        depth--;
        if(depth===0){
          let ln=buf.slice(start,i+1).trim();
          if(ln.startsWith('data:')) ln=ln.slice(5).trim();
          if(ln && ln!=='[DONE]') onLine(ln);
          start=i+1;
        }
        continue
      }
      if(ch==='\n'){
        const line=buf.slice(start,i).trim();
        if(line==='[DONE]' || line==='data: [DONE]') start=i+1;
      }
    }
    buf = buf.slice(start);
  }
  return {
    push(chunk){
      const s=(chunk instanceof Uint8Array || chunk instanceof ArrayBuffer)?dec.decode(chunk,{stream:true}):String(chunk);
      feed(s);
    },
    flush(){
      const tail=buf.trim();
      if(tail && depth===0){ let ln=tail; if(ln.startsWith('data:')) ln=ln.slice(5).trim(); if(ln && ln!=='[DONE]') onLine(ln) }
      buf=''; inStr=false; esc=false; depth=0;
    }
  }
}

const LLM = {
  async onPrompt(nodeId, payload){
    const node = Graph.getNode(nodeId); if(!node) return;
    const rec  = NodeStore.ensure(nodeId, 'LLM'); const cfg=rec.config||{};
    const base=(cfg.base||'').trim(), api=(cfg.api||'').trim(), relay=(cfg.relay||'').trim(), model=(cfg.model||'').trim();
    const viaNkn = (CFG.transport==='nkn');
    const stream = !!cfg.stream;
    const sysUse = !!cfg.useSystem;
    const sysTxt = (cfg.system||'').trim();
    const memOn  = !!cfg.memoryOn;
    const persist= !!cfg.persistMemory;
    const maxTurns = Number.isFinite(cfg.maxTurns)?cfg.maxTurns:16;

    const text = String(payload && (payload.text ?? payload.prompt ?? payload) || '');
    const memory = Array.isArray(cfg.memory)?cfg.memory.slice():[];

    function buildMessages(latest){
      const msgs=[];
      let iStart=0;
      if(sysUse && sysTxt) msgs.push({role:'system', content:sysTxt});
      if(memOn){
        if(memory.length && memory[0].role==='system'){
          if(!msgs.length) msgs.push(memory[0]);
          iStart=1;
        }
        for(let i=iStart;i<memory.length;i++) msgs.push(memory[i]);
      }
      if(latest?.trim()) msgs.push({role:'user', content:latest.trim()});
      // trim to last N user turns
      if(memOn){
        let userCount=msgs.filter(m=>m.role==='user').length;
        while(userCount>maxTurns){
          // remove earliest user + its following assistant if any (but not system)
          const si = (msgs[0]?.role==='system')?1:0;
          const uIdx = msgs.findIndex((m,i)=>i>=si && m.role==='user');
          if(uIdx<0) break;
          msgs.splice(uIdx, 1);
          // remove assistant immediately after if any
          if(msgs[uIdx]?.role==='assistant') msgs.splice(uIdx,1);
          userCount--;
        }
      }
      return msgs;
    }

    const messages = buildMessages(text);
    const mux = createSentenceMux(250);
    let full='';

    // helper emitters
    const emitDelta = (txt)=>{
      Router.sendFrom(nodeId,'delta',{nodeId,type:'text',text:txt});
    };
    const emitSentence = (s)=>{
      Router.sendFrom(nodeId,'final',{nodeId,text:s,eos:true});
    };

    try{
      if(stream){
        const pump = makeNdjsonPump((ln)=>{
          try{
            const obj=JSON.parse(ln);
            let delta =
              (obj.message && typeof obj.message.content==='string' && obj.message.content) ||
              (typeof obj.response==='string' && obj.response) ||
              (typeof obj.delta==='string' && obj.delta) || '';
            if(!delta && (obj.done||obj.complete) && typeof obj.final==='string') delta=obj.final;
            if(!delta && (obj.done||obj.complete) && obj.message && typeof obj.message.content==='string') delta=obj.message.content;
            if(delta){
              const clean=stripEOT(delta);
              full+=clean;
              emitDelta(clean);
              mux.push(clean, emitSentence);
            }
          }catch{}
        });

        if(viaNkn){
          let expected=null; const stash=new Map(); const seen=new Set();
          const flush=()=>{ while(expected!=null && stash.has(expected)){ pump.push(stash.get(expected)+'\n'); stash.delete(expected); expected++ } };
          await Net.nknStream({
            url:base.replace(/\/+$/,'')+'/api/chat', method:'POST',
            headers:Net.auth({'X-Relay-Stream':'chunks','Accept':'application/x-ndjson'}, api),
            json:{model,messages,stream:true}, timeout_ms:180000
          }, relay, {
            onBegin:()=>{},
            onLine:(line, seqRaw)=>{ const seq=(seqRaw|0); if(seen.has(seq))return; seen.add(seq); if(expected==null) expected=seq;
              if(seq===expected){ pump.push(line+'\n'); expected++; flush(); } else if(seq>expected){ stash.set(seq,line) } },
            onChunk:(u8)=>pump.push(u8),
            onEnd:()=>{ flush(); pump.flush(); mux.flush(emitSentence); }
          }, 180000);
        }else{
          const r = await fetch(base.replace(/\/+$/,'')+'/api/chat', {
            method:'POST',
            headers:Net.auth({'Accept':'application/x-ndjson','Content-Type':'application/json'}, api),
            body:JSON.stringify({model,messages,stream:true})
          });
          if(!r.ok || !r.body) throw new Error(`${r.status} ${r.statusText}`);
          const rd=r.body.getReader();
          while(true){ const {value,done}=await rd.read(); if(done) break; if(value && value.byteLength) pump.push(value) }
          pump.flush(); mux.flush(emitSentence);
        }
      }else{
        const data = await Net.postJSON(base,'/api/chat',{model,messages,stream:false}, api, viaNkn, relay, 120000);
        full = stripEOT((data?.message?.content)||(data?.response)||'') || '';
        if(full){ mux.push(full+'\n', emitSentence); mux.flush(emitSentence) }
      }

      // persist memory per node
      if(cfg.memoryOn){
        const newMem = (memory || []).slice();
        if(sysUse && sysTxt && !(newMem.length && newMem[0].role==='system')){
          newMem.unshift({role:'system', content:sysTxt});
        }
        if(text?.trim()) newMem.push({role:'user', content:text.trim()});
        const finalText = full.trim();
        if(finalText) newMem.push({role:'assistant', content:finalText});
        // trim pairs
        let pairs=0; const pruned=[];
        let i = (newMem.length && newMem[0].role==='system')?1:0;
        for(let k=newMem.length-1;k>=i;k--){
          pruned.push(newMem[k]);
          if(newMem[k].role==='user'){ pairs++; if(pairs>=maxTurns) break; }
        }
        pruned.reverse();
        const out = (newMem[0] && newMem[0].role==='system') ? [newMem[0], ...pruned] : pruned;
        NodeStore.update(nodeId, { memory: out });
        Router.sendFrom(nodeId,'memory',{type:'updated', size: out.length});
      }
    }catch(e){
      log(`[llm ${nodeId}] ${e.message}`);
    }
  },
  onSystem(nodeId, payload){
    const s=String(payload && (payload.text??payload.prompt??payload) || '').trim();
    const rec=NodeStore.ensure(nodeId,'LLM'); NodeStore.update(nodeId, { system:s, useSystem:true });
    setBadge(`System prompt set on ${nodeId}`);
  }
};

/* ============================================================
   TTS (node‑scoped)
   ============================================================ */
const TTS = {
  _state:new Map(), // nodeId -> { ac, node, q:[], queued:0, sr, underruns, audioEl? }
  ensure(nodeId){
    let s=this._state.get(nodeId);
    if(s) return s;
    const ac = new (window.AudioContext||window.webkitAudioContext)({ sampleRate:22050 });
    const node = ac.createScriptProcessor(4096,1,1);
    const st = { ac, node, q:[], queued:0, sr:ac.sampleRate||22050, underruns:0 };
    node.onaudioprocess=(e)=>{
      const out=e.outputBuffer.getChannelData(0);
      if(!st.q.length){ out.fill(0); st.underruns++; return }
      let need=out.length, off=0;
      while(need>0){
        if(!st.q.length){ out.fill(0, off); st.underruns++; break }
        const head=st.q[0]; const take=Math.min(need, head.length);
        out.set(head.subarray(0,take), off);
        if(take===head.length) st.q.shift(); else st.q[0]=head.subarray(take);
        st.queued -= take; off+=take; need-=take;
      }
    };
    node.connect(ac.destination);
    // attach (hidden) audio tag for file mode into node box
    const box = Graph.getNode(nodeId)?.el?.querySelector('.body');
    if(box && !box.querySelector('audio')){
      const au=document.createElement('audio'); au.controls=true; au.style.marginTop='6px'; box.appendChild(au); st.audioEl=au;
    }
    this._state.set(nodeId, st);
    return st;
  },
  f32FromI16(int16){ const f=new Float32Array(int16.length); for(let i=0;i<int16.length;i++) f[i]=Math.max(-1,Math.min(1,int16[i]/32768)); return f },
  resampleLinear(input, fromRate, toRate){
    if(fromRate===toRate) return input; const ratio=toRate/fromRate; const L=Math.round(input.length*ratio);
    const out=new Float32Array(L); for(let i=0;i<L;i++){ const pos=i/ratio; const i0=Math.floor(pos), i1=Math.min(i0+1,input.length-1); const t=pos-i0; out[i]=input[i0]*(1-t)+input[i1]*t } return out;
  },
  enqueue(st, f32){ st.q.push(f32); st.queued+=f32.length },

  _sanitize(s){
    if(!s) return ''; try{s=s.normalize('NFKC')}catch{}; s=s.replace(/[\u2019\u2018]/g,"'");
    s=s.replace(/\bhttps?:\/\/\S+/gi,' '); s=s.replace(/[*_~`]+/g,' ');
    s=s.replace(/\u2026/g,'.').replace(/\.{3,}/g,'.'); s=s.replace(/[“”"«»‹›„‟]/g,' ');
    s=s.replace(/[\[\](){}<>]/g,' '); return s.replace(/[^\S\r\n]+/g,' ').replace(/\s*([.,?!])\s*/g,'$1 ').trim();
  },

  async onText(nodeId, payload){
    const node=Graph.getNode(nodeId); if(!node) return;
    const cfg=NodeStore.ensure(nodeId,'TTS').config||{};
    const base=(cfg.base||'').trim(), api=(cfg.api||'').trim(), relay=(cfg.relay||'').trim(), model=(cfg.model||'').trim();
    const viaNkn=(CFG.transport==='nkn');
    const mode=cfg.mode||'stream';

    const raw=(payload && (payload.text||payload))||''; const eos=!!(payload && payload.eos);
    if(!raw) return;
    const st=this.ensure(nodeId);
    const clean=this._sanitize(String(raw)); if(!clean) return;

    if(mode==='stream'){
      await st.ac.resume();
      // short preroll
      this.enqueue(st, new Float32Array(Math.round((st.sr||22050)*0.04)));

      const req = { text: clean, mode:'stream', format:'raw', ...(model?{model,voice:model}:{}) };
      const handleBytes=(u8)=>{
        if(!u8 || !u8.length) return;
        const even=(u8.length>>1)<<1; if(!even) return;
        const body=u8.subarray(0,even);
        const frames=body.length>>1; const dv=new DataView(body.buffer, body.byteOffset, body.length);
        const i16=new Int16Array(frames); for(let i=0;i<frames;i++) i16[i]=dv.getInt16(i*2,true);
        let f32=this.f32FromI16(i16); if(st.sr!==22050) f32=this.resampleLinear(f32, 22050, st.sr);
        this.enqueue(st, f32);
      };

      try{
        if(viaNkn){
          let expected=null; const stash=new Map(); const seen=new Set(); const flush=()=>{ while(expected!=null && stash.has(expected)){ handleBytes(stash.get(expected)); stash.delete(expected); expected++ } };
          await Net.nknStream(
            { url:base.replace(/\/+$/,'')+'/speak', method:'POST', headers:Net.auth({'X-Relay-Stream':'chunks'}, api), json:req, timeout_ms:120000 },
            relay,
            {
              onBegin:()=>{},
              onChunk:(u8, seqRaw)=>{ const seq=(seqRaw|0); if(seen.has(seq))return; seen.add(seq); if(expected==null) expected=seq; if(seq===expected){ handleBytes(u8); expected++; flush() } else if(seq>expected){ stash.set(seq,u8) } },
              onEnd:()=>{}
            },
            120000
          );
        }else{
          const r=await fetch(base.replace(/\/+$/,'')+'/speak',{method:'POST',headers:Net.auth({},api),body:JSON.stringify(req)});
          if(!r.ok || !r.body) throw new Error(`${r.status} ${r.statusText}`);
          const rd=r.body.getReader(); let leftover=new Uint8Array(0);
          while(true){
            const {value,done}=await rd.read(); if(done) break; if(!value || !value.byteLength) continue;
            const merged=new Uint8Array(leftover.length+value.length); merged.set(leftover,0); merged.set(value,leftover.length);
            const even=(merged.length>>1)<<1; if(even){ handleBytes(merged.subarray(0,even)); leftover=merged.subarray(even) } else leftover=merged;
          }
        }
      }catch(e){ log(`[tts ${nodeId}] ${e.message}`) }
      // small inter‑sentence spacer
      this.enqueue(st, new Float32Array(Math.round((st.sr||22050)*0.03)));
    }else{
      // file(ogg) path
      try{
        const data = await Net.postJSON(base, '/speak', { text:clean, mode:'file', format:'ogg', ...(model?{model,voice:model}:{}) }, api, viaNkn, relay, 10*60*1000);
        let blob=null, mime='audio/ogg';
        if(data?.files?.[0]?.url){ const fileUrl=base.replace(/\/+$/,'')+data.files[0].url; blob=await Net.fetchBlob(fileUrl, viaNkn, relay, api); mime=blob.type||mime }
        else if(data?.audio_b64){ const u8=b64ToBytes(data.audio_b64); blob=new Blob([u8],{type:mime}) }
        else throw new Error('no audio');
        const url=URL.createObjectURL(blob);
        if(st.audioEl){ st.audioEl.src=url; st.audioEl.play().catch(()=>{}) }
      }catch(e){ log(`[tts ${nodeId}] ${e.message}`) }
    }
  }
};

/* ============================================================
   ASR (node‑scoped mic owner; isolated config usage)
   ============================================================ */
const ASR = {
  ownerId:null, running:false, ac:null, media:null, source:null, node:null,
  bufF32:new Float32Array(0), out:0, sid:null, _startingSid:false,
  _rate:16000,_chunk:120,_base:'',_api:'',_relay:'',_viaNkn:false,_live:true,
  _sawSpeech:false, finalizing:false, _vadWatch:null, _lastFinal:{text:'',at:0},
  _DEDUP_MS:1500, vad:{ema:0,state:'silence',lastVoice:0,lastSilence:0},
  aggr:{prev:'',pend:'',pendStart:0,lastChange:0,lastEmit:0},
  _uplinkOn:false,_tailDeadline:0,_preMs:450,_preMaxSamples:0,_preSamples:0,_preChunks:[],
  _sawPartialForUplink:false,_lastPartialAt:0,_lastPostAt:0,_ignorePartials:false,_silenceSince:0,
  _lingerMs:700,_minTailMs:350,_forceQuietMaxMs:2800,

  _nodeEl(){ return this.ownerId ? Graph.getNode(this.ownerId)?.el : null },
  _setVU(p){ const w=Math.max(0, Math.min(100, Math.round(p*150))); const el=this._nodeEl()?.querySelector('.vu > b'); if(el) el.style.width=w+'%' },
  _setPartial(t){ const el=this._nodeEl()?.querySelector('[data-asr-partial]'); if(el) el.textContent=t||'' },
  _setFinal(t){ const el=this._nodeEl()?.querySelector('[data-asr-final]'); if(!el) return; el.textContent=(el.textContent?el.textContent+'\n':'')+t; el.scrollTop=el.scrollHeight },

  pushF32(f32){ const a=this.bufF32,b=f32; const out=new Float32Array(a.length+b.length); out.set(a,0); out.set(b,a.length); this.bufF32=out },
  drainF32(n){ const a=this.bufF32; const take=Math.min(a.length,n); const head=a.subarray(0,take); this.bufF32=a.subarray(take).slice(0); return head },
  resample(f,fr,tr){ if(fr===tr) return f.slice(0); const r=tr/fr, L=Math.round(f.length*r), o=new Float32Array(L); for(let i=0;i<L;i++){ const pos=i/r, i0=Math.floor(pos), i1=Math.min(i0+1,f.length-1), t=pos-i0; o[i]=f[i0]*(1-t)+f[i1]*t } return o },
  i16(f32){ const o=new Int16Array(f32.length); for(let i=0;i<f32.length;i++){ const v=Math.max(-1,Math.min(1,f32[i])); o[i]=v<0 ? v*0x8000 : v*0x7FFF } return new Uint8Array(o.buffer) },

  _preInit(rate){ this._preMaxSamples=Math.max(1,Math.round(rate*(this._preMs/1000))); this._preSamples=0; this._preChunks=[] },
  _prePush(f32){ this._preChunks.push(f32); this._preSamples+=f32.length; while(this._preSamples>this._preMaxSamples && this._preChunks.length){ const drop=this._preChunks.shift(); this._preSamples-=drop.length } },
  _preFlush(){ for(const ch of this._preChunks) this.pushF32(ch); this._preChunks=[]; this._preSamples=0 },

  _openUplink(now, tailMs, current){ if(this._uplinkOn) return; this._uplinkOn=true; this._sawPartialForUplink=false; this._lastPartialAt=0; this._ignorePartials=false; this._tailDeadline=now+tailMs; this._preFlush(); if(current) this.pushF32(current) },
  _extendTail(now, tailMs){ this._tailDeadline=now+tailMs },
  _closeUplinkAndMaybeFinalize(){ if(!this._uplinkOn) return; this._uplinkOn=false; this._ignorePartials=true; this._drainAndEnd().catch(e=>log('[asr] finalize(gate) '+(e?.message||e))) },

  resetAggr(){ this.aggr.prev=''; this.aggr.pend=''; this.aggr.pendStart=0; this.aggr.lastChange=0 },
  handlePartialForPhrases(text, cfg){
    if(!cfg.phraseOn) return;
    const minW=cfg.phraseMin|0 || 3; const stableMs=cfg.phraseStable|0 || 350;
    const prev=this.aggr.prev || '';
    if(!text.startsWith(prev)){ this.aggr.prev=text; this.aggr.pend=''; this.aggr.pendStart=performance.now(); this.aggr.lastChange=this.aggr.pendStart; return }
    const added=text.slice(prev.length); const now=performance.now();
    if(added.length>0){ if(!this.aggr.pend) this.aggr.pendStart=now; this.aggr.pend+=added; this.aggr.prev=text; this.aggr.lastChange=now }
    else{
      const words=(this.aggr.pend.trim().match(/\S+/g)||[]).length;
      const punct=/[.!?;:,]$/.test(this.aggr.pend.trim());
      if(this.aggr.pend && words>=minW && (punct || (now-this.aggr.lastChange)>=stableMs)){
        const phrase=this.aggr.pend.trim();
        this._routePhrase(phrase);
        this.aggr.pend=''; this.aggr.pendStart=0; this.aggr.lastChange=now;
      }
    }
  },
  handleFinalFlush(text){ if(this.aggr.pend){ this._routePhrase(this.aggr.pend.trim()); this.aggr.pend='' } else if(text.startsWith(this.aggr.prev||'')){ const extra=text.slice((this.aggr.prev||'').length).trim(); if(extra) this._routePhrase(extra) } this.aggr.prev=text },
  _routePartial(t){ if(this.ownerId) Router.sendFrom(this.ownerId,'partial',{type:'text',text:t||''}) },
  _routePhrase(t){ if(!t) return; if(this.ownerId) Router.sendFrom(this.ownerId,'phrase',{type:'text',text:t}) },
  _routeFinal(s){ if(!s) return; if(this.ownerId) Router.sendFrom(this.ownerId,'final',{type:'text',text:s,eos:true}) },

  printPartial(t, cfg){ this._setPartial(t||''); this._routePartial(t||''); this.handlePartialForPhrases(t||'', cfg) },
  appendFinal(t){ const s=(t||'').trim().replace(/\s+/g,' '); if(!s) return;
    const now=performance.now(); if(s===this._lastFinal.text && (now-this._lastFinal.at)<=this._DEDUP_MS) return;
    this._lastFinal.text=s; this._lastFinal.at=now; this._setFinal(s); this._routeFinal(s)
  },

  shouldDropAsHallucination(text, meta){
    if(!SIGNOFF_RE.test(text)) return false;
    const words=(text.match(/\S+/g)||[]).length;
    const shortGeneric = words<=7;
    const weSawNoSpeech = !this._sawSpeech;
    const inSilenceNow = this.vad?.state==='silence';
    const noSpeechProb = (meta && typeof meta.no_speech_prob==='number')? meta.no_speech_prob : null;
    const lowConf = (noSpeechProb!==null && noSpeechProb>0.6) ||
      (meta && typeof meta.avg_logprob==='number' && meta.avg_logprob<-1.0) ||
      (meta && typeof meta.compression_ratio==='number' && meta.compression_ratio>2.4);
    return shortGeneric && (weSawNoSpeech || inSilenceNow || lowConf);
  },

  async _ensureLiveSession(cfg){
    if(!this._live || this.sid || this._startingSid || !this.running) return;
    this._startingSid=true;
    try{
      const prompt=(cfg.prompt||'').trim();
      const mode=cfg.mode||'fast';
      const preview_model=(cfg.prevModel||'').trim();
      const preview_window_s = cfg.prevWin ? Number(cfg.prevWin) : undefined;
      const preview_step_s   = cfg.prevStep? Number(cfg.prevStep): undefined;
      const model=(cfg.model||'').trim();
      const body={
        ...(prompt?{prompt}:{ }), mode,
        ...(preview_model?{preview_model}:{ }),
        ...(Number.isFinite(preview_window_s)?{preview_window_s}:{ }),
        ...(Number.isFinite(preview_step_s)?{preview_step_s}:{ }),
        temperature:0.0, condition_on_previous_text:false, no_speech_threshold:0.6, logprob_threshold:-1.0,
        ...(model?{model}:{})
      };
      const data=await Net.postJSON(this._base,'/recognize/stream/start',body,this._api,this._viaNkn,this._relay,45000);
      this.sid=(data && (data.sid||data.id||data.session))||null;
      if(!this.sid) throw new Error('no sid');
      const sid=this.sid;
      this.openEvents(sid, this._viaNkn, this._base, this._relay, this._api, cfg).catch(()=>{});
      this.flushLoop(this._rate,this._chunk,this._viaNkn,this._base,this._relay,this._api).catch(()=>{});
    }catch(e){ log('[asr] start(lazy) '+(e?.message||e)) }
    finally{ this._startingSid=false }
  },

  async _drainAndEnd(){
    if(this.finalizing || !this.sid) return;
    this.finalizing=true;
    const oldSid=this.sid; this._ignorePartials=true;
    const softDeadline=performance.now()+Math.max(900, this._lingerMs+600);
    while(performance.now()<softDeadline){
      const now=performance.now();
      const postQuiet=(now-this._lastPostAt)>=this._lingerMs;
      const partialQuiet=(!this._sawPartialForUplink) || (now-this._lastPartialAt)>=this._lingerMs;
      const hardQuiet=(now-Math.max(this._lastPostAt, this._lastPartialAt||0))>=this._forceQuietMaxMs;
      if((postQuiet && partialQuiet && this.out===0 && this.bufF32.length===0) || hardQuiet) break;
      await new Promise(r=>setTimeout(r,12));
    }
    try{
      const resp=await Net.postJSON(this._base, `/recognize/stream/${encodeURIComponent(oldSid)}/end`, {}, this._api, this._viaNkn, this._relay, 20000);
      const finalText = resp?.final?.text || resp?.final?.result?.text || resp?.text || resp?.result?.text || '';
      if(finalText){ this.handleFinalFlush(finalText); this.appendFinal(finalText) }
    }catch(e){ log('[asr] finalize-live '+(e?.message||e)) }
    finally{ this.sid=null; this.finalizing=false; }
  },

  async start(nodeId){
    if(this.running && this.ownerId===nodeId){ setBadge('ASR already running'); return }
    // if another node owns the mic — stop it first
    if(this.running && this.ownerId && this.ownerId!==nodeId){ await this.stop() }

    const rec=NodeStore.ensure(nodeId,'ASR'); const cfg=rec.config||{};
    this.ownerId=nodeId; this._rate=cfg.rate|0||16000; this._chunk=cfg.chunk|0||120; this._live=!!cfg.live;
    this._viaNkn=(CFG.transport==='nkn'); this._base=cfg.base||''; this._relay=cfg.relay||''; this._api=cfg.api||'';
    this._sawSpeech=false; this.finalizing=false; this._uplinkOn=false; this._tailDeadline=0; this._sawPartialForUplink=false; this._lastPartialAt=0; this._lastPostAt=0; this._ignorePartials=false; this._silenceSince=0;
    this._preInit(this._rate); this._lastFinal={text:'',at:0}; this.resetAggr();

    try{
      this.ac=new (window.AudioContext||window.webkitAudioContext)();
      this.media=await navigator.mediaDevices.getUserMedia({ audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false }, video:false });
      this.source=this.ac.createMediaStreamSource(this.media);
      this.node=(this.ac.createScriptProcessor? this.ac.createScriptProcessor(2048,1,1) : new ScriptProcessorNode(this.ac,{bufferSize:2048,numberOfInputs:1,numberOfOutputs:1}));

      const from=this.ac.sampleRate|0 || this._rate;
      const bufDurMs=(this.node.bufferSize/from)*1000;
      const emaMs=cfg.emaMs|0||120;
      const alpha=1 - Math.exp(-bufDurMs/Math.max(emaMs,1));
      const rmsTh=parseFloat(cfg.rms)||0.015;
      const holdMs=cfg.hold|0||250;
      const silence=cfg.silence|0||900;
      const tailBaseMs=Math.max(this._minTailMs, silence);

      let batchQuietSince=null;
      const vuEl=this._nodeEl()?.querySelector('.vu > b');
      if(vuEl) vuEl.style.width='0%';

      this.vad.ema=0; this.vad.state='silence'; this.vad.lastVoice=0; this.vad.lastSilence=performance.now();

      this.node.onaudioprocess=(e)=>{
        const ch=e.inputBuffer.getChannelData(0);
        let sum=0; for(let i=0;i<ch.length;i++) sum+=ch[i]*ch[i];
        const rmsCur=Math.sqrt(sum/ch.length);
        this.vad.ema=(1-alpha)*this.vad.ema + alpha*rmsCur;
        const ema=this.vad.ema;
        const onTh=rmsTh, offTh=rmsTh*0.7;
        const now=performance.now();
        const tailMs=tailBaseMs;

        const f32=(from===this._rate)? ch.slice(0) : this.resample(ch, from, this._rate);
        this._prePush(f32);

        if(this.vad.state==='silence'){
          if(ema>=onTh){
            this.vad.state='voice'; this.vad.lastVoice=now; this._sawSpeech=true; this._ignorePartials=false;
            this._ensureLiveSession(cfg).then(()=>{ if(this.sid) this._openUplink(now, tailMs, f32) });
          }else if(this._uplinkOn){
            if(now>this._tailDeadline){
              const postQuiet=(now-this._lastPostAt)>=this._lingerMs;
              const partialQuiet=(!this._sawPartialForUplink) || ((now-this._lastPartialAt)>=this._lingerMs);
              const hardQuiet=(now-Math.max(this._lastPostAt, this._lastPartialAt||0))>=this._forceQuietMaxMs;
              if((postQuiet && partialQuiet) || hardQuiet) this._closeUplinkAndMaybeFinalize();
            }
          }
        }else{ // voice
          if(ema>=offTh){ this.vad.lastVoice=now; if(this._uplinkOn){ this._extendTail(now, tailMs); this.pushF32(f32) } }
          else{
            const sinceVoice=now-(this.vad.lastVoice||now);
            if(sinceVoice>=holdMs){ this.vad.state='silence'; this.vad.lastSilence=now; this._silenceSince=now; this._ignorePartials=true; if(this.aggr.pend){ this._routePhrase(this.aggr.pend.trim()); this.aggr.pend='' } }
            else { if(this._uplinkOn) this.pushF32(f32) }
          }
        }

        // UI VU
        this._setVU(ema);

        // batch: finalize after long silence
        if(!this._live){
          if(ema<offTh){ batchQuietSince=batchQuietSince??now; if(now-batchQuietSince>=silence){ batchQuietSince=null; this.finalizeOnce(this._rate).catch(()=>{}) } }
          else batchQuietSince=null;
        }
      };

      this.source.connect(this.node);
      this.node.connect(this.ac.destination);

      clearInterval(this._vadWatch);
      if(this._live){
        this._vadWatch=setInterval(()=>{
          if(!this.sid || this.finalizing || !this._uplinkOn) return;
          const now=performance.now();
          if(this.vad.state!=='silence') return;
          if(now<=this._tailDeadline) return;
          const postQuiet=(now-this._lastPostAt)>=this._lingerMs;
          const partialQuiet=(!this._sawPartialForUplink) || ((now-this._lastPartialAt)>=this._lingerMs);
          const hardQuiet=(now-Math.max(this._lastPostAt, this._lastPartialAt||0))>=this._forceQuietMaxMs;
          if((postQuiet && partialQuiet) || hardQuiet) this._closeUplinkAndMaybeFinalize();
        }, Math.max(50, Math.min(200, this._chunk)));
      }
    }catch(e){
      log('[asr] '+e.message);
      return;
    }

    // node UI reset
    this._setPartial(''); const ff=this._nodeEl()?.querySelector('[data-asr-final]'); if(ff) ff.textContent='';
    this.running=true;
  },

  async stop(){
    if(!this.running) return;
    this.running=false;
    try{ if(this.sid) await Net.postJSON(this._base, `/recognize/stream/${encodeURIComponent(this.sid)}/end`, {}, this._api, this._viaNkn, this._relay, 20000) }catch{}
    this.sid=null; this._uplinkOn=false;
    try{ this.node && this.node.disconnect() }catch{}; try{ this.source && this.source.disconnect() }catch{};
    try{ this.media && this.media.getTracks().forEach(t=>t.stop()) }catch{}; try{ this.ac && this.ac.close() }catch{};
    this.node=this.source=this.media=this.ac=null; clearInterval(this._vadWatch); this._vadWatch=null; this.bufF32=new Float32Array(0); this._preInit(this._rate||16000);
    this._setVU(0);
    this.ownerId=null;
  },

  async finalizeOnce(rate){ if(!this.bufF32.length) return;
    const pcm=this.bufF32; const b=new ArrayBuffer(44+pcm.length*2); const v=new DataView(b); let o=0;
    const W4=s=>{ for(let i=0;i<4;i++) v.setUint8(o++, s.charCodeAt(i)) }; const U32=n=>{ v.setUint32(o,n,true); o+=4 }; const U16=n=>{ v.setUint16(o,n,true); o+=2 };
    const sr=rate, bps=16, ch=1, ba=ch*bps/8, br=sr*ba;
    W4('RIFF'); U32(36+pcm.length*2); W4('WAVE'); W4('fmt '); U32(16); U16(1); U16(1); U32(sr); U32(br); U16(ba); U16(bps); W4('data'); U32(pcm.length*2);
    for(let i=0;i<pcm.length;i++) v.setInt16(44+i*2, Math.max(-1,Math.min(1,pcm[i]))<0 ? pcm[i]*0x8000 : pcm[i]*0x7FFF, true);
    const b64=btoa(String.fromCharCode(...new Uint8Array(b))); this.bufF32=new Float32Array(0);
    try{
      const cfg = NodeStore.ensure(this.ownerId,'ASR').config||{};
      const prompt=(cfg.prompt||'').trim();
      const body=Object.assign({ body_b64:b64, format:'wav', sample_rate:rate }, prompt?{prompt}:{});
      const data=await Net.postJSON(this._base,'/recognize', body, this._api, this._viaNkn, this._relay, 120000);
      const txt=(data && (data.text||data.transcript))||''; if(txt) this.appendFinal(txt);
    }catch(e){ log('[asr] finalize '+e.message) }
  },

  async openEvents(sid, viaNkn, base, relay, api, cfg){
    const pump=(function(){
      let buf=''; return (u8)=>{
        buf+=td.decode(u8,{stream:true}); let i;
        while((i=buf.indexOf('\n\n'))>=0){
          const chunk=buf.slice(0,i); buf=buf.slice(i+2);
          let ev=null, data=''; for(const line of chunk.split(/\r?\n/)){ if(!line) continue; if(line.startsWith(':')) continue; if(line.startsWith('event:')) ev=line.slice(6).trim(); else if(line.startsWith('data:')) data+=(data?'\n':'')+line.slice(5).trim() }
          if(data){
            try{
              const obj=JSON.parse(data); const t=(obj.type||obj.event||'').toLowerCase();
              if(t==='asr.partial'||t==='partial'){
                const text=obj.text||(obj.result&&obj.result.text)||'';
                const sameSid=(sid===ASR.sid); const ok=sameSid && !ASR.finalizing && ASR._uplinkOn && ASR.vad.state==='voice' && !ASR._ignorePartials;
                if(ok){
                  ASR.printPartial(text, cfg);
                  if(text){ ASR._sawSpeech=true; ASR._lastPartialAt=performance.now(); ASR._sawPartialForUplink=true }
                }
              }else if(t==='asr.detected'||t==='detected'){
                const s=obj.text||(obj.result&&obj.result.text)||''; if(s){ const meta=obj.result||obj; if(!ASR.shouldDropAsHallucination(s,meta)) ASR._routePhrase(s) }
              }else if(t==='asr.final'||t==='final'){
                const s=(obj.result&&obj.result.text)||obj.text||''; const meta=obj.result||obj;
                if(s){
                  if(ASR.shouldDropAsHallucination(s, meta)){ log('[asr] dropped probable sign-off: "'+s+'"') }
                  else{ ASR._ignorePartials=true; ASR.appendFinal(s); ASR.handleFinalFlush(s) }
                }
              }
            }catch{}
          }
        }
      }
    })();

    if(viaNkn){
      await Net.nknStream(
        { url:base.replace(/\/+$/,'')+`/recognize/stream/${encodeURIComponent(sid)}/events`, method:'GET', headers:Net.auth({'X-Relay-Stream':'chunks'}, api), timeout_ms:10*60*1000 },
        relay,
        { onBegin:()=>{}, onChunk:(u8)=>pump(u8), onEnd:()=>{} }
      );
    }else{
      const r=await fetch(base.replace(/\/+$/,'')+`/recognize/stream/${encodeURIComponent(sid)}/events`, { headers:Net.auth({}, api) });
      if(!r.ok || !r.body) return;
      const reader=r.body.getReader();
      while(true){ const {value,done}=await reader.read(); if(done) break; if(value && value.byteLength) pump(value) }
    }
  },

  async flushLoop(rate, chunk, viaNkn, base, relay, api){
    const need=()=>Math.round(rate*(chunk/1000));
    while(this.running && this.sid){
      if(this.bufF32.length>=need() && this.out<4 && this._uplinkOn){
        const f32=this.drainF32(need()); const bytes=this.i16(f32);
        const url=base.replace(/\/+$/,'')+`/recognize/stream/${encodeURIComponent(this.sid)}/audio?format=pcm16&sr=${rate}`;
        this.out++;
        try{
          this._lastPostAt=performance.now();
          if(viaNkn){
            await Net.nknSend({ url, method:'POST', headers:Net.auth({'Content-Type':'application/octet-stream'}, api), body_b64:btoa(String.fromCharCode(...bytes)), timeout_ms:20000 }, relay, 20000);
          }else{
            const r=await fetch(url,{method:'POST', headers:Net.auth({'Content-Type':'application/octet-stream'}, api), body:bytes});
            if(!r.ok) throw new Error(r.status+' '+r.statusText);
          }
          this._lastPostAt=performance.now();
        }catch(e){ log('[asr] audio send '+(e&&e.message||e)) }
        finally{ this.out-- }
      }
      await new Promise(r=>setTimeout(r, Math.max(10, chunk/2)));
    }
  }
};

/* ============================================================
   Graph Editor (nodes, wires, dynamic settings)
   ============================================================ */
const Graph = (()=>{
  const WS={ el:null, svg:null, nodes:new Map(), wires:[], portSel:null };

  const TYPES={
    ASR:{
      title:'ASR',
      inputs:[],
      outputs:[{name:'partial'},{name:'phrase'},{name:'final'}],
      schema:[
        {key:'base', label:'Base URL', type:'text', placeholder:'http://localhost:8126'},
        {key:'relay',label:'NKN Relay',type:'text'},
        {key:'api',  label:'API Key', type:'text'},
        {key:'model',label:'Model',   type:'text', placeholder:'base · small · medium · large-v3'},
        {key:'mode', label:'ASR Mode',type:'select', options:['fast','accurate'], def:'fast'},
        {key:'rate', label:'Rate (Hz)',type:'number', def:16000},
        {key:'chunk',label:'Chunk (ms)',type:'number', def:120},
        {key:'live', label:'Live',     type:'select', options:['true','false'], def:'true'},
        {key:'rms',  label:'VAD Thresh',type:'number',step:'0.001', def:0.015},
        {key:'hold', label:'VAD Hangover (ms)',type:'number', def:250},
        {key:'emaMs',label:'EMA Window (ms)',type:'number', def:120},
        {key:'phraseOn',label:'Phrase Stream',type:'select', options:['true','false'], def:'true'},
        {key:'phraseMin',label:'Min Words',type:'number', def:3},
        {key:'phraseStable',label:'Stable (ms)',type:'number', def:350},
        {key:'silence',label:'Silence End (ms)',type:'number', def:900},
        {key:'prevWin',label:'Preview Window (s)',type:'text', placeholder:'(server default)'},
        {key:'prevStep',label:'Preview Step (s)',type:'text', placeholder:'(server default)'},
        {key:'prevModel',label:'Preview Model',type:'text', placeholder:'(server default)'},
        {key:'prompt',label:'Prompt',type:'textarea', placeholder:'Bias decoding, names, spellings…'}
      ]
    },
    LLM:{
      title:'LLM',
      inputs:[{name:'prompt'},{name:'system'}],
      outputs:[{name:'delta'},{name:'final'},{name:'memory'}],
      schema:[
        {key:'base', label:'Base URL', type:'text', placeholder:'http://127.0.0.1:11434'},
        {key:'relay',label:'NKN Relay',type:'text'},
        {key:'api',  label:'API Key', type:'text'},
        {key:'model',label:'Model',   type:'text'},
        {key:'stream',label:'Stream', type:'select', options:['true','false'], def:'true'},
        {key:'useSystem',label:'Use System Message', type:'select', options:['false','true'], def:'false'},
        {key:'system',label:'System Prompt', type:'textarea'},
        {key:'memoryOn',label:'Use Chat Memory', type:'select', options:['false','true'], def:'false'},
        {key:'persistMemory',label:'Persist Memory', type:'select', options:['false','true'], def:'false'},
        {key:'maxTurns',label:'Max Turns', type:'number', def:16}
      ]
    },
    TTS:{
      title:'TTS',
      inputs:[{name:'text'}],
      outputs:[],
      schema:[
        {key:'base', label:'Base URL', type:'text', placeholder:'http://localhost:8123'},
        {key:'relay',label:'NKN Relay',type:'text'},
        {key:'api',  label:'API Key', type:'text'},
        {key:'model',label:'Voice/Model', type:'text', placeholder:'glados_piper_medium or voices/*.onnx'},
        {key:'mode', label:'Mode', type:'select', options:['stream','file'], def:'stream'}
      ]
    }
  };

  const uid=()=>('n'+Math.random().toString(36).slice(2,8));

  function makeNodeEl(node){
    const t=TYPES[node.type];
    const el=document.createElement('div');
    el.className='node';
    el.style.left=(node.x||60)+'px'; el.style.top=(node.y||60)+'px';
    el.dataset.id=node.id;
    el.innerHTML=`
      <div class="head">
        <div class="title">${t.title}</div>
        <div class="row" style="gap:6px;">
          <button class="gear" title="Settings">⚙</button>
          ${node.type==='ASR'?`<button class="gear asrPlay" title="Start/Stop">▶</button>`:''}
          <button class="gear" title="Remove">🗑</button>
        </div>
      </div>
      <div class="body">
        <div class="ports">
          <div class="side left"></div>
          <div class="side right"></div>
        </div>
        ${node.type==='ASR'?`
          <div class="vu" style="margin-top:8px"><b></b></div>
          <div class="muted" style="margin-top:6px;">Partial</div>
          <div class="bubble" data-asr-partial style="min-height:28px"></div>
          <div class="muted" style="margin-top:6px;">Finals</div>
          <div class="code" data-asr-final style="min-height:60px;max-height:120px"></div>
        `:''}
        ${node.type==='TTS'?`<audio controls style="margin-top:6px"></audio>`:''}
      </div>
    `;

    // status row (NKN & type)
    const stat=document.createElement('div');
    stat.className='row'; stat.style.cssText='gap:8px;margin-top:6px;align-items:center;';
    stat.innerHTML=`<span title="NKN"><span class="dot ${CFG.transport==='nkn'?(Net.nkn.ready?'ok':'warn'):'err'}"></span>NKN</span>
                    <span class="muted">${node.type}</span>`;
    el.querySelector('.body').appendChild(stat);

    // Ports
    const left=el.querySelector('.side.left'); const right=el.querySelector('.side.right');

    for(const p of (t.inputs||[])){
      const r=document.createElement('div');
      r.className='wp-port in'; r.dataset.port=p.name; r.title=`${p.name} (Alt-click to disconnect)`;
      r.innerHTML=`<span class="dot"></span><span>${p.name}</span>`;
      r.addEventListener('click',(ev)=>{ if(ev.altKey||ev.metaKey||ev.ctrlKey){ removeWiresAt(node.id,'in',p.name); return } onPortClick(node.id,'in',p.name,r) });
      left.appendChild(r);
      Router.register(`${node.id}:in:${p.name}`, r, (payload)=>{
        if(node.type==='LLM'){
          if(p.name==='prompt') return LLM.onPrompt(node.id, payload);
          if(p.name==='system') return LLM.onSystem(node.id, payload);
        }else if(node.type==='TTS'){
          if(p.name==='text') return TTS.onText(node.id, payload);
        }
      });
    }
    for(const p of (t.outputs||[])){
      const r=document.createElement('div');
      r.className='wp-port out'; r.dataset.port=p.name; r.title=`${p.name} (Alt-click to disconnect)`;
      r.innerHTML=`<span>${p.name}</span><span class="dot"></span>`;
      r.addEventListener('click',(ev)=>{ if(ev.altKey||ev.metaKey||ev.ctrlKey){ removeWiresAt(node.id,'out',p.name); return } onPortClick(node.id,'out',p.name,r) });
      right.appendChild(r);
    }

    // dragging
    const head=el.querySelector('.head'); let drag=null;
    head.addEventListener('pointerdown',(e)=>{ if(e.target.closest('button')) return; drag={dx:e.clientX-el.offsetLeft, dy:e.clientY-el.offsetTop}; head.setPointerCapture(e.pointerId) });
    head.addEventListener('pointermove',(e)=>{ if(!drag) return; const gx=Math.round((e.clientX-drag.dx)/14)*14; const gy=Math.round((e.clientY-drag.dy)/14)*14; el.style.left=gx+'px'; el.style.top=gy+'px'; node.x=gx; node.y=gy; drawAllLinks() });
    head.addEventListener('pointerup',()=>{ drag=null; saveGraph() });

    // buttons
    const [btnGear, btnASR, btnDel] =
      node.type==='ASR' ? el.querySelectorAll('.gear') : (()=>{ const a=el.querySelectorAll('.gear'); return [a[0],null,a[1]] })();
    btnGear.addEventListener('click', ()=> openSettings(node.id) );
    if(btnASR){
      const glyph=()=>{ btnASR.textContent = (ASR.running && ASR.ownerId===node.id) ? '■' : '▶' };
      glyph();
      btnASR.addEventListener('click', async ()=>{
        if(ASR.running && ASR.ownerId===node.id){ await ASR.stop() }
        else { await ASR.start(node.id) }
        setTimeout(glyph,0);
      });
    }
    btnDel.addEventListener('click', ()=> removeNode(node.id) );

    return el;
  }

  // wire helpers
  function onPortClick(nodeId, side, portName, el){
    if(!WS.portSel){
      if(side!=='out'){ setBadge('Pick an output first', false); return }
      WS.portSel={ nodeId, side, portName, el }; el.classList.add('sel'); return;
    }
    if(side!=='in'){ setBadge('Connect to an input port', false); return }
    if(nodeId===WS.portSel.nodeId){ setBadge('Cannot self-link', false); return }
    addLink(WS.portSel.nodeId, WS.portSel.portName, nodeId, portName);
    WS.portSel.el.classList.remove('sel'); WS.portSel=null;
  }
  function addLink(fromNodeId, fromPort, toNodeId, toPort){
    if(WS.wires.find(w=>w.from.node===fromNodeId && w.from.port===fromPort && w.to.node===toNodeId && w.to.port===toPort)) return;
    const w={ id:uid(), from:{node:fromNodeId,port:fromPort}, to:{node:toNodeId,port:toPort}, path:null };
    WS.wires.push(w);
    const p=document.createElementNS('http://www.w3.org/2000/svg','path');
    p.setAttribute('fill','none'); p.setAttribute('stroke','rgba(255,255,255,.7)'); p.setAttribute('stroke-width','2'); p.setAttribute('stroke-linecap','round'); p.setAttribute('opacity','0.95'); p.dataset.id=w.id;
    const kill=(e)=>{ removeWireById(w.id); e.stopPropagation() };
    p.addEventListener('click',(e)=>{ if(e.altKey||e.metaKey||e.ctrlKey) kill(e) });
    p.addEventListener('dblclick', kill);
    WS.svg.appendChild(p); w.path=p;

    const fk=`${fromNodeId}:out:${fromPort}`; const tk=`${toNodeId}:in:${toPort}`;
    if(!Router.wires.find(x=>x.from===fk && x.to===tk)){ Router.wires.push({from:fk,to:tk}); CFG.wires=Router.wires.slice(); saveCFG(); Router.render(); log(`wired ${fk} → ${tk}`) }

    drawAllLinks(); saveGraph();
  }
  function portCenter(nodeId, side, portName){
    const n=WS.nodes.get(nodeId); if(!n) return {x:0,y:0};
    const dot=n.el.querySelector(`.wp-port.${side}[data-port="${CSS.escape(portName)}"] .dot`);
    if(!dot) return {x:0,y:0};
    const r=dot.getBoundingClientRect(); const ws=WS.el.getBoundingClientRect();
    return { x:r.left-ws.left+r.width/2, y:r.top-ws.top+r.height/2 };
  }
  function drawLink(w){
    const a=portCenter(w.from.node,'out',w.from.port); const b=portCenter(w.to.node,'in',w.to.port);
    const dx=Math.max(40, Math.abs(b.x-a.x)*0.5);
    const d=`M ${a.x},${a.y} C ${a.x+dx},${a.y} ${b.x-dx},${b.y} ${b.x},${b.y}`;
    w.path.setAttribute('d', d);
  }
  function drawAllLinks(){ for(const w of WS.wires) drawLink(w) }

  function removeWireById(id){
    const w=WS.wires.find(x=>x.id===id); if(!w) return;
    w.path?.remove(); WS.wires=WS.wires.filter(x=>x!==w); syncRouterFromWS(); saveGraph(); drawAllLinks(); setBadge('Wire removed');
  }
  function removeWiresAt(nodeId, side, portName){
    const rm=WS.wires.filter(w => (side==='out' && w.from.node===nodeId && w.from.port===portName) || (side==='in' && w.to.node===nodeId && w.to.port===portName));
    rm.forEach(w=>w.path?.remove());
    WS.wires=WS.wires.filter(w=>!rm.includes(w));
    syncRouterFromWS(); saveGraph(); drawAllLinks();
  }
  function syncRouterFromWS(){
    const newWires = WS.wires.map(w=>({ from:`${w.from.node}:out:${w.from.port}`, to:`${w.to.node}:in:${w.to.port}` }));
    Router.wires=newWires; CFG.wires=newWires.slice(); saveCFG(); Router.render();
  }

  // persistence
  function saveGraph(){
    const data={ nodes:Array.from(WS.nodes.values()).map(n=>({id:n.id,type:n.type,x:n.x,y:n.y})), links:WS.wires.map(w=>({from:w.from,to:w.to})), nodeConfigs:{} };
    // pack node configs for export
    for(const n of WS.nodes.values()){ const rec=NodeStore.load(n.id); if(rec) data.nodeConfigs[n.id]=rec }
    LS.set('graph.workspace', data);
  }
  function loadGraph(){
    const data=LS.get('graph.workspace', null);
    WS.el.innerHTML=''; WS.svg.innerHTML=''; WS.nodes.clear(); WS.wires=[];
    if(!data){
      // first boot: create a simple chain ASR→LLM→TTS
      const a=addNode('ASR', 90, 200);
      const l=addNode('LLM', 380, 180);
      const t=addNode('TTS', 680, 200);
      addLink(a.id,'final', l.id,'prompt');
      addLink(l.id,'final', t.id,'text');
      drawAllLinks();
      saveGraph();
      return;
    }
    // restore node‑local configs first
    if(data.nodeConfigs){ for(const [id, obj] of Object.entries(data.nodeConfigs)){ if(obj && obj.type && obj.config) NodeStore.saveObj(id, obj) } }

    for(const n of (data.nodes||[])){
      const node={ id:n.id, type:n.type, x:n.x, y:n.y }; NodeStore.ensure(node.id, node.type);
      node.el=makeNodeEl(node); WS.el.appendChild(node.el); WS.nodes.set(node.id, node);
    }
    for(const l of (data.links||[])) addLink(l.from.node, l.from.port, l.to.node, l.to.port);
    drawAllLinks();
  }

  // settings modal
  function openSettings(nodeId){
    const n=WS.nodes.get(nodeId); if(!n) return;
    const rec=NodeStore.ensure(nodeId, n.type); const cfg=rec.config||{};
    const modal=qs('#settingsModal'); const fields=qs('#settingsFields'); const help=qs('#settingsHelp'); const form=qs('#settingsForm');
    fields.innerHTML='';
    const schema=TYPES[n.type].schema||[];
    for(const f of schema){
      const lab=document.createElement('label'); lab.textContent=f.label;
      const inp=(f.type==='textarea')? document.createElement('textarea') : document.createElement('input');
      if(f.type==='select'){
        const sel=document.createElement('select'); for(const o of f.options||[]){ const opt=document.createElement('option'); opt.value=String(o); opt.textContent=String(o); sel.appendChild(opt) }
        sel.name=f.key; sel.value= String( (cfg[f.key]??f.def??'') );
        fields.appendChild(lab); fields.appendChild(sel);
      }else{
        if(f.type!=='textarea') inp.type=f.type||'text';
        if(f.placeholder) inp.placeholder=f.placeholder;
        inp.name=f.key; inp.value = (cfg[f.key]!==undefined && cfg[f.key]!==null) ? String(cfg[f.key]) : String(f.def ?? '');
        if(f.step) inp.step=f.step;
        fields.appendChild(lab); fields.appendChild(inp);
      }
    }
    form.dataset.nodeId=nodeId;
    help.textContent = `${TYPES[n.type].title} • ${nodeId}`;
    modal.classList.remove('hidden'); modal.setAttribute('aria-hidden','false');
  }
  function closeSettings(){
    const modal=qs('#settingsModal'); const form=qs('#settingsForm');
    delete form.dataset.nodeId; modal.classList.add('hidden'); modal.setAttribute('aria-hidden','true');
  }
  function bindModal(){
    qs('#closeSettings')?.addEventListener('click', closeSettings);
    qs('#cancelSettings')?.addEventListener('click', closeSettings);
    qs('#saveSettings')?.addEventListener('click',(e)=>{
      e.preventDefault();
      const form=qs('#settingsForm'); const nodeId=form.dataset.nodeId;
      if(!nodeId) return;
      const n=WS.nodes.get(nodeId); if(!n) return;
      const fd=new FormData(form); const patch={};
      for(const [k,v] of fd.entries()){
        const sch=(TYPES[n.type].schema||[]).find(s=>s.key===k);
        if(!sch){ patch[k]=String(v); continue }
        if(sch.type==='number'){ const num=Number(String(v).trim()); patch[k]=Number.isFinite(num)?num:undefined }
        else if(sch.type==='select'){ if(v==='true'||v==='false') patch[k]=(v==='true'); else if(/^\d+$/.test(String(v))) patch[k]=Number(v); else patch[k]=String(v) }
        else patch[k]=String(v);
      }
      NodeStore.update(nodeId, patch);
      setBadge('Settings saved'); closeSettings();
    });
  }

  // toolbar / boot helpers
  function addNode(type, x=70, y=70){
    const id=uid(); const n={id,type,x,y}; NodeStore.ensure(id,type); n.el=makeNodeEl(n); WS.el.appendChild(n.el); WS.nodes.set(id,n); saveGraph(); drawAllLinks(); return n;
  }
  function removeNode(nodeId){
    const n=WS.nodes.get(nodeId); if(!n) return;
    WS.wires.slice().forEach(w=>{ if(w.from.node===nodeId || w.to.node===nodeId){ w.path?.remove(); WS.wires=WS.wires.filter(x=>x!==w) } });
    n.el.remove(); WS.nodes.delete(nodeId); NodeStore.erase(nodeId);
    syncRouterFromWS(); saveGraph(); drawAllLinks();
    if(ASR.ownerId===nodeId) ASR.stop();
  }
  function exportGraph(){
    const data=LS.get('graph.workspace', {nodes:[],links:[],nodeConfigs:{}});
    const blob=new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
    const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='realtime-graph.json'; a.click(); URL.revokeObjectURL(url);
  }
  function importGraph(){
    const inp=document.createElement('input'); inp.type='file'; inp.accept='application/json';
    inp.onchange=()=>{ const f=inp.files?.[0]; if(!f) return;
      f.text().then(t=>{ const data=JSON.parse(t); LS.set('graph.workspace', data); loadGraph(); setBadge('Graph imported') }).catch(e=>setBadge('Import failed: '+e.message,false));
    }; inp.click();
  }
  function bindToolbar(){
    qs('#addASR')?.addEventListener('click',()=>addNode('ASR', 90, 120));
    qs('#addLLM')?.addEventListener('click',()=>addNode('LLM', 360, 160));
    qs('#addTTS')?.addEventListener('click',()=>addNode('TTS', 650, 200));
    qs('#exportGraph')?.addEventListener('click', exportGraph);
    qs('#importGraph')?.addEventListener('click', importGraph);
  }
  function onResize(){ drawAllLinks() }

  function init(){
    WS.el=qs('#workspace'); WS.svg=qs('#linksSvg');
    bindToolbar(); bindModal();
    loadGraph();
    window.addEventListener('resize', onResize);
    setTimeout(drawAllLinks, 50);
  }

  return { init, addNode, save:saveGraph, load:loadGraph, getNode:(id)=>WS.nodes.get(id) };
})();

/* ============================================================
   Boot / bindings
   ============================================================ */
function bindUI(){
  // global transport & nkn
  const tr=qs('#transport'); if(tr){ tr.value=CFG.transport; tr.addEventListener('change',e=>{ CFG.transport=e.target.value; saveCFG(); if(CFG.transport==='nkn') Net.ensureNkn(); setBadge('Saved') }) }
  qs('#nknConnect')?.addEventListener('click',()=>Net.ensureNkn());
  qs('#nknDisconnect')?.addEventListener('click',()=>{ try{ Net.nkn.client && Net.nkn.client.close() }catch{} Net.nkn.client=null; Net.nkn.ready=false; const i=qs('#nknInfo'); if(i) i.textContent='disconnected'; setBadge('NKN off') });
  qs('#saveAll')?.addEventListener('click',()=>{ saveCFG(); Graph.save(); setBadge('Saved') });

  // wires
  const state=qs('#wireState'); if(state) state.textContent=CFG.wireMode?'ON':'OFF';
  qs('#wireToggle')?.addEventListener('click',()=>{ CFG.wireMode=!CFG.wireMode; if(state) state.textContent=CFG.wireMode?'ON':'OFF'; saveCFG() });
  qs('#clearWires')?.addEventListener('click',()=>Router.clear());
}

function init(){
  bindUI();
  Graph.init();
  Router.render();
  if(CFG.transport==='nkn') Net.ensureNkn();
  setBadge('Ready');
}

document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
