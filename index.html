<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Realtime Graph — ASR → LLM → TTS</title>
    <style>
        :root {
            --bg: #0b0f14;
            --panel: rgba(255, 255, 255, .07);
            --panel2: rgba(255, 255, 255, .05);
            --accent: #66e0ff;
            --accent2: #a8ff60;
            --text: #e8f1f8;
            --muted: #a9b6c3;
            --ok: #7dffb0;
            --warn: #f9c846;
            --err: #ff6b6b;
            --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            --r: 16px;
            --shadow: 0 10px 30px rgba(0, 0, 0, .35), inset 0 0 1px rgba(255, 255, 255, .12)
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            color: var(--text);
            font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial
        }

        body::after {
            content: '';
            position: fixed;
            inset: 0;
            z-index: -1;
            background:
                radial-gradient(1200px 800px at 10% -10%, #163147, transparent 60%),
                radial-gradient(900px 600px at 100% 0%, #1b2d18, transparent 55%),
                var(--bg)
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 18px
        }

        .brand {
            display: flex;
            gap: 12px;
            align-items: center
        }

        .logo {
            width: 36px;
            height: 36px;
        }

        h1 {
            margin: 0;
            font-size: 18px
        }

        .hint {
            color: var(--muted);
            font-size: 12px
        }

        .badge {
            display: inline-flex;
            gap: 8px;
            align-items: center;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .15);
            background: rgba(255, 255, 255, .06)
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%
        }

        .dot.ok {
            background: var(--ok);
            box-shadow: 0 0 10px var(--ok)
        }

        .dot.warn {
            background: var(--warn);
            box-shadow: 0 0 10px var(--warn)
        }

        .dot.err {
            background: var(--err);
            box-shadow: 0 0 10px var(--err)
        }

        main {
            display: grid;
            gap: 14px;
            padding: 0 18px 24px;
            grid-template-columns: repeat(12, 1fr)
        }

        .card {
            grid-column: span 12;
            background: var(--panel);
            border: 1px solid rgba(255, 255, 255, .08);
            border-radius: var(--r);
            backdrop-filter: blur(8px);
            padding: 14px
        }

        @media(min-width:980px) {
            .span-4 {
                grid-column: span 4
            }

            .span-8 {
                grid-column: span 8
            }
        }

        h2 {
            margin: 0 0 8px;
            font-size: 15px
        }

        .isHidden {
            display: none !important;
        }

        .row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center
        }

        label {
            font-size: 12px;
            color: var(--muted);
            margin-right: 6px
        }

        input,
        select,
        textarea {
            width: 100%;
            background: var(--panel2);
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, .15);
            border-radius: 12px;
            padding: 9px 11px;
            outline: none
        }

        textarea {
            min-height: 84px;
            resize: vertical
        }

        button {
            background: linear-gradient(180deg, rgba(102, 224, 255, .9), rgba(102, 224, 255, .6));
            color: #001018;
            border: 0;
            border-radius: 12px;
            padding: 9px 12px;
            font-weight: 700;
            cursor: pointer
        }

        button.secondary {
            background: linear-gradient(180deg, rgba(168, 255, 96, .9), rgba(168, 255, 96, .6));
            color: #021204
        }

        button.ghost {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, .2);
            color: var(--text)
        }

        button.danger {
            background: linear-gradient(180deg, rgba(255, 107, 107, .95), rgba(255, 107, 107, .7));
            color: #280a0a
        }

        .code {
            font-family: var(--mono);
            font-size: 12px;
            background: #04070b;
            border: 1px solid rgba(255, 255, 255, .12);
            border-radius: 12px;
            padding: 10px;
            white-space: pre-wrap;
            max-height: 260px;
            overflow: auto
        }

        .bubble {
            background: rgba(255, 255, 255, .06);
            border: 1px solid rgba(255, 255, 255, .12);
            padding: 10px;
            border-radius: 12px
        }

        .muted {
            color: var(--muted);
            font-size: 12px
        }

        .vu {
            height: 8px;
            border-radius: 999px;
            background: rgba(255, 255, 255, .08);
            border: 1px solid rgba(255, 255, 255, .15);
            overflow: hidden
        }

        .vu>b {
            display: block;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #22c55e, #eab308, #ef4444)
        }

        .port {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 3px 8px;
            border: 1px dashed rgba(255, 255, 255, .25);
            border-radius: 999px;
            font-family: var(--mono);
            font-size: 12px;
            cursor: pointer
        }

        .port.sel {
            background: rgba(255, 255, 255, .1)
        }

        audio {
            width: 100%;
            height: 36px
        }

        .kv {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 8px
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border: 1px solid rgba(255, 255, 255, .18);
            border-radius: 999px;
            background: rgba(255, 255, 255, .06);
            font-family: var(--mono);
            font-size: 12px
        }

        /* Workspace */
        #workspaceWrap {
            position: relative;
            height: 520px;
            border-radius: var(--r);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, .12);
            background:
                linear-gradient(var(--panel2), var(--panel2)),
                repeating-linear-gradient(0deg, transparent 0 28px, rgba(255, 255, 255, .06) 28px 29px),
                repeating-linear-gradient(90deg, transparent 0 28px, rgba(255, 255, 255, .06) 28px 29px);
        }

        #workspace {
            position: absolute;
            inset: 0;
        }

        #workspace .isHidden {
            display: none;
        }

        #linksSvg {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        /* Node */
        .node {
            position: absolute;
            min-width: 220px;
            background: rgba(255, 255, 255, .08);
            border: 1px solid rgba(255, 255, 255, .18);
            border-radius: 14px;
            box-shadow: var(--shadow);
            user-select: none;
        }

        .node .head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 8px 10px;
            cursor: grab;
            background: rgba(0, 0, 0, .15);
            border-bottom: 1px solid rgba(255, 255, 255, .12);
            border-top-left-radius: 14px;
            border-top-right-radius: 14px;
        }

        .node .head:active {
            cursor: grabbing;
        }

        .node .title {
            font-weight: 700;
            font-size: 13px;
        }

        .node .gear {
            width: 24px;
            height: 24px;
            border-radius: 8px;
            padding: 0;
            line-height: 24px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, .25);
            color: var(--text);
        }

        .node .gear:hover {
            background: rgba(255, 255, 255, .08);
        }

        .node .body {
            padding: 10px;
        }

        .node .ports {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .node .side {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .right>.wp-port {

            justify-content: flex-end;

        }

        .wp-port {
            --sz: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: var(--mono);
            font-size: 12px;
            cursor: pointer;
        }

        .wp-port .dot {
            width: var(--sz);
            height: var(--sz);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, .8);
            background: rgba(255, 255, 255, .15);
        }

        .wp-port.out .dot {
            box-shadow: 0 0 0 2px rgba(102, 224, 255, .25);
        }

        .wp-port.in .dot {
            box-shadow: 0 0 0 2px rgba(168, 255, 96, .25);
        }

        .wp-port.sel .dot {
            background: var(--accent);
        }

        /* Modal */
        .modal.hidden {
            display: none;
        }

        .modal {
            position: fixed;
            inset: 0;
            z-index: 1000;
        }

        .modal-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, .5);
            backdrop-filter: blur(2px);
        }

        .modal-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: min(880px, calc(100% - 28px));
            /* wider to fit full card */
            background: var(--panel);
            border: 1px solid rgba(255, 255, 255, .18);
            border-radius: 16px;
            padding: 14px;
            max-height: calc(100vh - 80px);
            /* allow scrolling */
            overflow: auto;
        }

        /* When a card is shown inside the modal, let it stretch naturally */
        .modal-panel .card {
            grid-column: auto;
            margin: 0;
        }

        /* Tiny VU in nodes */
        .node .vu {
            height: 6px;
        }


        .modal-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .modal-title {
            font-weight: 800;
            font-size: 15px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/nkn-sdk@1.3.6/dist/nkn.min.js"></script>
</head>

<body>
    <header>
        <div class="brand">
            <div class="logo">
                <svg xmlns="http://www.w3.org/2000/svg" width="2rem" height="2rem" viewBox="0 0 24 24" fill="none">
                    <path
                        d="M8 6.5H16M7.70502 8.70919L12.2826 15.3034M4.6 9H6.4C6.96005 9 7.24008 9 7.45399 8.89101C7.64215 8.79513 7.79513 8.64215 7.89101 8.45399C8 8.24008 8 7.96005 8 7.4V5.6C8 5.03995 8 4.75992 7.89101 4.54601C7.79513 4.35785 7.64215 4.20487 7.45399 4.10899C7.24008 4 6.96005 4 6.4 4H4.6C4.03995 4 3.75992 4 3.54601 4.10899C3.35785 4.20487 3.20487 4.35785 3.10899 4.54601C3 4.75992 3 5.03995 3 5.6V7.4C3 7.96005 3 8.24008 3.10899 8.45399C3.20487 8.64215 3.35785 8.79513 3.54601 8.89101C3.75992 9 4.03995 9 4.6 9ZM13.6 20H15.4C15.9601 20 16.2401 20 16.454 19.891C16.6422 19.7951 16.7951 19.6422 16.891 19.454C17 19.2401 17 18.9601 17 18.4V16.6C17 16.0399 17 15.7599 16.891 15.546C16.7951 15.3578 16.6422 15.2049 16.454 15.109C16.2401 15 15.9601 15 15.4 15H13.6C13.0399 15 12.7599 15 12.546 15.109C12.3578 15.2049 12.2049 15.3578 12.109 15.546C12 15.7599 12 16.0399 12 16.6V18.4C12 18.9601 12 19.2401 12.109 19.454C12.2049 19.6422 12.3578 19.7951 12.546 19.891C12.7599 20 13.0399 20 13.6 20ZM17.6 9H19.4C19.9601 9 20.2401 9 20.454 8.89101C20.6422 8.79513 20.7951 8.64215 20.891 8.45399C21 8.24008 21 7.96005 21 7.4V5.6C21 5.03995 21 4.75992 20.891 4.54601C20.7951 4.35785 20.6422 4.20487 20.454 4.10899C20.2401 4 19.9601 4 19.4 4H17.6C17.0399 4 16.7599 4 16.546 4.10899C16.3578 4.20487 16.2049 4.35785 16.109 4.54601C16 4.75992 16 5.03995 16 5.6V7.4C16 7.96005 16 8.24008 16.109 8.45399C16.2049 8.64215 16.3578 8.79513 16.546 8.89101C16.7599 9 17.0399 9 17.6 9Z"
                        stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                </svg>
            </div>
            <div>
                <h1>Inference Graph Playground</h1>
                <div class="hint">ASR → LLM → TTS · HTTP or NKN Endpoints</div>
            </div>
        </div>
        <div id="status" class="badge"><span class="dot warn"></span><span>Booting…</span></div>
    </header>

    <main>
        <!-- GLOBAL -->
        <section class="card span-12">
            <h2>Global</h2>
            <div class="row">
                <label>Transport</label>
                <select id="transport">
                    <option value="http">HTTP(S)</option>
                    <option value="nkn">NKN Relay</option>
                </select>
                <button id="nknConnect">Connect NKN</button>
                <button class="ghost" id="nknDisconnect">Disconnect</button>
                <button class="secondary" id="saveAll">Save</button>
                <span class="muted">NKN: <b id="nknInfo">disconnected</b></span>
            </div>
        </section>

        <!-- GRAPH WORKSPACE -->
        <section class="card span-12" id="graphCard">
            <h2>Graph Workspace</h2>
            <div class="row" style="margin-bottom:10px;">
                <button id="addASR">+ ASR</button>
                <button id="addLLM" class="secondary">+ LLM</button>
                <button id="addTTS" class="ghost">+ TTS</button>
                <button id="exportGraph" class="ghost">Export</button>
                <button id="importGraph" class="ghost">Import</button>
                <span class="muted">Drag nodes, click an output port then an input port to link.</span>
            </div>

            <div id="workspaceWrap">
                <svg id="linksSvg" width="100%" height="100%" preserveAspectRatio="none"></svg>
                <div id="workspace"></div>
            </div>
        </section>
        <!-- ASR -->
        <section class="card span-4" id="asrCard">
            <h2>ASR</h2>
            <div class="kv">
                <label>Base URL</label><input id="asrBase" placeholder="http://localhost:8126" />
                <label>NKN Relay</label><input id="asrRelay" placeholder="(full NKN address)" />
                <label>API Key</label><input id="asrApi" placeholder="(optional)" />
                <label>Model</label>
                <input id="asrModel" list="asrModelList" placeholder="base · small · medium · large-v3" />
                <datalist id="asrModelList"></datalist>
                <label>ASR Mode</label>
                <select id="asrMode">
                    <option value="fast" selected>fast (lower latency)</option>
                    <option value="accurate">accurate (steadier)</option>
                </select>

                <label>Preview Window (s)</label>
                <input id="asrPrevWin" type="number" step="0.1" placeholder="(server default)" />

                <label>Preview Step (s)</label>
                <input id="asrPrevStep" type="number" step="0.05" placeholder="(server default)" />

                <label>Preview Model (override)</label>
                <input id="asrPrevModel" list="asrModelList" placeholder="(blank = server default)" />
                <label>Rate</label><input id="asrRate" type="number" value="16000" />
                <label>Chunk (ms)</label><input id="asrChunk" type="number" value="120" />
                <label>Live</label><select id="asrLive">
                    <option value="true" selected>true</option>
                    <option value="false">false</option>
                </select>

                <!-- VAD -->
                <label>VAD Thresh</label><input id="asrRms" type="number" step="0.001" value="0.3" />
                <label>VAD Hangover (ms)</label><input id="asrHold" type="number" value="300" />
                <label>EMA Window (ms)</label><input id="asrEmaMs" type="number" value="100" />

                <!-- phrase streaming -->
                <label>Phrase Stream</label><select id="asrPhraseOn">
                    <option value="true" selected>on</option>
                    <option value="false">off</option>
                </select>
                <label>Min Words</label><input id="asrPhraseMin" type="number" value="1" />
                <label>Stable (ms)</label><input id="asrPhraseStable" type="number" value="350" />

                <!-- batch-only silence -->
                <label>Silence End (ms)</label><input id="asrSilence" type="number" value="1100" />

                <!-- prompt -->
                <label>Prompt</label>
                <textarea id="asrPrompt" placeholder="Bias decoding: keywords, names, spellings…"></textarea>
            </div>
            <div class="row" style="margin-top:8px;">
                <button id="asrStart">Start</button>
                <button class="danger" id="asrStop">Stop</button>
                <button id="asrRefresh">Refresh Models</button>

                <span class="pill"><span class="dot ok" id="asrDot"></span><b id="asrState">idle</b></span>
                <span class="pill">buf:<b id="asrBuf">0</b></span>
                <span class="pill">out:<b id="asrOut">0</b></span>
                <span class="pill">events:<b id="asrEvt">—</b></span>
            </div>
            <div class="row" style="margin-top:6px;">
                <div class="vu" style="flex:1"><b id="asrVu"></b></div>
                <span class="muted">VAD: <span id="asrVad">idle</span></span>
                <span class="muted">RMS: <span id="asrRmsVal">0</span></span>
            </div>
            <div class="row" style="margin-top:8px;">
                <span class="port" data-port="asr:partial">out · partial</span>
                <span class="port" data-port="asr:phrase">out · phrase</span>
                <span class="port" data-port="asr:final">out · final</span>
            </div>
            <div class="muted" style="margin-top:8px;">Partial</div>
            <div id="asrPartial" class="bubble" style="min-height:38px"></div>
            <div class="muted" style="margin-top:8px;">Phrases (streamed)</div>
            <div id="asrPhrases" class="bubble" style="min-height:38px;max-height:96px;overflow:auto"></div>
            <div class="muted" style="margin-top:8px;">Finals</div>
            <div id="asrFinals" class="code" style="min-height:70px"></div>
            <div class="muted" id="asrMeta" style="margin-top:6px;">—</div>
        </section>

        <!-- LLM -->
        <section class="card span-4" id="llmCard">
            <h2>LLM (Ollama)</h2>

            <div class="kv">
                <label>Base URL</label><input id="llmBase" placeholder="http://127.0.0.1:11434" />
                <label>NKN Relay</label><input id="llmRelay" placeholder="(full NKN address)" />
                <label>API Key</label><input id="llmApi" placeholder="(optional)" />
                <label>Model</label><select id="llmModel"></select>
                <label>Stream</label>
                <select id="llmStream">
                    <option value="true" selected>true</option>
                    <option value="false">false</option>
                </select>
            </div>

            <!-- System & Memory controls -->
            <div class="kv" style="margin-top:8px;">
                <label>Use System Message</label>
                <select id="llmUseSystem">
                    <option value="false" selected>false</option>
                    <option value="true">true</option>
                </select>

                <label>Use Chat Memory</label>
                <select id="llmMemory">
                    <option value="false" selected>false</option>
                    <option value="true">true</option>
                </select>

                <label>Persist Memory</label>
                <select id="llmPersistMemory">
                    <option value="false" selected>false</option>
                    <option value="true">true</option>
                </select>

                <label>Max Turns</label>
                <input id="llmMaxTurns" type="number" min="1" step="1" placeholder="16" />
            </div>

            <div class="row" style="margin-top:8px;">
                <label style="width:100%; display:block; margin-bottom:4px;">System Prompt</label>
                <textarea id="llmSystem" rows="3" placeholder="(optional system message)"
                    style="width:100%;"></textarea>
            </div>

            <div class="row" style="margin-top:8px;">
                <button id="llmRefresh">Refresh Models</button>
                <button id="llmClearMemory" class="secondary">Clear Memory</button>
                <span class="pill"><span class="dot warn" id="llmDot"></span><b id="llmState">idle</b></span>
                <span class="pill">tokens:<b id="llmTok">0</b></span>
                <span class="pill">bytes:<b id="llmBytes">0</b></span>
                <span class="pill">elapsed:<b id="llmMs">0ms</b></span>
                <span class="pill">memory:<b id="llmMemSize">0</b></span>
            </div>

            <div class="row" style="margin-top:6px;">
                <span class="port" data-port="llm:prompt">in · prompt</span>
                <span class="port" data-port="llm:system">in · system</span> <!-- ⬅️ NEW -->
                <span class="port" data-port="llm:delta">out · delta</span>
                <span class="port" data-port="llm:final">out · final</span>
                <!-- optional, if you want to listen for memory updates you already emit -->
                <span class="port" data-port="llm:memory">out · memory</span>
            </div>

            <div class="muted" style="margin-top:8px;">Streaming tokens</div>
            <div id="llmTokens" class="code" style="min-height:80px"></div>
        </section>


        <!-- TTS -->
        <section class="card span-4" id="ttsCard">
            <h2>TTS</h2>
            <div class="kv">
                <label>Base URL</label><input id="ttsBase" placeholder="http://localhost:8123" />
                <label>NKN Relay</label><input id="ttsRelay" placeholder="(full NKN address)" />
                <label>API Key</label><input id="ttsApi" placeholder="(optional)" />
                <label>Voice</label><input id="ttsModel" list="ttsModelList"
                    placeholder="glados_piper_medium or voices/*.onnx" />
                <datalist id="ttsModelList"></datalist>
                <label>Mode</label><select id="ttsMode">
                    <option value="stream" selected>stream (raw)</option>
                    <option value="file">file (ogg)</option>
                </select>
            </div>
            <div class="row" style="margin-top:8px;">
                <button id="ttsRefresh">Refresh Voices</button>
                <span class="pill"><span class="dot warn" id="ttsDot"></span><b id="ttsState">idle</b></span>
                <span class="pill">chunks:<b id="ttsChunks">0</b></span>
                <span class="pill">bytes:<b id="ttsBytes">0</b></span>
                <span class="pill">buf samp:<b id="ttsBuf">0</b></span>
                <span class="pill">buf ms:<b id="ttsBufMs">0</b></span>
                <span class="pill">underruns:<b id="ttsUrun">0</b></span>
                <span class="pill">AC:<b id="ttsAC">—</b></span>
            </div>
            <div class="row" style="margin-top:6px;">
                <span class="port" data-port="tts:text">in · text</span>
            </div>
            <audio id="ttsAudio" controls style="margin-top:8px"></audio>
            <div class="muted" id="ttsMeta" style="margin-top:6px;">—</div>
        </section>

        <!-- WIRES -->
        <section class="card span-12">
            <h2>Wires</h2>
            <div class="row">
                <button class="secondary" id="wireToggle">Wire Mode: <b id="wireState">ON</b></button>
                <button class="ghost" id="clearWires">Clear</button>
                <span class="muted">Click source then destination to connect.</span>
            </div>
            <div id="wiresBox" class="code" style="margin-top:8px;min-height:54px"></div>
        </section>

        <!-- LOGS -->
        <section class="card span-12">
            <h2>Status / Logs</h2>
            <div id="logBox" class="code" style="min-height:120px">(logs)</div>
        </section>
    </main>


    <!-- SETTINGS MODAL -->
    <div id="settingsModal" class="modal hidden">
        <div class="modal-backdrop"></div>
        <div class="modal-panel">
            <div class="modal-head">
                <div class="modal-title">Node Settings</div>
                <button class="ghost" id="closeSettings">✕</button>
            </div>

            <!-- The full ASR/LLM/TTS card will be moved here while editing -->
            <div id="settingsSlot"></div>

            <div class="row" style="margin-top:12px;">
                <button id="saveSettings">Save to Node</button>
                <button class="ghost" id="cancelSettings" type="button">Close</button>
                <span class="muted" id="settingsHint">—</span>
            </div>
        </div>
    </div>


    <script>
        // --- Anti-signoff defaults ---
        const ASR_DEFAULT_PROMPT =
            "Context: live interactive conversation, not a video or broadcast. " +
            "Transcribe exactly what is spoken. Do not add generic media sign-offs. " +
            "Avoid phrases such as: \"thanks for watching\", \"like and subscribe\", " +
            "\"don't forget to subscribe\", \"link in the description\".";

        const SIGNOFF_RE = /\b(thanks(?:,)?\s+for\s+(?:watching|listening)|(?:don['’]t\s+forget\s+to\s+)?(?:like|subscribe)|like\s+and\s+subscribe|link\s+in\s+(?:the\s+)?description)\b/i;

        /* ======== tiny helpers ======== */
        const LS = { get(k, d) { try { const v = localStorage.getItem(k); return v ? JSON.parse(v) : d } catch { return d } }, set(k, v) { localStorage.setItem(k, JSON.stringify(v)) } };
        const qs = s => document.querySelector(s); const qsa = s => Array.from(document.querySelectorAll(s));
        const j = x => { try { return JSON.stringify(x, null, 2) } catch { return String(x) } };
        function log(s) { const b = qs('#logBox'); if (!b) return; b.textContent = (b.textContent + '\n' + s).trim().slice(-9000); b.scrollTop = b.scrollHeight }
        function setBadge(msg, ok = true) { const el = qs('#status'); if (!el) return; el.innerHTML = `<span class="dot ${ok ? 'ok' : 'err'}"></span><span>${msg}</span>`; }
        const td = new TextDecoder(); function b64ToBytes(b64) { const bin = atob(b64); const u8 = new Uint8Array(bin.length); for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i); return u8 }

        /* ======== persisted config ======== */
        const CFG = LS.get('graph.cfg', {
            transport: 'http',
            asr: {
                base: 'http://localhost:8126', relay: '', api: '',
                rate: 16000, chunk: 120, live: true,
                rms: 0.015, hold: 250, emaMs: 120,
                phraseOn: true, phraseMin: 3, phraseStable: 350,
                silence: 900,
                prompt: '',
                model: '',
                // NEW
                mode: 'fast',
                prevWin: '',   // number or '' to use server default
                prevStep: '',  // number or '' to use server default
                prevModel: ''  // name or '' = server default for chosen mode
            },
            llm: { base: 'http://127.0.0.1:11434', relay: '', api: '', model: '', stream: true },
            tts: { base: 'http://localhost:8123', relay: '', api: '', model: '', mode: 'stream' },
            wireMode: true,
            wires: [{ from: 'asr:phrase', to: 'llm:prompt' }, { from: 'llm:final', to: 'tts:text' }]
        });

        function saveCFG() { LS.set('graph.cfg', CFG) }

        // --- Simple service status dots
        const Status = {
            _t: null,
            setDot(id, level /* 'ok' | 'warn' | 'err' */) {
                const d = qs('#' + id);
                if (!d) return;
                d.className = 'dot ' + (level || 'err');
            },
            tickNkn() {
                // green when connected; yellow while trying; red when not in NKN mode
                if (CFG.transport === 'nkn') {
                    this.setDot('nknDot', Net.nkn.ready ? 'ok' : 'warn');
                } else {
                    this.setDot('nknDot', 'err');
                }
            },
            async pingASR() {
                try {
                    const viaNkn = CFG.transport === 'nkn';
                    const h = await Net.getJSON(CFG.asr.base, '/health', CFG.asr.api, viaNkn, CFG.asr.relay);
                    // ok if reachable; warn if models list is empty
                    const modelsOk = !!(h && h.models && (h.models.full || h.models.preview_fast || h.models.preview_accurate));
                    this.setDot('asrSvcDot', modelsOk ? 'ok' : 'warn');
                } catch { this.setDot('asrSvcDot', 'err'); }
            },
            async pingLLM() {
                try {
                    const viaNkn = CFG.transport === 'nkn';
                    const r = await Net.getJSON(CFG.llm.base, '/api/tags', CFG.llm.api, viaNkn, CFG.llm.relay);
                    const arr = (r?.models || []).map(m => m.name || m.model).filter(Boolean);
                    this.setDot('llmSvcDot', arr.length ? 'ok' : 'warn');
                } catch { this.setDot('llmSvcDot', 'err'); }
            },
            async pingTTS() {
                try {
                    const viaNkn = CFG.transport === 'nkn';
                    // try common endpoints
                    let ok = false;
                    try {
                        const v = await Net.getJSON(CFG.tts.base, '/voices', CFG.tts.api, viaNkn, CFG.tts.relay);
                        ok = Array.isArray(v) ? v.length > 0 : Array.isArray(v?.voices) ? v.voices.length > 0 : false;
                    } catch { /* fall through to /models */ }
                    if (!ok) {
                        const m = await Net.getJSON(CFG.tts.base, '/models', CFG.tts.api, viaNkn, CFG.tts.relay);
                        ok = Array.isArray(m) ? m.length > 0 : Array.isArray(m?.models) ? m.models.length > 0 : false;
                    }
                    this.setDot('ttsSvcDot', ok ? 'ok' : 'warn');
                } catch { this.setDot('ttsSvcDot', 'err'); }
            },

            refresh() { this.tickNkn(); this.pingASR(); this.pingLLM(); this.pingTTS(); },
            start() { this.ensureBar(); this.refresh(); clearInterval(this._t); this._t = setInterval(() => this.refresh(), 15000); }
        };

        /* ======== network (http+nkn) ======== */
        const Net = {
            nkn: { client: null, ready: false, addr: '', pend: new Map(), streams: new Map() },
            auth(h = {}, api) {
                const out = Object.assign({}, h);
                if (!out['Content-Type']) out['Content-Type'] = 'application/json';
                if (api) {
                    if (/^Bearer\s+/i.test(api)) out['Authorization'] = api;
                    else out['X-API-Key'] = api;
                }
                return out;
            },
            async getJSON(base, path, api, useNkn, relay) {
                if (!useNkn) {
                    const headers = this.auth({}, api);
                    delete headers['Content-Type'];          // ← remove for GET
                    headers['Accept'] = 'application/json';
                    const r = await fetch(base.replace(/\/+$/, '') + path, { headers });
                    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
                    return r.json();
                }
                return this.nknFetch(base, path, 'GET', null, api, relay);
            },
            async postJSON(base, path, body, api, useNkn, relay, timeout = 45000) {
                if (!useNkn) {
                    const r = await fetch(base.replace(/\/+$/, '') + path, { method: 'POST', headers: this.auth({}, api), body: JSON.stringify(body || {}) });
                    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`); return r.json();
                }
                return this.nknFetch(base, path, 'POST', body, api, relay, timeout)
            },
            async fetchBlob(fullUrl, useNkn, relay, api) {
                if (!useNkn) { const r = await fetch(fullUrl, { headers: this.auth({}, api) }); if (!r.ok) throw new Error(`${r.status} ${r.statusText}`); return r.blob() }
                return this.nknFetchBlob(fullUrl, relay, api)
            },


            ensureNkn() {
                if (CFG.transport !== 'nkn') return;
                if (this.nkn.client) return;
                if (!window.nkn || !window.nkn.MultiClient) { setBadge('nkn-sdk missing', false); return }
                const c = new window.nkn.MultiClient({ identifier: 'graph', numSubClients: 4, wsConnHeartbeatTimeout: 60000 }); this.nkn.client = c;
                c.on('connect', () => { this.nkn.ready = true; this.nkn.addr = c.addr || ''; const i = qs('#nknInfo'); if (i) i.textContent = `connected • ${this.nkn.addr.slice(0, 10)}…`; setBadge('NKN ready'); Status.tickNkn && Status.tickNkn(); });
                c.on('close', () => { this.nkn.ready = false; const i = qs('#nknInfo'); if (i) i.textContent = 'connecting…'; Status.tickNkn && Status.tickNkn(); });

                c.on('message', (a, b) => {
                    let p = (a && typeof a === 'object' && a.payload !== undefined) ? a.payload : b;
                    try {
                        const msg = JSON.parse((p && p.toString) ? p.toString() : String(p));
                        const ev = msg.event || ''; const id = msg.id;

                        if (ev === 'relay.response' && id) {
                            const pr = this.nkn.pend.get(id);
                            if (pr) { clearTimeout(pr.t); this.nkn.pend.delete(id); pr.res(msg) }
                            return;
                        }

                        if (/^relay\.response\.(begin|chunk|end|lines)$/.test(ev) && id) {
                            const st = this.nkn.streams.get(id); if (!st) return;
                            if (ev === 'relay.response.begin') { st.onBegin && st.onBegin(msg); return }
                            if (ev === 'relay.response.chunk') { const u8 = b64ToBytes(msg.b64 || ''); st.onChunk && st.onChunk(u8, msg.seq | 0); return }
                            if (ev === 'relay.response.lines') {
                                const arr = Array.isArray(msg.lines) ? msg.lines : [];
                                for (const it of arr) { try { st.onLine && st.onLine(it.line, it.seq | 0, it.ts) } catch { } }
                                return;
                            }
                            if (ev === 'relay.response.end') { try { st.onEnd && st.onEnd(msg) } finally { this.nkn.streams.delete(id) } return }
                        }
                    } catch { }
                });
            },
            async nknSend(req, relay, timeout = 45000) {
                if (!relay) throw new Error('No relay'); if (!this.nkn.client) this.ensureNkn();
                const id = 'g-' + Date.now() + '-' + Math.random().toString(36).slice(2);
                return new Promise((res, rej) => {
                    const t = setTimeout(() => { this.nkn.pend.delete(id); rej(new Error('NKN relay timeout')) }, timeout);
                    this.nkn.pend.set(id, { res, rej, t });
                    this.nkn.client.send(relay, JSON.stringify({ event: 'http.request', id, req }), { noReply: true, maxHoldingSeconds: 120 })
                        .catch(e => { clearTimeout(t); this.nkn.pend.delete(id); rej(e) });
                });
            },
            async nknStream(req, relay, handlers = {}, timeout = 300000) {
                if (!relay) throw new Error('No relay');
                if (!this.nkn.client) this.ensureNkn();
                const id = 'g-' + Date.now() + '-' + Math.random().toString(36).slice(2);

                return new Promise(async (resolve, reject) => {
                    let to = null;
                    const wrapped = {
                        onBegin: (...args) => { try { handlers.onBegin && handlers.onBegin(...args) } catch { } },
                        onLine: (...args) => { try { handlers.onLine && handlers.onLine(...args) } catch { } },
                        onChunk: (...args) => { try { handlers.onChunk && handlers.onChunk(...args) } catch { } },
                        onEnd: (...args) => { try { handlers.onEnd && handlers.onEnd(...args) } catch { } finally { clearTimeout(to); this.nkn.streams.delete(id); resolve(); } },
                        onError: (err) => { clearTimeout(to); this.nkn.streams.delete(id); reject(err instanceof Error ? err : new Error(String(err || 'nkn stream error'))) }
                    };
                    this.nkn.streams.set(id, wrapped);

                    try {
                        await this.nkn.client.send(
                            relay,
                            JSON.stringify({ event: 'http.request', id, req: Object.assign({ stream: 'chunks' }, req) }),
                            { noReply: true, maxHoldingSeconds: 120 }
                        );
                    } catch (e) { this.nkn.streams.delete(id); return reject(e); }

                    to = setTimeout(() => {
                        const st = this.nkn.streams.get(id);
                        if (st) { this.nkn.streams.delete(id); reject(new Error('NKN stream timeout')); }
                    }, timeout);
                });
            },
            async nknFetch(base, path, method, json, api, relay, timeout = 45000) {
                const headers = this.auth({}, api);
                if (method === 'GET') {
                    delete headers['Content-Type'];          // ← avoid preflight in relay
                    headers['Accept'] = 'application/json';
                }
                const req = { url: base.replace(/\/+$/, '') + path, method, headers, timeout_ms: timeout };
                if (json !== null) req.json = json;
                const r = await this.nknSend(req, relay, timeout); if (!r || r.ok === false) throw new Error((r && r.error) || ('HTTP ' + (r && r.status)));
                if (r.json !== undefined && r.json !== null) return r.json;
                if (r.body_b64) { const u8 = b64ToBytes(r.body_b64); return JSON.parse(td.decode(u8)) }
                return null;
            },
            async nknFetchBlob(fullUrl, relay, api) {
                const parts = []; let ctype = 'application/octet-stream';
                await this.nknStream({ url: fullUrl, method: 'GET', headers: this.auth({ 'X-Relay-Stream': 'chunks' }, api), timeout_ms: 10 * 60 * 1000 }, relay, {
                    onBegin: (m) => { const h = m.headers || {}; ctype = h['content-type'] || h['Content-Type'] || ctype },
                    onChunk: (u8) => parts.push(u8),
                    onEnd: () => { }
                });
                return new Blob(parts, { type: ctype })
            }

        };

        /* ======== wiring ======== */
        const Router = {
            ports: new Map(), wires: CFG.wires.slice(), sel: null,
            register(key, el, onrecv) {
                // always keep the original
                this.ports.set(key, { el, onrecv });

                // if key looks like "type:id:port", also register "id:in:port"
                const m = /^([a-z]+):([^:]+):(.+)$/.exec(key);
                if (m) {
                    const canon = `${m[2]}:in:${m[3]}`;
                    this.ports.set(canon, { el, onrecv });
                }
                // if key looks like "id:in:port", also register "type:id:port" (we need a type; best effort)
                const n = /^([^:]+):in:(.+)$/.exec(key);
                if (n && el) {
                    const typeGuess = el.closest('.node')?.querySelector('.title')?.textContent?.trim()?.toLowerCase();
                    if (typeGuess) this.ports.set(`${typeGuess}:${n[1]}:${n[2]}`, { el, onrecv });
                }

                if (!el) return;
                el.addEventListener('click', () => {
                    if (!CFG.wireMode) return;
                    if (!this.sel) { this.sel = key; el.classList.add('sel'); return }
                    const from = this.sel; this.clearSel();
                    if (from === key) return;
                    if (!this.wires.find(w => w.from === from && w.to === key)) {
                        this.wires.push({ from, to: key });
                        CFG.wires = this.wires.slice(); saveCFG();
                        this.render();
                        log(`wired ${from} → ${key}`);
                    }
                });
            },

            sendFrom(nodeId, portName, payload) {
                const fromKey = `${nodeId}:out:${portName}`;
                this.send(fromKey, payload);
            },
            clearSel() { qsa('.port.sel').forEach(e => e.classList.remove('sel')); this.sel = null },
            send(from, payload) { for (const w of this.wires) { if (w.from === from) { const p = this.ports.get(w.to); try { p && p.onrecv && p.onrecv(payload, from, w.to) } catch (e) { log(`wire error ${w.from}→${w.to}: ${e.message}`) } } } },
            render() { const box = qs('#wiresBox'); if (!box) return; box.textContent = this.wires.length ? this.wires.map((w, i) => `${i + 1}. ${w.from} → ${w.to}`).join('\n') : '(no wires)' },
            clear() { this.wires.length = 0; CFG.wires = []; saveCFG(); this.render() }
        };

        /* ======== ASR (always-on VAD; lazy session start) ======== */
        const ASR = {
            // capture + vad graph
            running: false, ac: null, node: null, media: null, source: null,
            // uplink buffers
            bufF32: new Float32Array(0), out: 0,
            // live session
            sid: null, _startingSid: false,

            activeNodeId: null,
            // sticky cfg for lazy session start
            _rate: 16000, _chunk: 120, _viaNkn: false, _base: '', _api: '', _relay: '', _live: true,

            // speech bookkeeping
            _sawSpeech: false,
            finalizing: false,
            _vadWatch: null,

            // de-dupe window for identical final text (ms)
            _DEDUP_MS: 1500,
            _lastFinal: { text: '', at: 0 },

            // VAD state (always-on)
            vad: { ema: 0, state: 'silence', lastVoice: 0, lastSilence: 0 },

            // phrase stream aggregator
            aggr: { prev: '', pend: '', pendStart: 0, lastChange: 0, lastEmit: 0 },

            // model refresh cadence
            models: [], _timer: null, _slow: 180000, _fast: 30000,

            // ─────────────────────────────────────────────────────────────
            // VAD-gated uplink & pre-roll ring buffer + linger
            // ─────────────────────────────────────────────────────────────
            _uplinkOn: false,
            _tailDeadline: 0,
            _preMs: 450,
            _preMaxSamples: 0,
            _preSamples: 0,
            _preChunks: [],
            _sawPartialForUplink: false,
            _lastPartialAt: 0,
            _lastPostAt: 0,

            // gating for late partials & silence tracking
            _ignorePartials: false,
            _silenceSince: 0,

            // timing knobs
            _lingerMs: 700,         // wait this long after last POST/partial before /end
            _minTailMs: 350,        // minimum post-silence tail
            _forceQuietMaxMs: 2800, // hard cap: force finalize if quiet this long

            // AFTER-FINAL cleanup (only for the session that produced the final)
            _afterFinalCleanupForSid(expectedSid) {
                const p = qs('#asrPartial'); if (p) p.textContent = '';
                const ph = qs('#asrPhrases'); if (ph) ph.textContent = '';
                this.resetAggr();
                this._sawPartialForUplink = false;
                // keep Finals
            },

            // ===== model discovery =====
            async _probeModels() {
                const viaNkn = CFG.transport === 'nkn';
                const base = CFG.asr.base, relay = CFG.asr.relay, api = CFG.asr.api;
                const normalize = (data) => {
                    const pick = (arr) => arr.map(m =>
                        typeof m === 'string' ? m : (m && (m.name || m.model || m.id || m.tag)) || ''
                    ).filter(Boolean);
                    if (!data || typeof data !== 'object') return Array.isArray(data) ? pick(data) : [];
                    if (Array.isArray(data)) return pick(data);
                    if (Array.isArray(data.models)) return pick(data.models);
                    if (Array.isArray(data.items)) return pick(data.items);
                    if (Array.isArray(data.data)) return pick(data.data);
                    return [];
                };
                try {
                    const data = await Net.getJSON(base, '/models', api, viaNkn, relay);
                    const arr = normalize(data);
                    return { arr, current: data?.current || {} };
                } catch { }
                for (const p of ['/api/models', '/whisper/models', '/recognize/models']) {
                    try {
                        const resp = await Net.getJSON(base, p, api, viaNkn, relay);
                        const arr = normalize(resp);
                        if (arr.length) return { arr, current: {} };
                    } catch { }
                }
                return { arr: [], current: {} };
            },

            async refreshModels() {
                try {
                    const { arr, current } = await this._probeModels();
                    this.models = arr;
                    const dl = qs('#asrModelList'); if (dl) { dl.innerHTML = ''; arr.forEach(n => { const o = document.createElement('option'); o.value = n; dl.appendChild(o); }); }
                    const prefer = current.full || current.preview || '';
                    const want = (prefer && arr.includes(prefer)) ? prefer
                        : (CFG.asr.model && arr.includes(CFG.asr.model)) ? CFG.asr.model
                            : (arr[0] || '');
                    CFG.asr.model = want;
                    const inp = qs('#asrModel'); if (inp) inp.value = want;
                    const meta = qs('#asrMeta'); if (meta) meta.textContent = arr.length ? `ASR models: ${arr.join(', ')}` : '—';
                    saveCFG();
                } catch (e) { log('[asr] models ' + (e?.message || e)); }
                finally {
                    clearTimeout(this._timer);
                    const healthy = this.models.length > 0;
                    this._timer = setTimeout(() => this.refreshModels(), healthy ? this._slow : this._fast);
                }
            },

            // ===== tiny utils =====
            pushF32(f32) {
                const a = this.bufF32, b = f32; const out = new Float32Array(a.length + b.length);
                out.set(a, 0); out.set(b, a.length); this.bufF32 = out;
                const el = qs('#asrBuf'); if (el) el.textContent = String(out.length);
            },
            drainF32(n) {
                const a = this.bufF32;
                const take = Math.min(a.length, n);
                const head = a.subarray(0, take);
                this.bufF32 = a.subarray(take).slice(0);
                const el = qs('#asrBuf'); if (el) el.textContent = String(this.bufF32.length);
                return head;
            },
            vu(p) {
                const w = Math.max(0, Math.min(100, Math.round(p * 150)));
                const el = qs('#asrVu'); if (el) el.style.width = w + '%';
                qsa('[data-asr-vu] > b').forEach(b => { b.style.width = w + '%'; });
            },
            resample(f, fr, tr) {
                if (fr === tr) return f.slice(0);
                const r = tr / fr, L = Math.round(f.length * r), o = new Float32Array(L);
                for (let i = 0; i < L; i++) {
                    const pos = i / r, i0 = Math.floor(pos), i1 = Math.min(i0 + 1, f.length - 1), t = pos - i0;
                    o[i] = f[i0] * (1 - t) + f[i1] * t;
                }
                return o;
            },
            i16(f32) { const o = new Int16Array(f32.length); for (let i = 0; i < f32.length; i++) { const v = Math.max(-1, Math.min(1, f32[i])); o[i] = v < 0 ? v * 0x8000 : v * 0x7FFF } return new Uint8Array(o.buffer) },
            setState(txt, cls = 'ok') { const s = qs('#asrState'); const d = qs('#asrDot'); if (s) s.textContent = txt; if (d) d.className = 'dot ' + (cls === 'ok' ? 'ok' : cls === 'err' ? 'err' : 'warn') },
            printPartial(t) {
                const el = qs('#asrPartial'); if (el) el.textContent = t || '';
                if (this.activeNodeId) Router.sendFrom(this.activeNodeId, 'partial', { type: 'text', text: t || '' });
                Router.send('asr:partial', { type: 'text', text: t || '' }); // legacy
            },

            addPhrase(t) {
                if (!t) return;
                const box = qs('#asrPhrases');
                if (box) { box.textContent = (box.textContent ? box.textContent + '\n' : '') + t; box.scrollTop = box.scrollHeight; }
                if (this.activeNodeId) Router.sendFrom(this.activeNodeId, 'phrase', { type: 'text', text: t });
                Router.send('asr:phrase', { type: 'text', text: t }); // legacy
            },

            appendFinal(t) {
                const s = (t || '').trim().replace(/\s+/g, ' ');
                if (!s) return;
                const now = performance.now();
                if (s === this._lastFinal.text && (now - this._lastFinal.at) <= this._DEDUP_MS) return;
                this._lastFinal.text = s; this._lastFinal.at = now;

                const box = qs('#asrFinals');
                if (box) { box.textContent = (box.textContent ? box.textContent + '\n' : '') + s; box.scrollTop = box.scrollHeight; }

                if (this.activeNodeId) Router.sendFrom(this.activeNodeId, 'final', { type: 'text', text: s, eos: true });
                Router.send('asr:final', { type: 'text', text: s, eos: true }); // legacy
            },


            ssePump(onEvent) {
                let buf = '';
                return (u8) => {
                    buf += td.decode(u8, { stream: true });
                    let i;
                    while ((i = buf.indexOf('\n\n')) >= 0) {
                        const chunk = buf.slice(0, i);
                        buf = buf.slice(i + 2);
                        let ev = null, data = '';
                        for (const line of chunk.split(/\r?\n/)) {
                            if (!line) continue;
                            if (line.startsWith(':')) continue;
                            if (line.startsWith('event:')) ev = line.slice(6).trim();
                            else if (line.startsWith('data:')) data += (data ? '\n' : '') + line.slice(5).trim();
                        }
                        if (data) onEvent(ev || 'message', data);
                    }
                };
            },

            async refreshHealth() {
                try {
                    const viaNkn = CFG.transport === 'nkn';
                    const h = await Net.getJSON(CFG.asr.base, '/health', CFG.asr.api, viaNkn, CFG.asr.relay);
                    // e.g. { modes: { default, fast:{window_s,step_s}, accurate:{window_s,step_s} }, models:{...} }
                    const m = h?.modes || {};
                    // Use placeholders so users see server defaults at a glance
                    const fw = m.fast?.window_s, fs = m.fast?.step_s, aw = m.accurate?.window_s, as = m.accurate?.step_s;
                    const win = qs('#asrPrevWin'); const step = qs('#asrPrevStep');
                    if (win && !win.value) {
                        const md = (qs('#asrMode')?.value || CFG.asr.mode || 'fast');
                        win.placeholder = md === 'fast' ? String(fw ?? '') : String(aw ?? '');
                    }
                    if (step && !step.value) {
                        const md = (qs('#asrMode')?.value || CFG.asr.mode || 'fast');
                        step.placeholder = md === 'fast' ? String(fs ?? '') : String(as ?? '');
                    }
                    // tiny UX hint
                    const meta = qs('#asrMeta');
                    if (meta && h?.models) {
                        const pf = h.models.preview_fast, pa = h.models.preview_accurate, full = h.models.full;
                        meta.textContent = `device=${h.device} • full=${full} • fast=${pf} • accurate=${pa}`;
                    }
                } catch (e) {
                    // ignore; health is just UX sugar
                }
            },

            resetAggr() { this.aggr.prev = ''; this.aggr.pend = ''; this.aggr.pendStart = 0; this.aggr.lastChange = 0; },

            handlePartialForPhrases(text) {
                if ((qs('#asrPhraseOn')?.value) !== 'true') return;
                const minW = parseInt(qs('#asrPhraseMin')?.value || '3', 10) || 3;
                const stableMs = parseInt(qs('#asrPhraseStable')?.value || '350', 10) || 350;

                const prev = this.aggr.prev || '';
                if (!text.startsWith(prev)) {
                    this.aggr.prev = text;
                    this.aggr.pend = '';
                    this.aggr.pendStart = performance.now();
                    this.aggr.lastChange = this.aggr.pendStart;
                    return;
                }

                const added = text.slice(prev.length);
                const now = performance.now();
                if (added.length > 0) {
                    if (!this.aggr.pend) this.aggr.pendStart = now;
                    this.aggr.pend += added;
                    this.aggr.prev = text;
                    this.aggr.lastChange = now;
                } else {
                    const words = (this.aggr.pend.trim().match(/\S+/g) || []).length;
                    const punct = /[.!?;:,]$/.test(this.aggr.pend.trim());
                    if (this.aggr.pend && words >= minW && (punct || (now - this.aggr.lastChange) >= stableMs)) {
                        const phrase = this.aggr.pend.trim();
                        this.addPhrase(phrase);
                        this.aggr.pend = ''; this.aggr.pendStart = 0; this.aggr.lastChange = now;
                    }
                }
            },

            handleFinalFlush(text) {
                if (this.aggr.pend) { this.addPhrase(this.aggr.pend.trim()); this.aggr.pend = ''; }
                else if (text.startsWith(this.aggr.prev || '')) {
                    const extra = text.slice((this.aggr.prev || '').length).trim();
                    if (extra) this.addPhrase(extra);
                }
                this.aggr.prev = text;
            },

            // ── preroll ring buffer ──
            _preInit(rate) { this._preMaxSamples = Math.max(1, Math.round(rate * (this._preMs / 1000))); this._preSamples = 0; this._preChunks = []; },
            _prePush(f32) {
                this._preChunks.push(f32);
                this._preSamples += f32.length;
                while (this._preSamples > this._preMaxSamples && this._preChunks.length) {
                    const drop = this._preChunks.shift();
                    this._preSamples -= drop.length;
                }
            },
            _preFlushToSend() { for (const ch of this._preChunks) this.pushF32(ch); this._preChunks = []; this._preSamples = 0; },

            // ── uplink gating ──
            _openUplink(now, tailMs, currentBlockF32) {
                if (this._uplinkOn) return;
                this._uplinkOn = true;
                this._sawPartialForUplink = false;
                this._lastPartialAt = 0;
                this._ignorePartials = false; // allow partials while speaking
                this._tailDeadline = now + tailMs;
                this._preFlushToSend();
                if (currentBlockF32) this.pushF32(currentBlockF32);
            },
            _extendTail(now, tailMs) { this._tailDeadline = now + tailMs; },
            _closeUplinkAndMaybeFinalize() {
                if (!this._uplinkOn) return;
                this._uplinkOn = false;
                this._ignorePartials = true;   // drop late partials now
                this._drainAndEnd().catch(e => log('[asr] finalize(gate) ' + (e?.message || e)));
            },

            // ── start a live session lazily (without touching mic/VAD) ──
            async _ensureLiveSession() {
                if (!this._live) return;
                if (this.sid || this._startingSid || !this.running) return;
                this._startingSid = true;
                try {
                    const prompt = (qs('#asrPrompt')?.value || CFG.asr.prompt || '').trim();
                    // NEW: pull mode + overrides from UI/CFG
                    const mode = (qs('#asrMode')?.value || CFG.asr.mode || 'fast');
                    const preview_model = (qs('#asrPrevModel')?.value || CFG.asr.prevModel || '').trim();
                    const preview_window_s_raw = (qs('#asrPrevWin')?.value || CFG.asr.prevWin || '').trim();
                    const preview_step_s_raw = (qs('#asrPrevStep')?.value || CFG.asr.prevStep || '').trim();
                    const preview_window_s = preview_window_s_raw ? Number(preview_window_s_raw) : undefined;
                    const preview_step_s = preview_step_s_raw ? Number(preview_step_s_raw) : undefined;

                    const model = (qs('#asrModel')?.value || CFG.asr.model || '').trim();
                    const body = {
                        ...(prompt ? { prompt } : {}),
                        mode,                              // "fast" or "accurate"
                        ...(preview_model ? { preview_model } : {}),
                        ...(Number.isFinite(preview_window_s) ? { preview_window_s } : {}),
                        ...(Number.isFinite(preview_step_s) ? { preview_step_s } : {}),
                        // (optional) conservative defaults/guardrails if you still want them:
                        temperature: 0.0,
                        condition_on_previous_text: false,
                        no_speech_threshold: 0.6,
                        logprob_threshold: -1.0
                    };

                    const data = await Net.postJSON(this._base, '/recognize/stream/start', body, this._api, this._viaNkn, this._relay, 45000);
                    this.sid = (data && (data.sid || data.id || data.session)) || null;
                    if (!this.sid) throw new Error('no sid');

                    const thisSid = this.sid;
                    this.openEvents(thisSid, this._viaNkn, this._base, this._relay, this._api).catch(() => { });
                    // start uplink loop if not already
                    this.flushLoop(this._rate, this._chunk, this._viaNkn, this._base, this._relay, this._api).catch(() => { });
                    this.setState('streaming', 'ok');
                } catch (e) {
                    log('[asr] start(lazy) ' + (e?.message || e));
                } finally {
                    this._startingSid = false;
                }
            },

            // === drain pending audio and /end the session (but keep mic + VAD alive) ===
            async _drainAndEnd() {
                if (this.finalizing || !this.sid) return;
                this.finalizing = true;

                const oldSid = this.sid;
                this._autoEndSid = oldSid;
                this.setState('finalizing…', 'warn');
                this._ignorePartials = true;

                const softDeadline = performance.now() + Math.max(900, this._lingerMs + 600);
                while (performance.now() < softDeadline) {
                    const now = performance.now();
                    const postQuiet = (now - this._lastPostAt) >= this._lingerMs;
                    const partialQuiet = (!this._sawPartialForUplink) || (now - this._lastPartialAt) >= this._lingerMs;
                    const hardQuiet = (now - Math.max(this._lastPostAt, this._lastPartialAt || 0)) >= this._forceQuietMaxMs;
                    if ((postQuiet && partialQuiet && this.out === 0 && this.bufF32.length === 0) || hardQuiet) break;
                    await new Promise(r => setTimeout(r, 12));
                }

                // IMPORTANT: do NOT stop mic/audio graph here.
                try {
                    const resp = await Net.postJSON(this._base, `/recognize/stream/${encodeURIComponent(oldSid)}/end`, {}, this._api, this._viaNkn, this._relay, 20000);
                    const finalText =
                        resp?.final?.text || resp?.final?.result?.text ||
                        resp?.text || resp?.result?.text || '';
                    if (finalText) {
                        this.handleFinalFlush(finalText);
                        this.appendFinal(finalText);
                        setTimeout(() => this._afterFinalCleanupForSid(oldSid), 0);
                    }
                } catch (e) {
                    log('[asr] finalize-live ' + (e?.message || e));
                } finally {
                    // return to listening idle; session closed
                    this.sid = null;
                    this.finalizing = false;
                    this.setState('listening', 'ok');
                }
            },

            async _finalizeLiveAndRestart() {
                // kept for compatibility; now just ends current session and stays listening
                return this._drainAndEnd();
            },

            async _rollSessionOnSilence() { /* legacy noop */ },

            async start() {
                if (this.running) return;

                this._lastFinal = { text: '', at: 0 };

                // cache cfg for lazy start
                this._rate = parseInt(qs('#asrRate')?.value || '16000', 10) || 16000;
                this._chunk = parseInt(qs('#asrChunk')?.value || '120', 10) || 120;
                this._live = (qs('#asrLive')?.value) === 'true';
                const rmsTh = parseFloat(qs('#asrRms')?.value || '0.015') || 0.015;
                const holdMs = parseInt(qs('#asrHold')?.value || '250', 10) || 250;
                const emaMs = parseInt(qs('#asrEmaMs')?.value || '120', 10) || 120;
                const silence = parseInt(qs('#asrSilence')?.value || '900', 10) || 900;
                const tailBaseMs = Math.max(this._minTailMs, silence);

                this._preMs = parseInt(qs('#asrPreMs')?.value || `${this._preMs}`, 10) || this._preMs;

                this._viaNkn = CFG.transport === 'nkn';
                this._base = CFG.asr.base;
                this._relay = CFG.asr.relay;
                this._api = CFG.asr.api;

                this._autoEndSid = null;
                const suppressReset = !!this._restartFlag;
                this._restartFlag = false;

                this._sawSpeech = false;
                this._lastSpeechAt = 0;
                this.finalizing = false;

                this._uplinkOn = false;
                this._tailDeadline = 0;
                this._sawPartialForUplink = false;
                this._lastPartialAt = 0;
                this._lastPostAt = 0;
                this._ignorePartials = false;
                this._silenceSince = 0;
                this._preInit(this._rate);

                try {
                    this.ac = new (window.AudioContext || window.webkitAudioContext)();
                    this.media = await navigator.mediaDevices.getUserMedia({
                        audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false },
                        video: false
                    });
                    this.source = this.ac.createMediaStreamSource(this.media);
                    this.node = (this.ac.createScriptProcessor
                        ? this.ac.createScriptProcessor(2048, 1, 1)
                        : new ScriptProcessorNode(this.ac, { bufferSize: 2048, numberOfInputs: 1, numberOfOutputs: 1 }));

                    const from = this.ac.sampleRate | 0 || this._rate;
                    const bufDurMs = (this.node.bufferSize / from) * 1000;
                    const alpha = 1 - Math.exp(-bufDurMs / Math.max(emaMs, 1));

                    this.vad.ema = 0;
                    this.vad.state = 'silence';
                    this.vad.lastVoice = 0;
                    this.vad.lastSilence = performance.now();

                    let batchQuietSince = null;

                    this.node.onaudioprocess = (e) => {
                        const ch = e.inputBuffer.getChannelData(0);
                        let sum = 0; for (let i = 0; i < ch.length; i++) sum += ch[i] * ch[i];
                        const rmsCur = Math.sqrt(sum / ch.length);

                        this.vad.ema = (1 - alpha) * this.vad.ema + alpha * rmsCur;
                        const ema = this.vad.ema;
                        const onTh = rmsTh;
                        const offTh = rmsTh * 0.7;
                        const now = performance.now();
                        const tailMs = tailBaseMs;

                        const f32 = (from === this._rate) ? ch.slice(0) : this.resample(ch, from, this._rate);
                        this._prePush(f32); // pre-roll always updated (even when not streaming)

                        if (this.vad.state === 'silence') {
                            if (ema >= onTh) {
                                // ENTER VOICE → ensure session, then open uplink
                                this.vad.state = 'voice';
                                this.vad.lastVoice = now;
                                this._sawSpeech = true;
                                this._lastSpeechAt = now;
                                this._ignorePartials = false;

                                // lazily start a session only when we first detect voice
                                this._ensureLiveSession().then(() => {
                                    if (this.sid) this._openUplink(now, tailMs, f32);
                                });
                            } else if (this._uplinkOn) {
                                // silent while uplink open → don't push silence; check tail deadline
                                if (now > this._tailDeadline) {
                                    const postQuiet = (now - this._lastPostAt) >= this._lingerMs;
                                    const partialQuiet = (!this._sawPartialForUplink) || ((now - this._lastPartialAt) >= this._lingerMs);
                                    const hardQuiet = (now - Math.max(this._lastPostAt, this._lastPartialAt || 0)) >= this._forceQuietMaxMs;
                                    if ((postQuiet && partialQuiet) || hardQuiet) this._closeUplinkAndMaybeFinalize();
                                }
                            }
                        } else {
                            // state === 'voice'
                            if (ema >= offTh) {
                                // still voice
                                this.vad.lastVoice = now;
                                this._lastSpeechAt = now;
                                if (this._uplinkOn) { this._extendTail(now, tailMs); this.pushF32(f32); }
                            } else {
                                // below off → hangover
                                const sinceVoice = now - (this.vad.lastVoice || now);
                                if (sinceVoice >= holdMs) {
                                    // EXIT VOICE → SILENCE
                                    this.vad.state = 'silence';
                                    this.vad.lastSilence = now;
                                    this._silenceSince = now;
                                    this._ignorePartials = true;
                                    if (this.aggr.pend) { this.addPhrase(this.aggr.pend.trim()); this.aggr.pend = ''; }
                                } else {
                                    if (this._uplinkOn) this.pushF32(f32);
                                }
                            }
                        }

                        // UI meters (always-on)
                        this.vu(ema);
                        const v = qs('#asrVad'); if (v) v.textContent = this.vad.state;
                        const rv = qs('#asrRmsVal'); if (rv) rv.textContent = ema.toFixed(3);

                        // BATCH: auto finalize on long silence
                        if (!this._live) {
                            if (ema < offTh) {
                                batchQuietSince = batchQuietSince ?? now;
                                if (now - batchQuietSince >= silence) { batchQuietSince = null; this.finalizeOnce(this._rate).catch(() => { }); }
                            } else { batchQuietSince = null; }
                        }
                    };

                    this.source.connect(this.node);
                    this.node.connect(this.ac.destination);

                    clearInterval(this._vadWatch);
                    if (this._live) {
                        // watchdog: if silent tail elapsed & no uploads/partials recently → finalize
                        this._vadWatch = setInterval(() => {
                            if (!this.sid || this.finalizing || !this._uplinkOn) return;
                            const now = performance.now();
                            if (this.vad.state !== 'silence') return;
                            if (now <= this._tailDeadline) return;
                            const postQuiet = (now - this._lastPostAt) >= this._lingerMs;
                            const partialQuiet = (!this._sawPartialForUplink) || ((now - this._lastPartialAt) >= this._lingerMs);
                            const hardQuiet = (now - Math.max(this._lastPostAt, this._lastPartialAt || 0)) >= this._forceQuietMaxMs;
                            if ((postQuiet && partialQuiet) || hardQuiet) this._closeUplinkAndMaybeFinalize();
                        }, Math.max(50, Math.min(200, this._chunk)));
                    }
                } catch (e) {
                    this.setState('mic error', 'err');
                    log('[asr] ' + e.message);
                    return;
                }

                // UI reset (keep Finals on auto-restarts)
                if (!suppressReset) {
                    const p = qs('#asrPartial'); if (p) p.textContent = '';
                    const ph = qs('#asrPhrases'); if (ph) ph.textContent = '';
                    const f = qs('#asrFinals'); if (f) f.textContent = '';
                }
                this.resetAggr();

                this.running = true;
                this.out = 0; const ao = qs('#asrOut'); if (ao) ao.textContent = '0';
                this.setState(this._live ? 'listening' : 'batch', 'warn'); // LISTENING until VAD starts a session
                // NOTE: we do NOT create a session here; it will be created on voice.
            },

            async stop() {
                if (!this.running) return; this.setState('stopping', 'warn');
                this.running = false;
                this._autoEndSid = null;

                // close session if any
                try {
                    if (this.sid) await Net.postJSON(CFG.asr.base, `/recognize/stream/${encodeURIComponent(this.sid)}/end`, {}, CFG.asr.api, CFG.transport === 'nkn', CFG.asr.relay, 20000);
                } catch { }

                this.sid = null; this._uplinkOn = false;

                try { this.node && this.node.disconnect() } catch { }
                try { this.source && this.source.disconnect() } catch { }
                try { this.media && this.media.getTracks().forEach(t => t.stop()) } catch { }
                try { this.ac && this.ac.close() } catch { }
                this.node = this.source = this.media = this.ac = null;

                clearInterval(this._vadWatch); this._vadWatch = null;
                this.bufF32 = new Float32Array(0);
                this._preInit(parseInt(qs('#asrRate')?.value || '16000', 10) || 16000);

                const ab = qs('#asrBuf'); if (ab) ab.textContent = '0';
                const av = qs('#asrVad'); if (av) av.textContent = 'idle';
                this.setState('idle', 'ok');
                this.activeNodeId = null;
            },

            async finalizeOnce(rate) {
                if (!this.bufF32.length) return;
                const pcm = this.bufF32; const b = new ArrayBuffer(44 + pcm.length * 2); const v = new DataView(b); let o = 0;
                const W4 = s => { for (let i = 0; i < 4; i++) v.setUint8(o++, s.charCodeAt(i)) }; const U32 = n => { v.setUint32(o, n, true); o += 4 }; const U16 = n => { v.setUint16(o, n, true); o += 2 };
                const sr = rate, bps = 16, ch = 1, ba = ch * bps / 8, br = sr * ba;
                W4('RIFF'); U32(36 + pcm.length * 2); W4('WAVE'); W4('fmt '); U32(16); U16(1); U16(1); U32(sr); U32(br); U16(ba); U16(bps); W4('data'); U32(pcm.length * 2);
                for (let i = 0; i < pcm.length; i++) v.setInt16(44 + i * 2, Math.max(-1, Math.min(1, pcm[i])) < 0 ? pcm[i] * 0x8000 : pcm[i] * 0x7FFF, true);
                const b64 = btoa(String.fromCharCode(...new Uint8Array(b))); this.bufF32 = new Float32Array(0);
                try {
                    const prompt = (qs('#asrPrompt')?.value || CFG.asr.prompt || '').trim();
                    const body = Object.assign({ body_b64: b64, format: 'wav', sample_rate: rate }, prompt ? { prompt } : {});
                    const data = await Net.postJSON(CFG.asr.base, '/recognize', body, CFG.asr.api, CFG.transport === 'nkn', CFG.asr.relay, 120000);
                    const txt = (data && (data.text || data.transcript)) || '';
                    if (txt) this.appendFinal(txt);
                } catch (e) { log('[asr] finalize ' + e.message) }
            },

            async openEvents(sid, viaNkn, base, relay, api) {
                const pump = this.ssePump((ev, data) => {
                    try {
                        const obj = JSON.parse(data);
                        const t = (obj.type || obj.event || '').toLowerCase();

                        if (t === 'asr.partial' || t === 'partial') {
                            const text = obj.text || (obj.result && obj.result.text) || '';
                            const sameSid = (sid === this.sid);
                            const ok = sameSid && !this.finalizing && this._uplinkOn && this.vad.state === 'voice' && !this._ignorePartials;
                            if (ok) {
                                this.printPartial(text);
                                this.handlePartialForPhrases(text);
                                if (text) {
                                    this._sawSpeech = true;
                                    this._lastSpeechAt = performance.now();
                                    this._sawPartialForUplink = true;
                                    this._lastPartialAt = performance.now();
                                }
                            }
                        } else if (t === 'asr.detected' || t === 'detected') {
                            const s = obj.text || (obj.result && obj.result.text) || '';
                            if (s) {
                                const meta = (obj.result && obj.result) || obj;
                                if (!ASR.shouldDropAsHallucination(s, meta)) this.addPhrase(s);
                            }
                        } else if (t === 'asr.final' || t === 'final') {
                            const s = (obj.result && obj.result.text) || obj.text || '';
                            const sessionMode = obj.result?.mode || obj.mode;
                            if (sessionMode) log(`[asr] final (${sessionMode}): ${JSON.stringify(s)}`);
                            if (s) {
                                const meta = (obj.result && obj.result) || obj;
                                if (ASR.shouldDropAsHallucination(s, meta)) {
                                    log('[asr] dropped probable hallucinated sign-off: "' + s + '"');
                                } else {
                                    this._ignorePartials = true;
                                    this.appendFinal(s);
                                    this.handleFinalFlush(s);
                                    setTimeout(() => this._afterFinalCleanupForSid(sid), 0);
                                }
                            }
                        } else if (t === 'error') {
                            log('[asr] ' + (obj.message || obj.error || 'error'));
                        }

                        const e = qs('#asrEvt'); if (e) e.textContent = t;
                    } catch { }
                });

                const ev = qs('#asrEvt'); if (ev) ev.textContent = 'connecting';

                if (viaNkn) {
                    await Net.nknStream(
                        { url: base.replace(/\/+$/, '') + `/recognize/stream/${encodeURIComponent(sid)}/events`, method: 'GET', headers: Net.auth({ 'X-Relay-Stream': 'chunks' }, api), timeout_ms: 10 * 60 * 1000 },
                        relay,
                        {
                            onBegin: () => { const e = qs('#asrEvt'); if (e) e.textContent = 'open'; this.setState('streaming', 'ok'); },
                            onChunk: (bytes) => pump(bytes),
                            onEnd: () => {
                                const e = qs('#asrEvt'); if (e) e.textContent = 'ended';
                                // DO NOT stop VAD/watchdog here; we remain listening.
                            }
                        }
                    );
                } else {
                    const r = await fetch(base.replace(/\/+$/, '') + `/recognize/stream/${encodeURIComponent(sid)}/events`, { headers: Net.auth({}, api) });
                    if (!r.ok || !r.body) { const e = qs('#asrEvt'); if (e) e.textContent = 'error'; return }
                    const e = qs('#asrEvt'); if (e) e.textContent = 'open';
                    const reader = r.body.getReader();
                    while (true) { const { value, done } = await reader.read(); if (done) break; if (value && value.byteLength) pump(value) }
                    const ed = qs('#asrEvt'); if (ed) ed.textContent = 'ended';
                    // Keep listening; do not clear watchdog.
                }
            },

            async flushLoop(rate, chunk, viaNkn, base, relay, api) {
                const need = () => Math.round(rate * (chunk / 1000));
                while (this.running && this.sid) {
                    if (this.bufF32.length >= need() && this.out < 4 && this._uplinkOn) {
                        const f32 = this.drainF32(need());
                        const bytes = this.i16(f32);
                        const url = base.replace(/\/+$/, '') + `/recognize/stream/${encodeURIComponent(this.sid)}/audio?format=pcm16&sr=${rate}`;
                        this.out++; const ao = qs('#asrOut'); if (ao) ao.textContent = String(this.out);
                        try {
                            this._lastPostAt = performance.now();
                            if (viaNkn) {
                                await Net.nknSend({ url, method: 'POST', headers: Net.auth({ 'Content-Type': 'application/octet-stream' }, api), body_b64: btoa(String.fromCharCode(...bytes)), timeout_ms: 20000 }, relay, 20000);
                            } else {
                                const r = await fetch(url, { method: 'POST', headers: Net.auth({ 'Content-Type': 'application/octet-stream' }, api), body: bytes });
                                if (!r.ok) throw new Error(r.status + ' ' + r.statusText);
                            }
                            this._lastPostAt = performance.now();
                        } catch (e) { log('[asr] audio send ' + (e && e.message || e)) }
                        finally { this.out--; const ao2 = qs('#asrOut'); if (ao2) ao2.textContent = String(this.out) }
                    }
                    await new Promise(r => setTimeout(r, Math.max(10, chunk / 2)));
                }
            },

            shouldDropAsHallucination(text, meta) {
                const SIGNOFF_RE = /\b(thanks(?:,)?\s+for\s+(?:watching|listening)|(?:don['’]t\s+forget\s+to\s+)?(?:like|subscribe)|like\s+and\s+subscribe|link\s+in\s+(?:the\s+)?description)\b/i;
                if (!SIGNOFF_RE.test(text)) return false;
                const words = (text.match(/\S+/g) || []).length;
                const shortGeneric = words <= 7;
                const weSawNoSpeech = !this._sawSpeech;
                const inSilenceNow = this.vad?.state === 'silence';
                const noSpeechProb = (meta && typeof meta.no_speech_prob === 'number') ? meta.no_speech_prob : null;
                const lowConf = (noSpeechProb !== null && noSpeechProb > 0.6) ||
                    (meta && typeof meta.avg_logprob === 'number' && meta.avg_logprob < -1.0) ||
                    (meta && typeof meta.compression_ratio === 'number' && meta.compression_ratio > 2.4);
                return shortGeneric && (weSawNoSpeech || inSilenceNow || lowConf);
            }
        };





        /* ======== LLM ======== */
        const EOT_TOKENS = ["<|eot_id|>", "</s>"];
        function stripEOT(s) { let out = s || ''; for (const t of EOT_TOKENS) { if (t) out = out.split(t).join('') } return out }
        function makeSeqAligner(deliver) {
            let expected = null;
            const stash = new Map();
            const seen = new Set();

            function flush() {
                while (expected != null && stash.has(expected)) {
                    const v = stash.get(expected);
                    stash.delete(expected);
                    deliver(v);
                    expected++;
                }
            }

            return {
                push(line, seqRaw) {
                    const seq = (seqRaw | 0);
                    if (seen.has(seq)) return;   // drop dupes
                    seen.add(seq);

                    if (expected == null) expected = seq;
                    if (seq === expected) {
                        deliver(line);
                        expected++;
                        flush();
                    } else if (seq > expected) {
                        stash.set(seq, line);
                    }
                    // silently ignore late (< expected)
                },
                end(lastSeq) {
                    // best effort: drain up to lastSeq if provided
                    if (typeof lastSeq === 'number') {
                        flush();
                    } else {
                        flush();
                    }
                }
            };
        }

        // JSON-aware NDJSON pump: emits complete JSON objects even without trailing '\n'
        function makeNdjsonPump(onLine) {
            const dec = new TextDecoder('utf-8');
            let buf = '';
            let inStr = false, esc = false, depth = 0;

            function feed(text) {
                buf += text;
                let start = 0;

                for (let i = 0; i < buf.length; i++) {
                    const ch = buf[i];

                    if (inStr) {
                        if (esc) { esc = false; continue; }
                        if (ch === '\\') { esc = true; continue; }
                        if (ch === '"') { inStr = false; continue; }
                        continue;
                    }

                    // not in string
                    if (ch === '"') { inStr = true; continue; }

                    if (ch === '{') { depth++; continue; }
                    if (ch === '}') {
                        depth--;
                        if (depth === 0) {
                            // complete JSON object [start..i]
                            let ln = buf.slice(start, i + 1).trim();
                            if (ln.startsWith('data:')) ln = ln.slice(5).trim();
                            if (ln && ln !== '[DONE]') onLine(ln);
                            start = i + 1;
                        }
                        continue;
                    }

                    // swallow bare [DONE] lines that may appear between JSONs
                    if (ch === '\n') {
                        const line = buf.slice(start, i).trim();
                        if (line === '[DONE]' || line === 'data: [DONE]') start = i + 1;
                    }
                }

                // keep only unclosed tail
                buf = buf.slice(start);
            }

            return {
                push(chunk) {
                    const s = (chunk instanceof Uint8Array || chunk instanceof ArrayBuffer)
                        ? dec.decode(chunk, { stream: true })
                        : String(chunk);
                    feed(s);
                },
                flush() {
                    // Emit a last object if it's complete but lacked '\n'
                    const tail = buf.trim();
                    if (tail && depth === 0) {
                        let ln = tail;
                        if (ln.startsWith('data:')) ln = ln.slice(5).trim();
                        if (ln && ln !== '[DONE]') onLine(ln);
                    }
                    buf = '';
                    inStr = false; esc = false; depth = 0;
                }
            };
        }


        // Sentence mux for TTS (settled EOS streaming)
        const SentenceMux = {
            // config knobs
            stableMs: 250,               // time of no changes before we accept the last sentence
            // state
            carry: '',
            pending: '',
            emitTimer: null,

            // Exhaustive-ish end-of-sentence detector with closers, bullets, emoji
            SENT_RE: /([\s\S]*?)(?:([.!?;:](?:["')\]]+)*)\s+|(\n{2,}|\r?\n[-*•]\s+)|((?:\p{Extended_Pictographic}|\p{Emoji_Presentation})+\s+))/u,

            // push ordered delta; only emit "settled" sentences
            pushDelta(delta, emitFn) {
                if (!delta) return;

                // add new text to the buffer
                this.carry += delta;

                // extract as many complete sentences as possible from carry
                const produced = [];
                let guard = 0;
                while (guard++ < 1000) {
                    const m = this.SENT_RE.exec(this.carry);
                    if (!m) break;

                    const head = (m[1] || '').trim();
                    const punc = (m[2] || '').trim();
                    const bullet = (m[3] || '').trim();
                    const emoji = (m[4] || '').trim();
                    const boundary = punc || bullet || emoji;
                    if (!boundary) break;

                    const sentence = (head + (punc ? punc : '')).trim();
                    const cut = m.index + (m[0] || '').length;
                    this.carry = this.carry.slice(cut);

                    if (sentence) produced.push(sentence);
                }

                // If we produced any *new* complete sentence(s), we can now COMMIT whatever was pending.
                if (produced.length) {
                    if (this.pending) emitFn(this.pending); // settled by new boundary evidence
                    // keep the *last* as the new pending; emit any earlier immediately
                    for (let i = 0; i < produced.length - 1; i++) emitFn(produced[i]);
                    this.pending = produced[produced.length - 1];
                    this._armTimer(emitFn); // re-arm stability timer for the new pending
                    return;
                }

                // No new boundary yet; if *any* non-space showed up after the pending boundary,
                // that's sufficient look-ahead to settle it (low-latency).
                if (this.pending && /\S/.test(this.carry)) {
                    emitFn(this.pending);
                    this.pending = '';
                    this._clearTimer();
                    return;
                }

                // Otherwise, keep waiting but ensure we have a fallback timer for silence gaps.
                if (this.pending) this._armTimer(emitFn);
            },

            flush(emitFn) {
                // At stream end, everything left is considered final
                this._clearTimer();
                if (this.pending) { emitFn(this.pending); this.pending = ''; }
                const tail = this.carry.trim();
                if (tail) emitFn(tail);
                this.carry = '';
            },

            _armTimer(emitFn) {
                this._clearTimer();
                this.emitTimer = setTimeout(() => {
                    if (this.pending) {
                        emitFn(this.pending);
                        this.pending = '';
                    }
                }, this.stableMs);
            },
            _clearTimer() {
                if (this.emitTimer) { clearTimeout(this.emitTimer); this.emitTimer = null; }
            }
        };


        const LLM = {
            // ---- conversation state ----
            _memLoaded: false,
            _history: [],            // [{role:'user'|'assistant'|'system', content:string}, ...]
            _lastUserText: '',       // captured per-turn so we can save to memory after streaming
            _sysOverride: '',
            // Pull toggles from DOM or CFG with sane fallbacks
            _useSystem() {
                return (qs('#llmUseSystem')?.value === 'true') || !!CFG.llm?.useSystem || !!this._sysOverride;
            },
            _systemText() {
                // precedence: live override → UI value → CFG
                return (this._sysOverride && this._sysOverride.trim())
                    || (qs('#llmSystem')?.value || CFG.llm?.system || '').trim();
            },
            _memoryOn() { return (qs('#llmMemory')?.value === 'true') || !!CFG.llm?.memoryOn; },
            _persistOn() { return (qs('#llmPersistMemory')?.value === 'true') || !!CFG.llm?.persistMemory; },
            _maxTurns() {
                // number of user/assistant pairs to keep (not counting system)
                const n = parseInt(qs('#llmMaxTurns')?.value || (CFG.llm?.maxTurns ?? 16), 10);
                return Number.isFinite(n) && n > 0 ? n : 16;
            },
            onSystem(nodeId, payload) {
                const n = Graph.getNode(nodeId); if (!n) return;
                const s = String(payload && (payload.text ?? payload.prompt ?? payload) || '').trim();
                n.config = Object.assign({}, n.config, { system: s, useSystem: 'true' });
                Graph.save();                 // persist to this node only
                setBadge(`System prompt updated for ${nodeId}`);
            },
            _ensureMemoryLoaded() {
                if (this._memLoaded) return;
                // load any persisted memory
                if (CFG.llm && Array.isArray(CFG.llm.memory)) {
                    // make a shallow copy to avoid accidental shared mutation
                    this._history = CFG.llm.memory.slice();
                } else {
                    this._history = [];
                }
                this._memLoaded = true;
            },

            clearMemory() {
                this._history = [];
                if (CFG.llm) { CFG.llm.memory = []; saveCFG(); }
                Router.send('llm:memory', { type: 'cleared' });
            },

            _trimHistoryInPlace() {
                // Keep only last N user/assistant turns (plus leading system if present)
                const maxPairs = this._maxTurns();

                // Identify an initial system message (only first is kept)
                let sys = null;
                const rest = [];
                for (const m of this._history) {
                    if (!sys && m.role === 'system') { sys = m; continue; }
                    rest.push(m);
                }

                // Walk from end and keep last maxPairs pairs (user+assistant). If odd count, keep the last message anyway.
                const pruned = [];
                let pairs = 0;
                for (let i = rest.length - 1; i >= 0; i--) {
                    pruned.push(rest[i]);
                    if (rest[i].role === 'user') {
                        // Count a pair when we see a user message, assuming assistant follows it earlier in the array
                        pairs++;
                        if (pairs >= maxPairs) { break; }
                    }
                }
                pruned.reverse();
                this._history = (sys ? [sys] : []).concat(pruned);
            },

            _rememberTurn(userText, assistantText) {
                if (!this._memoryOn()) return; // memory off → do not store
                this._ensureMemoryLoaded();

                // If a system message is configured AND memory has no system yet, pin it at the front (once).
                if (this._useSystem()) {
                    const sysText = this._systemText();
                    if (sysText && !this._history.some(m => m.role === 'system')) {
                        this._history.unshift({ role: 'system', content: sysText });
                    }
                }

                // Append the turn
                if (userText?.trim()) this._history.push({ role: 'user', content: userText.trim() });
                if (assistantText?.trim()) this._history.push({ role: 'assistant', content: assistantText.trim() });

                // Trim & optionally persist
                this._trimHistoryInPlace();
                if (this._persistOn()) {
                    if (!CFG.llm) CFG.llm = {};
                    CFG.llm.memory = this._history.slice();
                    saveCFG();
                }

                Router.send('llm:memory', { type: 'updated', size: this._history.length });
            },

            _buildMessages(latestUserText) {
                const msgs = [];
                const useSys = this._useSystem();
                const memOn = this._memoryOn();
                this._ensureMemoryLoaded();

                // System message (explicit UI or CFG)
                const sysText = this._systemText();
                if (useSys && sysText) {
                    // If history already contains a system (persisted), ensure the first message is that one,
                    // and update its content if it differs (so the toggle updates future calls).
                    const hasSysIdx = this._history.findIndex(m => m.role === 'system');
                    if (hasSysIdx >= 0) {
                        if (this._history[hasSysIdx].content !== sysText) {
                            this._history[hasSysIdx] = { role: 'system', content: sysText };
                            if (this._persistOn()) { CFG.llm.memory = this._history.slice(); saveCFG(); }
                        }
                    } else {
                        // don't modify stored history at build time; only send system transiently unless we later save
                        msgs.push({ role: 'system', content: sysText });
                    }
                }

                // History (if enabled)
                if (memOn) {
                    // If history contains a system and we didn't add one above transiently,
                    // include from stored history.
                    let i = 0;
                    if (this._history.length && this._history[0].role === 'system') {
                        if (!msgs.length) msgs.push(this._history[0]);
                        i = 1;
                    }
                    for (; i < this._history.length; i++) msgs.push(this._history[i]);
                }

                // Finally add the new user message
                if (latestUserText?.trim()) {
                    msgs.push({ role: 'user', content: latestUserText.trim() });
                }

                return msgs;
            },

            async refreshModels() {
                try {
                    const data = await Net.getJSON(CFG.llm.base, '/api/tags', CFG.llm.api, CFG.transport === 'nkn', CFG.llm.relay);
                    const arr = (data?.models || []).map(m => m.name || m.model).filter(Boolean);
                    const sel = qs('#llmModel'); if (!sel) return; sel.innerHTML = ''; arr.forEach(n => { const o = document.createElement('option'); o.value = n; o.textContent = n; sel.appendChild(o) });
                    if (arr.length) { CFG.llm.model = (CFG.llm.model && arr.includes(CFG.llm.model)) ? CFG.llm.model : arr[0]; sel.value = CFG.llm.model; saveCFG(); log('[llm] models ok') }
                } catch (e) { log('[llm] tags ' + e.message) }
            },

            setState(txt, cls = 'ok') { const s = qs('#llmState'); const d = qs('#llmDot'); if (s) s.textContent = txt; if (d) d.className = 'dot ' + (cls === 'ok' ? 'ok' : cls === 'err' ? 'err' : 'warn') },

            async onPrompt(nodeId, payload) {
                const n = Graph.getNode(nodeId); if (!n) return;
                const c = n.config || {};

                // per-node first, fall back to legacy keys, then global CFG
                const base = (c.llmBase ?? c.base ?? CFG.llm?.base ?? '').trim();
                const api = (c.llmApi ?? c.api ?? CFG.llm?.api ?? '').trim();
                const relay = (c.llmRelay ?? c.relay ?? CFG.llm?.relay ?? '').trim();
                const model = (c.llmModel ?? c.model ?? CFG.llm?.model ?? '').trim();

                // per-node system toggle/text (transient; doesn’t mutate memory)
                const sysUse = (c.llmUseSystem ?? c.useSystem) === 'true';
                const sysTxt = (c.llmSystem ?? c.system ?? '').trim();

                const text = String(payload && (payload.text ?? payload.prompt ?? payload) || '');
                const viaNkn = CFG.transport === 'nkn';
                const stream = (c.llmStream ?? c.stream ?? 'true') === 'true';

                // build messages from global UI/memory, then overlay per-node system if provided
                let messages = this._buildMessages(text);
                if (sysUse && sysTxt) {
                    if (messages.length && messages[0].role === 'system') messages[0] = { role: 'system', content: sysTxt };
                    else messages.unshift({ role: 'system', content: sysTxt });
                }

                // remember user text for memory persistence after completion
                this._lastUserText = text;

                // ensure a live token window exists (no-op if the card isn't open)
                let out = qs('#llmTokens');
                if (!out) {
                    const card = document.querySelector('#llmCard .body');
                    if (card) {
                        out = document.createElement('pre');
                        out.id = 'llmTokens';
                        out.className = 'tokenStream';
                        out.style.cssText = 'min-height:70px;max-height:140px;overflow:auto;background:rgba(0,0,0,.35);padding:6px;border-radius:6px;white-space:pre-wrap;';
                        card.appendChild(out);
                    }
                }
                if (out) out.textContent = '';

                // stats + UI
                let full = '';
                let tok = 0;
                let bytes = 0;
                const t0 = performance.now();
                const upd = () => {
                    const t = qs('#llmTok'); if (t) t.textContent = String(tok);
                    const b = qs('#llmBytes'); if (b) b.textContent = String(bytes);
                    const m = qs('#llmMs'); if (m) m.textContent = String(Math.round(performance.now() - t0)) + 'ms';
                };

                // emitters (canonical per-node wires + legacy bus)
                const emitDelta = (txt) => {
                    Router.sendFrom(nodeId, 'delta', { nodeId, type: 'text', text: txt });
                    Router.send('llm:delta', { nodeId, type: 'text', text: txt }); // legacy
                };
                const emitSentence = (s) => {
                    Router.sendFrom(nodeId, 'final', { nodeId, text: s, eos: true });
                    Router.send('llm:final', { nodeId, text: s, eos: true });     // legacy
                };

                // per-chunk handler
                const handleLine = (ln) => {
                    try {
                        const obj = JSON.parse(ln);

                        // common streaming fields
                        let delta =
                            (obj.message && typeof obj.message.content === 'string' && obj.message.content) ||
                            (typeof obj.response === 'string' && obj.response) ||
                            (typeof obj.delta === 'string' && obj.delta) || '';

                        // terminal fallbacks
                        if (!delta && (obj.done || obj.complete) && typeof obj.final === 'string') {
                            delta = obj.final;
                        }
                        if (!delta && (obj.done || obj.complete) && obj.message && typeof obj.message.content === 'string') {
                            delta = obj.message.content;
                        }

                        if (delta) {
                            const clean = stripEOT(delta);
                            full += clean;
                            if (out) { out.textContent += clean; out.scrollTop = out.scrollHeight; }
                            tok += (clean.match(/\S+/g) || []).length;
                            bytes += clean.length;
                            upd();
                            SentenceMux.pushDelta(clean, emitSentence);
                            emitDelta(clean);
                        }
                    } catch {
                        // ignore mid-JSON fragments — NDJSON pump will deliver whole objects
                    }
                };

                try {
                    if (stream) {
                        this.setState('streaming', 'warn'); upd();
                        const pump = makeNdjsonPump(handleLine);

                        if (viaNkn) {
                            const order = makeSeqAligner(line => pump.push(line + '\n'));
                            await Net.nknStream({
                                url: base.replace(/\/+$/, '') + '/api/chat',
                                method: 'POST',
                                headers: Net.auth({ 'X-Relay-Stream': 'chunks', 'Accept': 'application/x-ndjson' }, api),
                                json: { model, messages, stream: true },
                                timeout_ms: 180000
                            }, relay, {
                                onBegin: () => { this.setState('stream open', 'warn'); },
                                onLine: (line, seq) => order.push(line, seq),
                                onChunk: (u8) => pump.push(u8),
                                onEnd: (m) => {
                                    order.end(m && (m.last_seq | 0));
                                    pump.flush();
                                    SentenceMux.flush(emitSentence);
                                    this.setState('done', 'ok');
                                    const finalText = stripEOT(full || '');
                                    this._rememberTurn(this._lastUserText, finalText);
                                }
                            }, 180000);
                        } else {
                            const r = await fetch(base.replace(/\/+$/, '') + '/api/chat', {
                                method: 'POST',
                                headers: Net.auth({ 'Accept': 'application/x-ndjson', 'Content-Type': 'application/json' }, api),
                                body: JSON.stringify({ model, messages, stream: true })
                            });
                            if (!r.ok || !r.body) throw new Error(`${r.status} ${r.statusText}`);
                            const reader = r.body.getReader();
                            while (true) {
                                const { value, done } = await reader.read();
                                if (done) break;
                                if (value && value.byteLength) pump.push(value);
                            }
                            pump.flush();
                            SentenceMux.flush(emitSentence);
                            this.setState('done', 'ok');
                            const finalText = stripEOT(full || '');
                            this._rememberTurn(this._lastUserText, finalText);
                        }
                    } else {
                        // one-shot
                        const data = await Net.postJSON(
                            base, '/api/chat',
                            { model, messages, stream: false },
                            api, viaNkn, relay, 120000
                        );
                        full = stripEOT((data?.message?.content) || (data?.response) || '');
                        const finalText = full || '';
                        tok = (finalText.match(/\S+/g) || []).length; bytes = finalText.length; upd();

                        // show in token window if present
                        const outEl = qs('#llmTokens'); if (outEl) outEl.textContent = finalText;

                        this.setState('done', 'ok');

                        // reuse the same sentence mux path so ports get identical events
                        SentenceMux.pushDelta(finalText + '\n', emitSentence);
                        SentenceMux.flush(emitSentence);

                        this._rememberTurn(this._lastUserText, finalText);
                    }
                } catch (e) {
                    this.setState('error', 'err');
                    log('[llm] ' + e.message);
                }
            }

        };

        /* ======== TTS ======== */
        const TTS = {
            models: [], lastOk: 0, timer: null, slow: 180000, fast: 30000,

            async _probeVoices() {
                const viaNkn = CFG.transport === 'nkn', base = CFG.tts.base, relay = CFG.tts.relay, api = CFG.tts.api;
                const paths = ['/voices', '/models', '/api/voices', '/api/models'];
                const normalize = (data) => {
                    const pick = (arr) => arr.map(v => {
                        if (typeof v === 'string') return v;
                        if (v && typeof v === 'object') { return v.name || v.model || v.id || v.voice || '' }
                        return '';
                    }).filter(Boolean);
                    if (Array.isArray(data)) return pick(data);
                    if (!data || typeof data !== 'object') return [];
                    if (Array.isArray(data.voices)) return pick(data.voices);
                    if (Array.isArray(data.models)) return pick(data.models);
                    if (Array.isArray(data.items)) return pick(data.items);
                    if (data.data && Array.isArray(data.data)) return pick(data.data);
                    return [];
                };
                for (const p of paths) {
                    try {
                        const resp = await Net.getJSON(base, p, api, viaNkn, relay);
                        const arr = normalize(resp);
                        if (arr.length) return arr;
                    } catch { }
                }
                return [];
            },

            _timer: null,
            _slow: 180000,
            _fast: 30000,

            async refreshModels() {
                try {
                    const arr = await this._probeVoices();
                    this.models = arr;

                    const dl = qs('#ttsModelList');
                    if (dl) {
                        const prev = (qs('#ttsModel')?.value || '').trim();
                        dl.innerHTML = '';
                        arr.forEach(n => { const o = document.createElement('option'); o.value = n; dl.appendChild(o) });

                        const want = (CFG.tts.model && arr.includes(CFG.tts.model)) ? CFG.tts.model
                            : (prev && arr.includes(prev)) ? prev
                                : (arr[0] || '');
                        CFG.tts.model = want;
                        const inp = qs('#ttsModel'); if (inp) inp.value = want;
                        saveCFG();
                    }
                } catch (e) {
                    log('[tts] voices ' + (e?.message || e));
                } finally {
                    clearTimeout(this._timer);
                    const ok = (qs('#ttsModelList')?.options?.length || 0) > 0;
                    this._timer = setTimeout(() => this.refreshModels(), ok ? this._slow : this._fast);
                }
            },
            setState(txt, cls = 'ok') { const s = qs('#ttsState'); const d = qs('#ttsDot'); if (s) s.textContent = txt; if (d) d.className = 'dot ' + (cls === 'ok' ? 'ok' : cls === 'err' ? 'err' : 'warn') },

            _ac: null, _node: null, _q: [], _queued: 0, _underruns: 0, _sr: 22050,

            // Text FIFO to enforce strict sentence ordering
            _textQ: [],
            _busy: false,

            ensureAC() {
                if (this._ac) return this._ac;
                this._ac = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 22050 });
                this._sr = this._ac.sampleRate || 22050; const ac = qs('#ttsAC'); if (ac) ac.textContent = this._sr + 'Hz';
                const n = this._node = this._ac.createScriptProcessor(4096, 1, 1);
                n.onaudioprocess = (e) => {
                    const out = e.outputBuffer.getChannelData(0);
                    if (!this._q.length) { out.fill(0); this._underruns++; const u = qs('#ttsUrun'); if (u) u.textContent = String(this._underruns); return }
                    let need = out.length, off = 0;
                    while (need > 0) {
                        if (!this._q.length) { out.fill(0, off); this._underruns++; const u = qs('#ttsUrun'); if (u) u.textContent = String(this._underruns); break }
                        const head = this._q[0]; const take = Math.min(need, head.length);
                        out.set(head.subarray(0, take), off);
                        if (take === head.length) this._q.shift(); else this._q[0] = head.subarray(take);
                        this._queued -= take; off += take; need -= take;
                    }
                    const tb = qs('#ttsBuf'); if (tb) tb.textContent = String(this._queued);
                    const tbm = qs('#ttsBufMs'); if (tbm) tbm.textContent = String(Math.round(this._queued / this._sr * 1000));
                };
                n.connect(this._ac.destination);
                return this._ac;
            },
            int16ToF32(int16) { const f = new Float32Array(int16.length); for (let i = 0; i < int16.length; i++) f[i] = Math.max(-1, Math.min(1, int16[i] / 32768)); return f },
            enqueueF32(f) { this._q.push(f); this._queued += f.length; const tb = qs('#ttsBuf'); if (tb) tb.textContent = String(this._queued); const tbm = qs('#ttsBufMs'); if (tbm) tbm.textContent = String(Math.round(this._queued / this._sr * 1000)); },
            resampleLinear(input, fromRate, toRate) {
                if (fromRate === toRate) return input;
                const ratio = toRate / fromRate;
                const L = Math.round(input.length * ratio);
                const out = new Float32Array(L);
                for (let i = 0; i < L; i++) {
                    const pos = i / ratio;
                    const i0 = Math.floor(pos);
                    const i1 = Math.min(i0 + 1, input.length - 1);
                    const t = pos - i0;
                    out[i] = input[i0] * (1 - t) + input[i1] * t;
                }
                return out;
            },

            // simple sentence buffer / dedupe
            _ingressCarry: '', _lastSentences: [],
            _splitComplete(buf) {
                const closes = `"'’”)]`; const isClose = c => closes.includes(c); const isWS = c => /\s/.test(c || '');
                const out = []; let start = 0, i = 0;
                while (i < buf.length) {
                    const ch = buf[i];
                    if ('.!?;:…'.includes(ch)) {
                        let j = i + 1; while (j < buf.length && isClose(buf[j])) j++;
                        if (j >= buf.length || isWS(buf[j])) {
                            const sent = buf.slice(start, j).trim();
                            if (sent) out.push(sent);
                            while (j < buf.length && isWS(buf[j])) j++;
                            start = j; i = j; continue;
                        }
                    }
                    i++;
                }
                return { complete: out, rest: buf.slice(start) };
            },
            _seenRecently(s) {
                const key = s.slice(0, 120);
                const hit = this._lastSentences.includes(key);
                if (!hit) { this._lastSentences.push(key); if (this._lastSentences.length > 8) this._lastSentences.shift(); }
                return hit;
            },


            // ─────────────────────────────────────────────────────────────
            // NEW: punctuation/symbol scrubber (runs just before synth)
            // ─────────────────────────────────────────────────────────────
            _sanitizeForTTS(s) {
                if (!s) return '';
                try { s = s.normalize('NFKC'); } catch { }
                s = s.replace(/[\u2019\u2018]/g, "'"); // ’ ‘ → '
                s = s.replace(/\s*'\s*/g, "'");       // tighten around '
                // light clean only (no whitespace removal inside words)
                s = s.replace(/\bhttps?:\/\/\S+/gi, ' ');
                s = s.replace(/[*_~`]+/g, ' ');
                s = s.replace(/\u2026/g, '.').replace(/\.{3,}/g, '.');
                s = s.replace(/[“”"«»‹›„‟]/g, ' ');
                s = s.replace(/[\[\](){}<>]/g, ' ');
                // keep . , ? ! to preserve prosody
                return s.replace(/[^\S\r\n]+/g, ' ').replace(/\s*([.,?!])\s*/g, '$1 ').trim();
            },



            async onText(payload) {
                const raw = (payload && (payload.text || payload)) || '';
                const eos = !!(payload && payload.eos);
                const piece = String(raw);
                if (!piece) return;

                const combined = (this._ingressCarry || '') + piece;

                const { complete, rest } = this._splitComplete(combined);
                this._ingressCarry = rest;

                for (const s of complete) { if (!this._seenRecently(s)) this._textQ.push(s); }
                if (eos) { const tail = this._ingressCarry.trim(); if (tail && !this._seenRecently(tail)) this._textQ.push(tail); this._ingressCarry = ''; }
                if (complete.length || eos) this._pumpQueue().catch(() => { });
            },

            async _pumpQueue() {
                if (this._busy) return;
                this._busy = true;
                try {
                    while (this._textQ.length) {
                        const nextText = this._textQ.shift();
                        await this._speakOne(nextText);
                        this.enqueueF32(new Float32Array(Math.round((this._sr || 22050) * 0.03)));
                    }
                } finally { this._busy = false; }
            },

            async _speakOne(text) {
                // sanitize here — AFTER sentence concatenation, BEFORE synth
                const clean = this._sanitizeForTTS(text);
                console.log(clean);
                if (!clean) return;

                const mode = qs('#ttsMode')?.value || 'stream';
                const model = (qs('#ttsModel')?.value || CFG.tts.model || '').trim();
                const viaNkn = CFG.transport === 'nkn';
                const base = CFG.tts.base;
                const relay = CFG.tts.relay;
                const api = CFG.tts.api;

                const a = qs('#ttsAudio');
                this._underruns = 0; const ur = qs('#ttsUrun'); if (ur) ur.textContent = '0';

                if (mode === 'stream') {
                    this.setState('streaming…', 'warn');
                    this.ensureAC(); await this._ac.resume();

                    const preroll = Math.round((this._sr || 22050) * 0.04);
                    if (preroll > 0) this.enqueueF32(new Float32Array(preroll));

                    const req = { text: clean, mode: 'stream', format: 'raw', ...(model ? { model, voice: model } : {}) };
                    let chunks = 0, bytes = 0;
                    const ch = qs('#ttsChunks'); const by = qs('#ttsBytes');
                    let leftover = new Uint8Array(0);
                    const sinkRate = this._sr || 22050;

                    const handleBytes = (u8) => {
                        const merged = new Uint8Array(leftover.length + u8.length);
                        merged.set(leftover, 0); merged.set(u8, leftover.length);
                        const even = (merged.length >> 1) << 1;
                        const body = merged.subarray(0, even);
                        leftover = merged.subarray(even);
                        if (!body.length) return;

                        const frames = body.length >> 1;
                        const dv = new DataView(body.buffer, body.byteOffset, body.length);
                        const i16 = new Int16Array(frames);
                        for (let i = 0; i < frames; i++) i16[i] = dv.getInt16(i * 2, true);

                        let f32 = this.int16ToF32(i16);
                        if (sinkRate !== 22050) f32 = this.resampleLinear(f32, 22050, sinkRate);
                        this.enqueueF32(f32);

                        chunks++; bytes += u8.length;
                        if (ch) ch.textContent = String(chunks);
                        if (by) by.textContent = String(bytes);
                    };

                    if (viaNkn) {
                        const spec = {
                            url: base.replace(/\/+$/, '') + '/speak',
                            method: 'POST',
                            headers: Net.auth({ 'X-Relay-Stream': 'chunks' }, api),
                            json: req,
                            timeout_ms: 120000
                        };

                        let expected = null;
                        const stash = new Map();
                        const seen = new Set();
                        const flush = () => { while (expected != null && stash.has(expected)) { const u8 = stash.get(expected); stash.delete(expected); handleBytes(u8); expected++; } };

                        await Net.nknStream(spec, relay, {
                            onBegin: () => { this.setState('stream open', 'warn') },
                            onChunk: (u8, seqRaw) => {
                                const seq = (seqRaw | 0);
                                if (seen.has(seq)) return; seen.add(seq);
                                if (expected == null) expected = seq;
                                if (seq === expected) { handleBytes(u8); expected++; flush(); }
                                else if (seq > expected) stash.set(seq, u8);
                            },
                            onEnd: () => { leftover = new Uint8Array(0); this.setState('ok', 'ok'); }
                        }, 120000);
                    }
                    else {
                        const r = await fetch(base.replace(/\/+$/, '') + '/speak', { method: 'POST', headers: Net.auth({}, api), body: JSON.stringify(req) });
                        if (!r.ok || !r.body) throw new Error(`${r.status} ${r.statusText}`);
                        const rd = r.body.getReader();
                        let httpLeftover = new Uint8Array(0);
                        while (true) {
                            const { value, done } = await rd.read();
                            if (done) break;
                            if (!value || !value.byteLength) continue;

                            const merged = new Uint8Array(httpLeftover.length + value.length);
                            merged.set(httpLeftover, 0); merged.set(value, httpLeftover.length);
                            const even = (merged.length >> 1) << 1;
                            if (even) { handleBytes(merged.subarray(0, even)); httpLeftover = merged.subarray(even); }
                            else { httpLeftover = merged; }
                        }
                        httpLeftover = new Uint8Array(0);
                        this.setState('ok', 'ok');
                    }

                    if (a) a.src = ''; // streaming via WebAudio
                    const tm = qs('#ttsMeta'); if (tm) tm.textContent = `live pcm 16-bit mono 22050Hz → ${sinkRate}Hz`;
                } else {
                    this.setState('synth…', 'warn');
                    try {
                        const data = await Net.postJSON(
                            base, '/speak',
                            { text: clean, mode: 'file', format: 'ogg', ...(model ? { model, voice: model } : {}) },
                            api, CFG.transport === 'nkn', CFG.tts.relay, 10 * 60 * 1000
                        );
                        let blob = null, mime = 'audio/ogg';
                        if (data?.files?.[0]?.url) {
                            const fileUrl = base.replace(/\/+$/, '') + data.files[0].url;
                            blob = await Net.fetchBlob(fileUrl, CFG.transport === 'nkn', CFG.tts.relay, api);
                            mime = blob.type || mime;
                        } else if (data?.audio_b64) {
                            const u8 = b64ToBytes(data.audio_b64);
                            blob = new Blob([u8], { type: mime });
                        } else { throw new Error('no audio'); }

                        if (a) { const url = URL.createObjectURL(blob); a.src = url; a.play().catch(() => { }); }
                        const tm = qs('#ttsMeta'); if (tm) tm.textContent = `${mime} • ${(blob.size / 1024).toFixed(1)} KB`;
                        this.setState('ok', 'ok');
                    } catch (e) { this.setState('error', 'err'); log('[tts] ' + e.message); }
                }
            }
        };


        // ─────────────────────────────────────────────────────────────
        // Graph Editor (drag nodes, gear modal, SVG spline links)
        // ─────────────────────────────────────────────────────────────
        const Graph = (() => {
            const WS = { el: null, svg: null, wires: [], nodes: new Map(), sel: null, portSel: null };

            // ─────────────────────────────────────────────────────────────
            // Card Editor helpers
            // ─────────────────────────────────────────────────────────────
            function hideAllCards() {
                qsa('#asrCard, #llmCard, #ttsCard').forEach(el => {
                    el.classList.add('isHidden');
                    const tb = el.querySelector('.nodePanel');
                    if (tb) tb.remove();
                    el.removeAttribute('data-node-id');
                });
            }

            function syncRouterFromWS() {
                const newWires = WS.wires.map(w => ({
                    from: `${w.from.node}:out:${w.from.port}`,
                    to: `${w.to.node}:in:${w.to.port}`
                }));
                Router.wires = newWires;
                CFG.wires = newWires.slice();
                saveCFG();
                Router.render();
            }

            function attachNodeToolbar(cardEl, nodeId, title) {
                const bar = document.createElement('div');
                bar.className = 'row nodePanel';
                bar.style.margin = '10px 0 4px';
                bar.innerHTML = `
      <button class="secondary">Save to Node</button>
      <button class="ghost">Close</button>
      <span class="muted">Editing ${title} • <b>${nodeId}</b></span>
    `;
                const [btnSave, btnClose] = bar.querySelectorAll('button');
                btnClose.addEventListener('click', hideAllCards);
                btnSave.addEventListener('click', () => { saveCardToNode(nodeId); setBadge('Node settings saved'); });
                const h2 = cardEl.querySelector('h2');
                (h2 && h2.parentNode) ? h2.parentNode.insertBefore(bar, h2.nextSibling) : cardEl.prepend(bar);
            }

            function fillCardFromNode(node) {
                const cfg = node.config || {};
                const setVal = (id, v) => { const el = qs('#' + id); if (el && v !== undefined && v !== null && v !== '') el.value = String(v); };

                if (node.type === 'ASR') {
                    setVal('asrBase', cfg.asrBase ?? cfg.base);
                    setVal('asrRelay', cfg.asrRelay ?? cfg.relay);
                    setVal('asrApi', cfg.asrApi ?? cfg.api);
                    setVal('asrModel', cfg.asrModel ?? cfg.model);
                    setVal('asrMode', cfg.asrMode ?? cfg.mode);
                    setVal('asrPrevWin', cfg.asrPrevWin);
                    setVal('asrPrevStep', cfg.asrPrevStep);
                    setVal('asrPrevModel', cfg.asrPrevModel);
                    setVal('asrRate', cfg.asrRate);
                    setVal('asrChunk', cfg.asrChunk);
                    setVal('asrLive', cfg.asrLive);
                    setVal('asrRms', cfg.asrRms);
                    setVal('asrHold', cfg.asrHold);
                    setVal('asrEmaMs', cfg.asrEmaMs);
                    setVal('asrPhraseOn', cfg.asrPhraseOn);
                    setVal('asrPhraseMin', cfg.asrPhraseMin);
                    setVal('asrPhraseStable', cfg.asrPhraseStable);
                    setVal('asrSilence', cfg.asrSilence);
                    setVal('asrPrompt', cfg.asrPrompt);
                } else if (node.type === 'LLM') {
                    setVal('llmBase', cfg.llmBase ?? cfg.base);
                    setVal('llmRelay', cfg.llmRelay ?? cfg.relay);
                    setVal('llmApi', cfg.llmApi ?? cfg.api);
                    setVal('llmModel', cfg.llmModel ?? cfg.model);
                    setVal('llmStream', cfg.llmStream ?? cfg.stream);
                    setVal('llmUseSystem', cfg.llmUseSystem ?? cfg.useSystem);
                    setVal('llmSystem', cfg.llmSystem ?? cfg.system);
                    setVal('llmMemory', cfg.llmMemory ?? cfg.memoryOn);
                    setVal('llmPersistMemory', cfg.llmPersistMemory ?? cfg.persistMemory);
                    setVal('llmMaxTurns', cfg.llmMaxTurns ?? cfg.maxTurns);
                } else if (node.type === 'TTS') {
                    setVal('ttsBase', cfg.ttsBase ?? cfg.base);
                    setVal('ttsRelay', cfg.ttsRelay ?? cfg.relay);
                    setVal('ttsApi', cfg.ttsApi ?? cfg.api);
                    setVal('ttsModel', cfg.ttsModel ?? cfg.voice ?? cfg.model);
                    setVal('ttsMode', cfg.ttsMode ?? cfg.mode);
                }
            }

            function saveCardToNode(nodeId) {
                const n = WS.nodes.get(nodeId); if (!n) return;
                const cfg = Object.assign({}, n.config || {});
                const getVal = id => { const el = qs('#' + id); return el ? (el.type === 'number' ? Number(el.value) : String(el.value)) : undefined; };

                if (n.type === 'ASR') {
                    Object.assign(cfg, {
                        asrBase: getVal('asrBase'), asrRelay: getVal('asrRelay'), asrApi: getVal('asrApi'),
                        asrModel: getVal('asrModel'), asrMode: getVal('asrMode'),
                        asrPrevWin: getVal('asrPrevWin'), asrPrevStep: getVal('asrPrevStep'), asrPrevModel: getVal('asrPrevModel'),
                        asrRate: Number(getVal('asrRate')), asrChunk: Number(getVal('asrChunk')), asrLive: getVal('asrLive'),
                        asrRms: Number(getVal('asrRms')), asrHold: Number(getVal('asrHold')), asrEmaMs: Number(getVal('asrEmaMs')),
                        asrPhraseOn: getVal('asrPhraseOn'), asrPhraseMin: Number(getVal('asrPhraseMin')),
                        asrPhraseStable: Number(getVal('asrPhraseStable')), asrSilence: Number(getVal('asrSilence')), asrPrompt: getVal('asrPrompt')
                    });
                } else if (n.type === 'LLM') {
                    Object.assign(cfg, {
                        llmBase: getVal('llmBase'), llmRelay: getVal('llmRelay'), llmApi: getVal('llmApi'),
                        llmModel: getVal('llmModel'), llmStream: getVal('llmStream'),
                        llmUseSystem: getVal('llmUseSystem'), llmSystem: getVal('llmSystem'),
                        llmMemory: getVal('llmMemory'), llmPersistMemory: getVal('llmPersistMemory'),
                        llmMaxTurns: Number(getVal('llmMaxTurns'))
                    });
                } else if (n.type === 'TTS') {
                    Object.assign(cfg, {
                        ttsBase: getVal('ttsBase'), ttsRelay: getVal('ttsRelay'), ttsApi: getVal('ttsApi'),
                        ttsModel: getVal('ttsModel'), ttsMode: getVal('ttsMode')
                    });
                }

                n.config = cfg;
                saveGraph();
                closeSettings();
                setBadge('Settings saved');

                if (n.type === 'LLM' && (cfg.llmSystem ?? cfg.system) != null) {
                    LLM.onSystem(n.id, { text: (cfg.llmSystem ?? cfg.system) });
                }
            }

            function openNodeCard(nodeId) {
                const n = WS.nodes.get(nodeId); if (!n) return;
                hideAllCards();

                const map = { ASR: '#asrCard', LLM: '#llmCard', TTS: '#ttsCard' };
                const sel = map[n.type];
                const card = sel ? qs(sel) : null;
                if (!card) return;

                card.dataset.nodeId = nodeId;
                card.classList.remove('isHidden');

                if (n.type === 'ASR') ASR.activeNodeId = n.id;

                if (n.type === 'ASR') {
                    const mini = document.createElement('div');
                    mini.className = 'row';
                    mini.style.marginTop = '8px';
                    mini.innerHTML = `
        <button class="gear asrPlay" title="Start/Stop">▶</button>
        <div class="vu" data-asr-vu="${n.id}" style="flex:1"><b></b></div>
      `;
                    card.querySelector('.body').appendChild(mini);
                    const btn = mini.querySelector('.asrPlay');
                    const setGlyph = () => { btn.textContent = ASR.running ? '■' : '▶'; };
                    setGlyph();
                    btn.addEventListener('click', () => {
                        if (ASR.running) {
                            if (ASR.activeNodeId === n.id) { ASR.stop(); ASR.activeNodeId = null; }
                            else { ASR.activeNodeId = n.id; setBadge(`Mic now owned by ${n.id}`); }
                        } else { ASR.activeNodeId = n.id; ASR.start(); }
                        setTimeout(setGlyph, 0);
                    });
                }

                if (n.type === 'LLM') {
                    const body = card.querySelector('.body');
                    if (body && !card.querySelector('#llmTokens')) {
                        const pre = document.createElement('pre');
                        pre.id = 'llmTokens';
                        pre.className = 'tokenStream';
                        pre.style.cssText = 'min-height:70px;max-height:140px;overflow:auto;background:rgba(0,0,0,.35);padding:6px;border-radius:6px;white-space:pre-wrap;';
                        body.appendChild(pre);
                    }
                    const out = card.querySelector('#llmTokens'); if (out) out.textContent = '';
                }

                attachNodeToolbar(card, nodeId, TYPES[n.type].title);

                // Per-card status dots
                if (!card.querySelector(`[data-card-status="${n.id}"]`)) {
                    const row = document.createElement('div');
                    row.className = 'row';
                    row.dataset.cardStatus = n.id;
                    row.style.cssText = 'gap:10px;margin:8px 0;align-items:center;';
                    row.innerHTML = `
        <span title="NKN"><span class="dot err" id="cardNknDot-${n.id}"></span>NKN</span>
        <span title="${n.type} service"><span class="dot err" id="card${n.type}SvcDot-${n.id}"></span>${n.type}</span>
      `;
                    const body = card.querySelector('.body');
                    card.insertBefore(row, body);
                }
                if (window.Status && Status.refreshForNode) Status.refreshForNode(n, 'card');

                fillCardFromNode(n);
            }

            // ─────────────────────────────────────────────────────────────
            // Node type registry
            // ─────────────────────────────────────────────────────────────
            const TYPES = {
                ASR: {
                    title: 'ASR',
                    inputs: [],
                    outputs: [
                        { name: 'partial', wireKey: 'asr:partial' },
                        { name: 'phrase', wireKey: 'asr:phrase' },
                        { name: 'final', wireKey: 'asr:final' }
                    ],
                    schema: [
                        { key: 'base', label: 'Base URL', type: 'text', placeholder: 'http://localhost:8126', def: CFG.asr?.base || '' },
                        { key: 'relay', label: 'NKN Relay', type: 'text', def: CFG.asr?.relay || '' },
                        { key: 'api', label: 'API Key', type: 'text', def: CFG.asr?.api || '' },
                        { key: 'model', label: 'Model', type: 'text', def: CFG.asr?.model || '' },
                        { key: 'mode', label: 'ASR Mode', type: 'select', options: ['fast', 'accurate'], def: CFG.asr?.mode || 'fast' }
                    ]
                },
                LLM: {
                    title: 'LLM',
                    inputs: [
                        { name: 'prompt', wireKey: 'llm:prompt' },
                        { name: 'system', wireKey: 'llm:system' }
                    ],
                    outputs: [
                        { name: 'delta', wireKey: 'llm:delta' },
                        { name: 'final', wireKey: 'llm:final' },
                        { name: 'memory', wireKey: 'llm:memory' } // ← NEW: wire out memory
                    ],
                    schema: [
                        { key: 'base', label: 'Base URL', type: 'text', placeholder: 'http://127.0.0.1:11434', def: CFG.llm?.base || '' },
                        { key: 'relay', label: 'NKN Relay', type: 'text', def: CFG.llm?.relay || '' },
                        { key: 'api', label: 'API Key', type: 'text', def: CFG.llm?.api || '' },
                        { key: 'model', label: 'Model', type: 'text', def: CFG.llm?.model || '' },
                        { key: 'stream', label: 'Stream', type: 'select', options: ['true', 'false'], def: String(!!CFG.llm?.stream) },
                        { key: 'system', label: 'System Prompt', type: 'textarea', def: '' }
                    ]
                },
                TTS: {
                    title: 'TTS',
                    inputs: [{ name: 'text', wireKey: 'tts:text' }],
                    outputs: [],
                    schema: [
                        { key: 'base', label: 'Base URL', type: 'text', placeholder: 'http://localhost:8123', def: CFG.tts?.base || '' },
                        { key: 'relay', label: 'NKN Relay', type: 'text', def: CFG.tts?.relay || '' },
                        { key: 'api', label: 'API Key', type: 'text', def: CFG.tts?.api || '' },
                        { key: 'voice', label: 'Voice', type: 'text', def: CFG.tts?.model || '' },
                        { key: 'mode', label: 'Mode', type: 'select', options: ['stream', 'file'], def: CFG.tts?.mode || 'stream' }
                    ]
                }
            };

            const uid = () => 'n' + Math.random().toString(36).slice(2, 8);
            function getSettingsNodeId() { return (document.querySelector('#settingsModal')?.dataset?.nodeId) || null; }
            function readFormKV(formEl) { const fd = new FormData(formEl); const cfg = {}; fd.forEach((v, k) => cfg[k] = String(v)); return cfg; }

            // ─────────────────────────────────────────────────────────────
            // Wire removal helpers
            // ─────────────────────────────────────────────────────────────
            function removeWireById(id) {
                const w = WS.wires.find(x => x.id === id);
                if (!w) return;
                w.path?.remove();
                WS.wires = WS.wires.filter(x => x !== w);
                syncRouterFromWS();
                saveGraph();
                drawAllLinks();
                setBadge('Wire removed');
            }

            function removeWiresAt(nodeId, side, portName) {
                const toRemove = WS.wires.filter(w =>
                    (side === 'out' && w.from.node === nodeId && w.from.port === portName) ||
                    (side === 'in' && w.to.node === nodeId && w.to.port === portName)
                );
                toRemove.forEach(w => w.path?.remove());
                WS.wires = WS.wires.filter(w => !toRemove.includes(w));
                syncRouterFromWS();
                saveGraph();
                drawAllLinks();
                setBadge(`Disconnected ${toRemove.length} link(s) on ${nodeId}:${side}:${portName}`);
            }

            // ─────────────────────────────────────────────────────────────
            // Node DOM
            // ─────────────────────────────────────────────────────────────
            function makeNodeEl(node) {
                const t = TYPES[node.type];
                const el = document.createElement('div');
                el.className = 'node';
                el.style.left = (node.x || 60) + 'px';
                el.style.top = (node.y || 60) + 'px';
                el.dataset.id = node.id;

                el.innerHTML = `
      <div class="head">
        <div class="title">${t.title}</div>
        <div class="row" style="gap:6px;">
          <button class="gear" title="Settings">⚙</button>
          <button class="gear" title="Remove">🗑</button>
        </div>
      </div>
      <div class="body">
        <div class="ports">
          <div class="side left"></div>
          <div class="side right"></div>
        </div>
      </div>
    `;

                // ASR mini toolbar + VU on the node
                if (node.type === 'ASR') {
                    const mini = document.createElement('div');
                    mini.className = 'row';
                    mini.style.marginTop = '8px';
                    mini.innerHTML = `
        <button class="gear asrPlay" title="Start/Stop">▶</button>
        <div class="vu" data-asr-vu="${node.id}" style="flex:1"><b></b></div>
      `;
                    el.querySelector('.body').appendChild(mini);
                    const btn = mini.querySelector('.asrPlay');
                    const setGlyph = () => { btn.textContent = ASR.running && ASR.activeNodeId === node.id ? '■' : '▶'; };
                    setGlyph();
                    btn.addEventListener('click', () => {
                        ASR.activeNodeId = node.id;
                        if (ASR.running && ASR.activeNodeId === node.id) { ASR.stop(); }
                        else if (ASR.running && ASR.activeNodeId !== node.id) { setBadge(`Mic now owned by ${node.id}`); ASR.stop(); setTimeout(() => ASR.start(), 0); }
                        else { ASR.start(); }
                        setTimeout(setGlyph, 0);
                    });
                }

                // Per-node status dots
                const stat = document.createElement('div');
                stat.className = 'row miniStatus';
                stat.dataset.nodeStatus = node.id;
                stat.style.cssText = 'gap:8px;margin-top:6px;align-items:center;';
                stat.innerHTML = `
      <span title="NKN"><span class="dot err" id="nknDot-${node.id}"></span>NKN</span>
      <span title="${node.type} service"><span class="dot err" id="${node.type.toLowerCase()}SvcDot-${node.id}"></span>${node.type}</span>
    `;
                el.querySelector('.body').appendChild(stat);
                if (window.Status && Status.refreshForNode) Status.refreshForNode(node, 'node');

                // Ports
                const left = el.querySelector('.side.left');
                const right = el.querySelector('.side.right');

                for (const p of t.inputs) {
                    const r = document.createElement('div');
                    r.className = 'wp-port in';
                    r.dataset.port = p.name;
                    r.title = `${p.name} (Alt-click to disconnect)`;
                    r.innerHTML = `<span class="dot"></span><span>${p.name}</span>`;
                    r.addEventListener('click', (ev) => {
                        if (ev.altKey || ev.metaKey || ev.ctrlKey) { removeWiresAt(node.id, 'in', p.name); return; }
                        onPortClick(node.id, 'in', p.name, r);
                    });
                    left.appendChild(r);

                    Router.register(`${node.id}:in:${p.name}`, r, (payload) => {
                        if (node.type === 'LLM') {
                            if (p.name === 'prompt') return LLM.onPrompt(node.id, payload);
                            if (p.name === 'system') return LLM.onSystem(node.id, payload);
                        } else if (node.type === 'TTS') {
                            if (p.name === 'text') return TTS.onText(payload);
                        }
                    });
                }

                for (const p of t.outputs) {
                    const r = document.createElement('div');
                    r.className = 'wp-port out';
                    r.dataset.port = p.name;
                    r.title = `${p.name} (Alt-click to disconnect)`;
                    r.innerHTML = `<span>${p.name}</span><span class="dot"></span>`;
                    r.addEventListener('click', (ev) => {
                        if (ev.altKey || ev.metaKey || ev.ctrlKey) { removeWiresAt(node.id, 'out', p.name); return; }
                        onPortClick(node.id, 'out', p.name, r);
                    });
                    right.appendChild(r);
                }

                // Dragging
                const head = el.querySelector('.head');
                let drag = null;
                head.addEventListener('pointerdown', (e) => {
                    if (e.target.closest('button')) return;
                    drag = { dx: e.clientX - el.offsetLeft, dy: e.clientY - el.offsetTop };
                    head.setPointerCapture(e.pointerId);
                });
                head.addEventListener('pointermove', (e) => {
                    if (!drag) return;
                    const gx = Math.round((e.clientX - drag.dx) / 14) * 14;
                    const gy = Math.round((e.clientY - drag.dy) / 14) * 14;
                    el.style.left = gx + 'px';
                    el.style.top = gy + 'px';
                    node.x = gx; node.y = gy;
                    drawAllLinks();
                });
                head.addEventListener('pointerup', () => { drag = null; saveGraph(); });

                // Gear + delete
                const [btnGear, btnDel] = el.querySelectorAll('.gear');
                btnGear.addEventListener('click', () => {
                    const modal = document.querySelector('#settingsModal');
                    if (modal && !modal.classList.contains('hidden')) {
                        const openId = getSettingsNodeId();
                        if (openId && WS.nodes.has(openId)) {
                            const openNode = WS.nodes.get(openId);
                            const form = document.querySelector('#settingsForm');
                            if (form) { openNode.config = readFormKV(form); saveGraph(); }
                        }
                    }
                    openSettings(node.id);
                });
                btnDel.addEventListener('click', () => removeNode(node.id));

                return el;
            }

            // ─────────────────────────────────────────────────────────────
            // Wire linking
            // ─────────────────────────────────────────────────────────────
            function onPortClick(nodeId, side, portName, el) {
                if (!WS.portSel) {
                    if (side !== 'out') { setBadge('Pick an output first', false); return; }
                    WS.portSel = { nodeId, side, portName, el };
                    el.classList.add('sel');
                    return;
                }
                if (side !== 'in') { setBadge('Connect to an input port', false); return; }
                if (nodeId === WS.portSel.nodeId) { setBadge('Cannot self-link', false); return; }

                addLink(WS.portSel.nodeId, WS.portSel.portName, nodeId, portName);
                WS.portSel.el.classList.remove('sel');
                WS.portSel = null;
            }

            function addLink(fromNodeId, fromPort, toNodeId, toPort) {
                if (WS.wires.find(w => w.from.node === fromNodeId && w.from.port === fromPort && w.to.node === toNodeId && w.to.port === toPort)) return;

                const w = { id: uid(), from: { node: fromNodeId, port: fromPort }, to: { node: toNodeId, port: toPort }, path: null };
                WS.wires.push(w);

                const p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                p.setAttribute('fill', 'none');
                p.setAttribute('stroke', 'rgba(255,255,255,.7)');
                p.setAttribute('stroke-width', '2');
                p.setAttribute('stroke-linecap', 'round');
                p.setAttribute('opacity', '0.95');
                p.dataset.id = w.id;

                // Remove the wire: Alt/Meta/Ctrl click or double-click
                const kill = (e) => { removeWireById(w.id); e.stopPropagation(); };
                p.addEventListener('click', (e) => { if (e.altKey || e.metaKey || e.ctrlKey) kill(e); });
                p.addEventListener('dblclick', kill);

                WS.svg.appendChild(p);
                w.path = p;

                const fk = `${fromNodeId}:out:${fromPort}`;
                const tk = `${toNodeId}:in:${toPort}`;
                if (!Router.wires.find(x => x.from === fk && x.to === tk)) {
                    Router.wires.push({ from: fk, to: tk });
                    CFG.wires = Router.wires.slice(); saveCFG(); Router.render();
                    log(`wired ${fk} → ${tk}`);
                }

                drawAllLinks(); saveGraph();
            }

            function portCenter(nodeId, side, portName) {
                const n = WS.nodes.get(nodeId); if (!n) return { x: 0, y: 0 };
                const dot = n.el.querySelector(`.wp-port.${side}[data-port="${CSS.escape(portName)}"] .dot`);
                if (!dot) return { x: 0, y: 0 };
                const r = dot.getBoundingClientRect();
                const ws = WS.el.getBoundingClientRect();
                return { x: r.left - ws.left + r.width / 2, y: r.top - ws.top + r.height / 2 };
            }

            function drawLink(w) {
                const a = portCenter(w.from.node, 'out', w.from.port);
                const b = portCenter(w.to.node, 'in', w.to.port);
                const dx = Math.max(40, Math.abs(b.x - a.x) * 0.5);
                const d = `M ${a.x},${a.y} C ${a.x + dx},${a.y} ${b.x - dx},${b.y} ${b.x},${b.y}`;
                w.path.setAttribute('d', d);
            }
            function drawAllLinks() { for (const w of WS.wires) drawLink(w); }

            // ─────────────────────────────────────────────────────────────
            // Settings modal
            // ─────────────────────────────────────────────────────────────
            function openSettings(nodeId) {
                const n = WS.nodes.get(nodeId); if (!n) return;
                const modal = qs('#settingsModal');
                const slot = qs('#settingsSlot');
                const hint = qs('#settingsHint');

                const map = { ASR: '#asrCard', LLM: '#llmCard', TTS: '#ttsCard' };
                const sel = map[n.type];
                const card = sel ? qs(sel) : null;
                if (!card || !slot || !modal) return;

                fillCardFromNode(n);

                const ph = document.createElement('div');
                ph.id = card.id + '-ph';
                ph.style.display = 'none';
                card.parentNode.insertBefore(ph, card);

                slot.innerHTML = '';
                slot.appendChild(card);
                card.classList.remove('isHidden');
                card.style.removeProperty('display');

                modal.dataset.nodeId = nodeId;
                modal.dataset.placeholderId = ph.id;
                hint.textContent = `${TYPES[n.type].title} • ${nodeId}`;
                modal.classList.remove('hidden');
            }

            function closeSettings() {
                const modal = qs('#settingsModal');
                const slot = qs('#settingsSlot');
                if (!modal || !slot) return;
                const phId = modal.dataset.placeholderId;
                const ph = phId ? qs('#' + phId) : null;
                const card = slot.firstElementChild;
                if (ph && ph.parentNode && card) {
                    ph.parentNode.replaceChild(card, ph);
                    card.classList.add('isHidden');
                    card.style.display = 'none';
                } else if (ph) { ph.remove(); }
                delete modal.dataset.nodeId;
                delete modal.dataset.placeholderId;
                modal.classList.add('hidden');
            }

            function bindModal() {
                qs('#closeSettings')?.addEventListener('click', closeSettings);
                qs('#cancelSettings')?.addEventListener('click', closeSettings);
                qs('#saveSettings')?.addEventListener('click', (e) => {
                    e.preventDefault();
                    const nodeId = qs('#settingsModal')?.dataset?.nodeId;
                    if (nodeId) { saveCardToNode(nodeId); setBadge('Settings saved'); }
                });
            }

            function removeNode(nodeId) {
                const n = WS.nodes.get(nodeId); if (!n) return;
                WS.wires.slice().forEach(w => {
                    if (w.from.node === nodeId || w.to.node === nodeId) {
                        w.path?.remove();
                        WS.wires = WS.wires.filter(x => x !== w);
                    }
                });
                n.el.remove();
                WS.nodes.delete(nodeId);
                syncRouterFromWS();
                saveGraph();
                drawAllLinks();
            }

            // ─────────────────────────────────────────────────────────────
            // Persistence
            // ─────────────────────────────────────────────────────────────
            function saveGraph() {
                const data = {
                    nodes: Array.from(WS.nodes.values()).map(n => ({ id: n.id, type: n.type, x: n.x, y: n.y, config: n.config || {} })),
                    links: WS.wires.map(w => ({ from: w.from, to: w.to }))
                };
                LS.set('graph.workspace', data);
            }

            function loadGraph() {
                const data = LS.get('graph.workspace', null);
                if (!data) return;
                WS.el.innerHTML = '';
                WS.svg.innerHTML = '';
                WS.nodes.clear();
                WS.wires = [];
                for (const n of data.nodes) {
                    const node = { id: n.id, type: n.type, x: n.x, y: n.y, config: n.config || {} };
                    node.el = makeNodeEl(node);
                    WS.el.appendChild(node.el);
                    WS.nodes.set(node.id, node);
                }
                for (const l of data.links) addLink(l.from.node, l.from.port, l.to.node, l.to.port);
                drawAllLinks();
            }

            // ─────────────────────────────────────────────────────────────
            // Toolbar / boot
            // ─────────────────────────────────────────────────────────────
            function addNode(type, x = 70, y = 70) {
                const id = uid();
                const n = { id, type, x, y, config: {} };
                n.el = makeNodeEl(n);
                WS.el.appendChild(n.el);
                WS.nodes.set(id, n);
                saveGraph();
                drawAllLinks();
                return n;
            }

            function exportGraph() {
                const data = LS.get('graph.workspace', { nodes: [], links: [] });
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'realtime-graph.json'; a.click();
                URL.revokeObjectURL(url);
            }

            function importGraph() {
                const inp = document.createElement('input'); inp.type = 'file'; inp.accept = 'application/json';
                inp.onchange = () => {
                    const f = inp.files?.[0]; if (!f) return;
                    f.text().then(t => {
                        const data = JSON.parse(t);
                        LS.set('graph.workspace', data);
                        loadGraph();
                        setBadge('Graph imported');
                    }).catch(e => setBadge('Import failed: ' + e.message, false));
                };
                inp.click();
            }

            function bindToolbar() {
                qs('#addASR')?.addEventListener('click', () => addNode('ASR', 90, 90));
                qs('#addLLM')?.addEventListener('click', () => addNode('LLM', 340, 120));
                qs('#addTTS')?.addEventListener('click', () => addNode('TTS', 640, 160));
                qs('#exportGraph')?.addEventListener('click', exportGraph);
                qs('#importGraph')?.addEventListener('click', importGraph);
            }

            function onResize() { drawAllLinks(); }

            function init() {
                WS.el = qs('#workspace'); WS.svg = qs('#linksSvg');
                bindToolbar(); bindModal();
                const hasSaved = !!LS.get('graph.workspace', null);
                if (!hasSaved) {
                    const a = addNode('ASR', 90, 200);
                    const l = addNode('LLM', 380, 180);
                    const t = addNode('TTS', 680, 200);
                    addLink(a.id, 'final', l.id, 'prompt');
                    addLink(l.id, 'final', t.id, 'text');
                } else {
                    loadGraph();
                }
                window.addEventListener('resize', onResize);
                setTimeout(drawAllLinks, 50);
            }

            return { init, addNode, save: saveGraph, load: loadGraph, getNode: (id) => WS.nodes.get(id) };
        })();


        /* ======== boot / bindings ======== */
        function bindUI() {
            // global
            const tr = qs('#transport'); if (tr) { tr.value = CFG.transport; tr.addEventListener('change', e => { CFG.transport = e.target.value; saveCFG(); if (CFG.transport === 'nkn') Net.ensureNkn(); setBadge('Saved') }) }
            const c1 = qs('#nknConnect'); if (c1) c1.addEventListener('click', () => Net.ensureNkn());
            const c2 = qs('#nknDisconnect'); if (c2) c2.addEventListener('click', () => { try { Net.nkn.client && Net.nkn.client.close() } catch { } Net.nkn.client = null; Net.nkn.ready = false; const i = qs('#nknInfo'); if (i) i.textContent = 'disconnected'; setBadge('NKN off') });
            const sv = qs('#saveAll'); if (sv) sv.addEventListener('click', () => { saveCFG(); setBadge('Saved') });

            // ASR inputs
            if (qs('#asrBase')) qs('#asrBase').value = CFG.asr.base; if (qs('#asrRelay')) qs('#asrRelay').value = CFG.asr.relay; if (qs('#asrApi')) qs('#asrApi').value = CFG.asr.api;
            if (qs('#asrRate')) qs('#asrRate').value = CFG.asr.rate; if (qs('#asrChunk')) qs('#asrChunk').value = CFG.asr.chunk; if (qs('#asrLive')) qs('#asrLive').value = String(!!CFG.asr.live);
            if (qs('#asrRms')) qs('#asrRms').value = CFG.asr.rms; if (qs('#asrHold')) qs('#asrHold').value = CFG.asr.hold; if (qs('#asrEmaMs')) qs('#asrEmaMs').value = CFG.asr.emaMs;
            if (qs('#asrPhraseOn')) qs('#asrPhraseOn').value = String(!!CFG.asr.phraseOn); if (qs('#asrPhraseMin')) qs('#asrPhraseMin').value = CFG.asr.phraseMin; if (qs('#asrPhraseStable')) qs('#asrPhraseStable').value = CFG.asr.phraseStable;
            if (qs('#asrSilence')) qs('#asrSilence').value = CFG.asr.silence;
            if (qs('#asrPrompt')) qs('#asrPrompt').value = CFG.asr.prompt || '';
            if (qs('#asrModel')) qs('#asrModel').value = CFG.asr.model || '';
            // load values
            if (qs('#asrMode')) qs('#asrMode').value = CFG.asr.mode || 'fast';
            if (qs('#asrPrevWin')) qs('#asrPrevWin').value = CFG.asr.prevWin || '';
            if (qs('#asrPrevStep')) qs('#asrPrevStep').value = CFG.asr.prevStep || '';
            if (qs('#asrPrevModel')) qs('#asrPrevModel').value = CFG.asr.prevModel || '';
            qsa('#asrCard, #llmCard, #ttsCard').forEach(el => el.classList.add('isHidden'));
            qsa('#asrCard input, #asrCard select, #asrCard textarea').forEach(el => el.addEventListener('change', () => {
                CFG.asr.base = qs('#asrBase')?.value.trim() || CFG.asr.base; CFG.asr.relay = qs('#asrRelay')?.value.trim() || ''; CFG.asr.api = qs('#asrApi')?.value.trim() || '';
                CFG.asr.rate = parseInt(qs('#asrRate')?.value || '16000', 10) || 16000; CFG.asr.chunk = parseInt(qs('#asrChunk')?.value || '120', 10) || 120;
                CFG.asr.live = (qs('#asrLive')?.value) === 'true';
                CFG.asr.rms = parseFloat(qs('#asrRms')?.value || '0.015') || 0.015; CFG.asr.hold = parseInt(qs('#asrHold')?.value || '250', 10) || 250; CFG.asr.emaMs = parseInt(qs('#asrEmaMs')?.value || '120', 10) || 120;
                CFG.asr.silence = parseInt(qs('#asrSilence')?.value || '900', 10) || 900;
                CFG.asr.phraseOn = (qs('#asrPhraseOn')?.value) === 'true'; CFG.asr.phraseMin = parseInt(qs('#asrPhraseMin')?.value || '3', 10) || 3; CFG.asr.phraseStable = parseInt(qs('#asrPhraseStable')?.value || '350', 10) || 350;
                CFG.asr.prompt = (qs('#asrPrompt')?.value || '').trim();
                CFG.asr.model = (qs('#asrModel')?.value || '').trim();
                saveCFG(); setBadge('Saved')
            }));
            const ab = qs('#asrStart'); if (ab) ab.addEventListener('click', () => ASR.start());
            const as = qs('#asrStop'); if (as) as.addEventListener('click', () => ASR.stop());
            const arf = qs('#asrRefresh'); if (arf) arf.addEventListener('click', () => ASR.refreshModels());

            // LLM inputs

            // Ensure LLM config defaults exist
            CFG.llm = Object.assign({
                base: '',
                relay: '',
                api: '',
                model: '',
                stream: true,
                useSystem: false,
                system: '',
                memoryOn: false,
                persistMemory: false,
                maxTurns: 16,
                memory: []   // persisted history (optional)
            }, CFG.llm || {});


            if (qs('#llmBase')) qs('#llmBase').value = CFG.llm.base; if (qs('#llmRelay')) qs('#llmRelay').value = CFG.llm.relay; if (qs('#llmApi')) qs('#llmApi').value = CFG.llm.api;
            if (qs('#llmStream')) qs('#llmStream').value = String(!!CFG.llm.stream);
            // New LLM memory/system UI defaults
            if (qs('#llmUseSystem')) qs('#llmUseSystem').value = String(!!CFG.llm.useSystem);
            if (qs('#llmSystem')) qs('#llmSystem').value = CFG.llm.system || '';
            if (qs('#llmMemory')) qs('#llmMemory').value = String(!!CFG.llm.memoryOn);
            if (qs('#llmPersistMemory')) qs('#llmPersistMemory').value = String(!!CFG.llm.persistMemory);
            if (qs('#llmMaxTurns')) qs('#llmMaxTurns').value = (CFG.llm.maxTurns ?? 16);
            if (qs('#llmMemSize')) qs('#llmMemSize').textContent = String((CFG.llm.memory && CFG.llm.memory.length) || 0);

            qsa('#llmCard input, #llmCard select, #llmCard textarea').forEach(el => el.addEventListener('change', () => {
                CFG.llm.base = qs('#llmBase')?.value.trim() || CFG.llm.base;
                CFG.llm.relay = qs('#llmRelay')?.value.trim() || '';
                CFG.llm.api = qs('#llmApi')?.value.trim() || '';
                CFG.llm.model = qs('#llmModel')?.value || CFG.llm.model;
                CFG.llm.stream = (qs('#llmStream')?.value) === 'true';

                // new fields
                CFG.llm.useSystem = (qs('#llmUseSystem')?.value) === 'true';
                CFG.llm.system = (qs('#llmSystem')?.value || '').trim();
                CFG.llm.memoryOn = (qs('#llmMemory')?.value) === 'true';
                CFG.llm.persistMemory = (qs('#llmPersistMemory')?.value) === 'true';
                CFG.llm.maxTurns = parseInt(qs('#llmMaxTurns')?.value || '16', 10) || 16;

                // in the big "qsa('#asrCard input, #asrCard select, #asrCard textarea')" listener, capture the new fields:
                CFG.asr.mode = (qs('#asrMode')?.value || 'fast');
                CFG.asr.prevWin = (qs('#asrPrevWin')?.value || '').trim();
                CFG.asr.prevStep = (qs('#asrPrevStep')?.value || '').trim();
                CFG.asr.prevModel = (qs('#asrPrevModel')?.value || '').trim();

                saveCFG(); setBadge('Saved');
            }));

            const lr = qs('#llmRefresh'); if (lr) lr.addEventListener('click', () => LLM.refreshModels());
            const lcm = qs('#llmClearMemory');
            if (lcm) lcm.addEventListener('click', () => {
                LLM.clearMemory();
                const ms = qs('#llmMemSize'); if (ms) ms.textContent = '0';
                setBadge('Memory cleared');
            });

            // TTS inputs
            if (qs('#ttsBase')) qs('#ttsBase').value = CFG.tts.base; if (qs('#ttsRelay')) qs('#ttsRelay').value = CFG.tts.relay; if (qs('#ttsApi')) qs('#ttsApi').value = CFG.tts.api;
            if (qs('#ttsModel')) qs('#ttsModel').value = CFG.tts.model || ''; if (qs('#ttsMode')) qs('#ttsMode').value = CFG.tts.mode || 'stream';
            qsa('#ttsCard input, #ttsCard select').forEach(el => el.addEventListener('change', () => {
                CFG.tts.base = qs('#ttsBase')?.value.trim() || CFG.tts.base; CFG.tts.relay = qs('#ttsRelay')?.value.trim() || ''; CFG.tts.api = qs('#ttsApi')?.value.trim() || '';
                CFG.tts.model = qs('#ttsModel')?.value.trim() || ''; CFG.tts.mode = qs('#ttsMode')?.value || 'stream'; saveCFG();
            }));
            const trf = qs('#ttsRefresh'); if (trf) trf.addEventListener('click', () => TTS.refreshModels());

            // wires
            const state = qs('#wireState'); if (state) state.textContent = CFG.wireMode ? 'ON' : 'OFF';
            const wt = qs('#wireToggle'); if (wt) wt.addEventListener('click', () => { CFG.wireMode = !CFG.wireMode; if (state) state.textContent = CFG.wireMode ? 'ON' : 'OFF'; saveCFG() });
            const cw = qs('#clearWires'); if (cw) cw.addEventListener('click', () => Router.clear());
        }

        function bindPorts() {
            // node-scoped ports are registered per-node in makeNodeEl()
            Router.render();
        }


        /* boot */
        function init() {
            bindUI(); bindPorts();
            Graph.init();
            if (!CFG.asr.prompt || !CFG.asr.prompt.trim()) {
                CFG.asr.prompt = ASR_DEFAULT_PROMPT;
                const p = qs('#asrPrompt'); if (p) p.value = CFG.asr.prompt;
                saveCFG();
            }
            if (CFG.transport === 'nkn') Net.ensureNkn();
            setBadge('Ready');
            ASR.refreshModels();
            ASR.refreshHealth(); // NEW
            LLM.refreshModels();
            TTS.refreshModels();
            const wb = qs('#wiresBox');
            if (wb) wb.textContent = CFG.wires.length ? CFG.wires.map((w, i) => `${i + 1}. ${w.from} → ${w.to}`).join('\n') : '(no wires)';
            Status.start();
        }

        document.addEventListener('DOMContentLoaded', init);

    </script>

</body>

</html>
